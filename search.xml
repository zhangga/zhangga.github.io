<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里云转战腾讯云-全纪录</title>
    <url>/ali2tx/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="机器迁移全记录。"><a href="#机器迁移全记录。" class="headerlink" title="机器迁移全记录。"></a>机器迁移全记录。</h1><p><a href="https://imgtu.com/i/hMnUVP"><a href="https://z3.ax1x.com/2021/08/27/hMnUVP.md.png" title="hMnUVP.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/27/hMnUVP.md.png" alt="hMnUVP.md.png"></a></a></p>
<span id="more"></span>

<h3 id="1-JDK"><a href="#1-JDK" class="headerlink" title="1.JDK"></a>1.JDK</h3><p>/usr/local/java/下，放jdk11和jdk1.8。default软连接到jdk11。</p>
<p>/etc/profile 文件加入环境变量指向default。执行source /etc/profile</p>
<h3 id="2-maven"><a href="#2-maven" class="headerlink" title="2.maven"></a>2.maven</h3><p>/usr/local/mvn/下，放maven解压包，加入环境变量。</p>
<h3 id="3-cmake"><a href="#3-cmake" class="headerlink" title="3.cmake"></a>3.cmake</h3><p>/opt下放cmake的解压包，加入环境变量。</p>
<h3 id="4-xampp"><a href="#4-xampp" class="headerlink" title="4.xampp"></a>4.xampp</h3><p>/opt下放xampp的安装文件，xampp-xxx.run文件。</p>
<p>chmod -R 755 xampp-linux-xxx-installer.run 添加执行权限。</p>
<p>./xampp-linux-xxx-installer.run 执行安装。</p>
<p>安装的过程就不多说了，也不用设置什么，无非就是问你时候确定一些选项，出现提问，直接按 回车 下去即可。xampp默认安装在/opt/lampp下</p>
<p>安装完毕之后，并没有运行，我们需要手动启动xampp服务，也就是启动apache，ftp和mysql这些服务器。使用命令</p>
<p>/opt/lampp/lampp start</p>
<p>此时，lampp组件就成功启动了，但它并不是每次随系统启动<br>输入以下命令<br>ln -s /opt/lampp/lampp /etc/rc.d/rc3.d/S99lampp<br>ln -s /opt/lampp/lampp /etc/rc.d/rc4.d/S99lampp<br>ln -s /opt/lampp/lampp /etc/rc.d/rc5.d/S99lampp</p>
<p>这样，就随系统启动了！</p>
<p>环境安装完了，但是MySQL的密码是多少，ftp的账号密码也是多少？我们不知道，这个默认为空，还需要我们自己设置。【要先在文本上面写好先在复制安全点，不然密码设置成什么自己都不记得了】输入命令</p>
<p>sudo /opt/lampp/lampp security</p>
<p>如图所示:他会依次要求你</p>
<p>1、先输入xampp控制面板的密码（用户名是xampp）；</p>
<p>2、输入phpmyadmin的密码（用户名是pma）</p>
<p>3、输入mysql的密码（用户名是root）</p>
<p>4、输入ftp密码（用户名是daemon，默认端口21）</p>
<p>9、在浏览器输入服务器的ip访问看一下成功了没有？</p>
<p>由于服务器设置了xampp不允许远程访问，所以远程不能访问需要修改conf文件</p>
<p>vi /opt/lampp/etc/extra/httpd-xampp.conf</p>
<p>将  Require local 改成 Require all granted</p>
<p>/opt/lampp/lampp restart 重启xampp</p>
<p>到此xampp安装完成</p>
<p>mysql指令无法执行，简单的方法是可以直接将/opt/lampp/bin/目录添加到环境变量中，这样就可以直接使用mysql和mysqldump命令了。</p>
<p>打开 ~/.bashrc 文件<br>在最后一行加入<br># PATH<br>export PATH=/opt/lampp/bin:$PATH<br>保存退出执行该文件中的命令<br>source ~/.bashrc</p>
<p>修改/opt/lampp/etc/my.cnf 配置文件，开放3306端口。可能需要重启服务器，注意查看下mysql是否启动在33066端口上。</p>
<h3 id="4-迁移wordpress。"><a href="#4-迁移wordpress。" class="headerlink" title="4.迁移wordpress。"></a>4.迁移wordpress。</h3><h3 id="5-redis迁移。"><a href="#5-redis迁移。" class="headerlink" title="5.redis迁移。"></a>5.redis迁移。</h3><h3 id="6-server和htdocs迁移。"><a href="#6-server和htdocs迁移。" class="headerlink" title="6.server和htdocs迁移。"></a>6.server和htdocs迁移。</h3><h2 id="7-maven私有仓库和SVN。"><a href="#7-maven私有仓库和SVN。" class="headerlink" title="7.maven私有仓库和SVN。"></a>7.maven私有仓库和SVN。</h2><p>8.nginx安装<a href="https://www.cnblogs.com/wyd168/p/6636529.html">https://www.cnblogs.com/wyd168/p/6636529.html</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>APP开发选型</title>
    <url>/app-dev/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="这次真的是从入坑到弃坑。最后还是觉得使用flutter"><a href="#这次真的是从入坑到弃坑。最后还是觉得使用flutter" class="headerlink" title="这次真的是从入坑到弃坑。最后还是觉得使用flutter"></a>这次真的是从入坑到弃坑。最后还是觉得使用flutter</h2><p>在使用weex做了一个简单的应用，调通通信和资源加载后，发现坑还是很多的。</p>
<p>主要weex适合用来做单页面的开发，开发完整的APP还是有一些局限性，在浏览器端调试也存在问题。</p>
<p>主要还是社区和文档很不齐全。</p>
<p>为什么选择flutter呢？</p>
<span id="more"></span>

<p>1.google爸爸背书。</p>
<p>2.dart开发。（自己对JS不熟悉。常年使用JAVA）</p>
<p>3.idea，和服务器端统一IDE。</p>
<p>4.flutter的理念才是跨平台的最终解决方案。</p>
<p>5.感觉不能再好了、</p>
<p>ps：就在前几天（2018.12.5）出正式1.0版本了</p>
<h2 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h2><p>最近有做一款APP的想法，调研下开发工具链。一直做游戏开发，引擎用过u3d，cocos，egret。</p>
<p>最终决定使用weex。</p>
<p>学习整理：</p>
<p><a href="https://segmentfault.com/a/1190000011027225">https://segmentfault.com/a/1190000011027225</a></p>
<p>html，css的基础知识；</p>
<p>Node：<a href="http://www.runoob.com/nodejs/nodejs-tutorial.html">《Node.js 教程》</a><br>Vue：<a href="https://cn.vuejs.org/v2/guide/">《Vue.js官方教程》</a><br>ES6：<a href="http://es6.ruanyifeng.com/">《ECMAScript 6 入门》</a></p>
<p>转载：<a href="https://www.jianshu.com/p/33246251cfae">https://www.jianshu.com/p/33246251cfae</a></p>
<h1 id="浅谈Native、Web-App、Hybrid、ReactNative和WEEX的优劣"><a href="#浅谈Native、Web-App、Hybrid、ReactNative和WEEX的优劣" class="headerlink" title="浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣"></a>浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣</h1><h1 id="一句话概要"><a href="#一句话概要" class="headerlink" title="一句话概要"></a>一句话概要</h1><blockquote>
<p>Native、Web App、Hybrid、ReactNative（后面以RN简称）、WEEX间的异同点</p>
</blockquote>
<h1 id="APP常用开发模式【简介】"><a href="#APP常用开发模式【简介】" class="headerlink" title="APP常用开发模式【简介】"></a>APP常用开发模式【简介】</h1><p>此处APP为应用，application，并非我们通常讲的手机App<br><a href="https://link.jianshu.com/?t=http://naotu.baidu.com/file/6af15fcbb72f89926043779811b1ea44?token=df0378691ecdcef2">常用的几种APP开发模式-脑图</a></p>
<h2 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h2><p>传统的原生APP开发模式，有IOS和AOS两大系统，需要各自语言开发各自APP。</p>
<p><strong>优点</strong>：性能和体验都是最好的<br><strong>缺点</strong>：开发和发布成本高<br><strong>举个栗子</strong>：<a href="https://link.jianshu.com/?t=https://id.163.com/gj/">网易管家APP</a> （Tab1，Tab2）<br><strong>应用技术</strong>：Swift，OC，JAVA</p>
<h2 id="WebApp"><a href="#WebApp" class="headerlink" title="WebApp"></a>WebApp</h2><p>移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application，再后面做介绍）对应。</p>
<p><strong>优点</strong>：开发和发布成本最低<br><strong>缺点</strong>：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量<br><strong>举个栗子</strong>：<a href="https://link.jianshu.com/?t=https://id.163.com/gj/">网易管家APP</a>（Tab3）<br><strong>应用技术</strong>：ReactJS，RegularJS等</p>
<h2 id="Hybrid-App"><a href="#Hybrid-App" class="headerlink" title="Hybrid App"></a>Hybrid App</h2><p>混合模式移动应用，介于web-app、native-app这两者之间的app，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）</p>
<p>主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用HTML+CSS实现界面，JS来写逻辑，调用API，最终的页面在webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所有有跨平台效果。</p>
<p><strong>优点</strong>：开发和发布都比较方便，效率介于Native App、Web App之间<br><strong>缺点</strong>：学习范围较广，需要原生配合<br><strong>举个栗子</strong>：<a href="https://link.jianshu.com/?t=https://music.163.com/#/download">网易云音乐</a>，我爱我家App<br><strong>应用技术</strong>：PhoneGap，AppCan，Wex5</p>
<h2 id="React-Native-App"><a href="#React-Native-App" class="headerlink" title="React Native App"></a>React Native App</h2><p>Facebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的APP开发方案RN App。。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。</p>
<p><strong>优点</strong>：效率体验接近Native App，发布和开发成本低于Native App<br><strong>缺点</strong>：学习有一定成本，且文档较少，免不了踩坑<br><strong>举个栗子</strong>：Facebook、youtube、discord、QQ、百度等等</p>
<h2 id="WEEX-App"><a href="#WEEX-App" class="headerlink" title="WEEX App"></a>WEEX App</h2><p>阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。</p>
<p><strong>优点</strong>：开发效率和体验上跟RN不相上下，并且跨平台性更强<br><strong>缺点</strong>：刚刚起步，社区没有RN活跃<br><strong>举个栗子</strong>：淘宝、天猫、饿了么等</p>
<h1 id="继续剖析"><a href="#继续剖析" class="headerlink" title="继续剖析"></a>继续剖析</h1><h2 id="Native-App-1"><a href="#Native-App-1" class="headerlink" title="Native App"></a>Native App</h2><p><a href="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-70fa348f3db0fca7.png?w=640" title="APP开发选型 - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-70fa348f3db0fca7.png?w=640" alt="APP开发选型 - 第1张  | 张嘎"></a></p>
<p>Native App是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序,也叫本地app。一般使用的开发语言为JAVA、C++、Objective-C。</p>
<p>自iOS和Android这两个的手机操作系统发布以来，在互联网界从此就多了一个新的名词：App意为运行在智能的移动终端设备第三方应用程序)。</p>
<p>Native App因为位于平台层上方，向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。但是比较乐观的是，AppStore培养了一种比较好的用户付费模式，所以在Apple的生态圈里，开发者的盈利模式是一种明朗状态，其他market也在往这条路上靠拢。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1、相比于其它模式，提供最佳的用户体验，最优质的用户界面，最华丽的交互<br>2、针对不同平台提供不同体验<br>3、可节省带宽成本，打开速度更快<br>4、功能最为强大,特别是在与系统交互中,几乎所有功能都能实现</p>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>1、门槛高，原生开发人才稀缺，至少比前端和后端少，开发环境昂贵<br>2、无法跨平台，开发的成本比较大，各个系统独立开发<br>3、发布成本高，需要通过store或market的审核，导致更新缓慢<br>4、维持多个版本、多个系统的成本比较高，而且必须做兼容<br>5、应用市场逐渐饱和，怎么样抢占用户时间需要投入大量时间和金钱，这也导致“僵尸”App的增多</p>
<h2 id="WebApp-1"><a href="#WebApp-1" class="headerlink" title="WebApp"></a>WebApp</h2><p><a href="https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-a16fa91905d4214e.png?w=640" title="APP开发选型 - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-a16fa91905d4214e.png?w=640" alt="APP开发选型 - 第2张  | 张嘎"></a></p>
<p>说到Web App不少人会联想到WAP，或者有人认为，WAP就是WebApp，其实不然。</p>
<p>WebApp与WAP最直接的区别就是功能层面。WAP更侧重使用网页技术在移动端做展示，包括文字、媒体文件等。而Web App更侧重“功能”，是使用网页技术实现的App。总的来说，Web App就是运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用。</p>
<p>响应式的大部分技术都是为实现WebApp能适配多类客户端而设计的。</p>
<p>Web网站一般分两种，MPA(Multi-page Application)和SPA(Single-page Application)。而WebApp一般泛指SPA形式开发出的网站。这样更像是一个App。</p>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>1、可以跨平台，调试方便<br>2、无需安装，不会占用手机内存，而且更新速度最快<br>3、不存在多版本问题，维护成本低<br>4、临时入口，可以随意嵌入</p>
<h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><p>1、依赖于网络，第一次访问页面速度慢，耗费流量<br>2、受限于手机和浏览器性能，用户体验相较于其他模式最差<br>3、功能受限，大量移动端功能无法实现<br>4、入口强依赖于第三方浏览器，且只能以URL地址的形式存在，导致用户留存率低（优点即缺点）</p>
<h2 id="Hybird-App"><a href="#Hybird-App" class="headerlink" title="Hybird App"></a>Hybird App</h2><p><a href="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-e8ed4f0375d2639b.png?w=640" title="APP开发选型 - 第3张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-e8ed4f0375d2639b.png?w=640" alt="APP开发选型 - 第3张  | 张嘎"></a></p>
<p>混合开发，也就是半原生半Web的开发模式，由原生提供统一的API给JS调用，实际的主要逻辑有Html和JS来完成，最终是放在webview中显示的，所以只需要写一套代码即可达到跨平台效果，另外也可以直接在浏览器中调试，很方便。最重要的是只需要一个前端人员稍微学习下JS api的调用即可。</p>
<p>Hybird App 的较早实践者是PhoneGap，随后遍地开花，如Titanium、Salama、WeX5、Kerkee和国内的AppCan，项目各有各的实现方式，大致的原理基本相同。有幸在AppCan上海总部参与过一段时间的学习研究，如下大致简介：</p>
<p>AppCan是基于HTML5技术的Hybird跨平台移动应用开发工具。开发者利用HTML5+CSS3+JavaScript技术，通过AppCan IDE集成开发系统、云端打包器等，快速开发出Android、iOS、WP平台上的移动应用。</p>
<p>AppCan的平台构成</p>
<p><a href="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-cd8c63378a612022.png?w=640" title="APP开发选型 - 第4张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-cd8c63378a612022.png?w=640" alt="APP开发选型 - 第4张  | 张嘎"></a></p>
<p>在实际的APP开发中，AppCan可以完成大部分的工作量，如图示：</p>
<p><a href="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-634591b2598fa8ad.png?w=640" title="APP开发选型 - 第5张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-634591b2598fa8ad.png?w=640" alt="APP开发选型 - 第5张  | 张嘎"></a></p>
<p>AppCan将APP底层复杂的原生功能封装在引擎、插件中，开发者仅需调用接口、打包编译，就可以获得原生功能；灵活的插件扩展机制。</p>
<p>开发者可以像开发WebApp一样开发app的视觉UI，以及绝大部分的交互，当需要使用原生功能（如摄像头，陀螺仪等功能）时，只需要调用官方的API就可以轻松实现Native的效果。至于JS和Native的通信，常用的有URL监听和绝大部分Hybrid厂商使用的JSBridge通信，两者原理相近。</p>
<p><a href="https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-400b4c6162d774f4.png?w=640" title="APP开发选型 - 第6张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-400b4c6162d774f4.png?w=640" alt="APP开发选型 - 第6张  | 张嘎"></a></p>
<p>JsBridge通信简图</p>
<p>关于JsBridge的原理详解，可见<a href="https://link.jianshu.com/?t=http://blog.csdn.net/xiangzhihong8/article/details/66970600">http://blog.csdn.net/xiangzhihong8/article/details/66970600</a></p>
<p>在Hybird概念盛行的时候，国内外各大公司也参与了探索，国外代表有Facebook、google、亚马逊，国内的有腾讯、阿里巴巴、网易等，慢慢的他们发现Hybird严重受限于WebView的解析渲染效率，于是Facebook开始了他的类原生的研究探索。</p>
<h2 id="React-Native-App-1"><a href="#React-Native-App-1" class="headerlink" title="React Native App"></a>React Native App</h2><p><a href="https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-846d1bcbe4f9b505.png?w=640" title="APP开发选型 - 第7张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-846d1bcbe4f9b505.png?w=640" alt="APP开发选型 - 第7张  | 张嘎"></a></p>
<p>请移驾 <a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000010989345">【笔记】React Native 快速入门笔记</a></p>
<h2 id="Weex-App"><a href="#Weex-App" class="headerlink" title="Weex App"></a>Weex App</h2><p><a href="https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-ec1e7c9c4de9f9c0.png?w=640" title="APP开发选型 - 第8张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-ec1e7c9c4de9f9c0.png?w=640" alt="APP开发选型 - 第8张  | 张嘎"></a></p>
<p>请移驾<a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000011027225">网易严选App感受Weex开发</a></p>
<p>作者：木羽zwwill<br>链接：<a href="https://www.jianshu.com/p/33246251cfae">https://www.jianshu.com/p/33246251cfae</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
<p>真的从入门到放弃，fluuter</p>
<p><a href="http://www.52im.net/thread-1870-1-1.html">http://www.52im.net/thread-1870-1-1.html</a></p>
<p><a href="https://www.jianshu.com/p/139c5074ae5d">https://www.jianshu.com/p/139c5074ae5d</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-结构化战略思维</title>
    <url>/booknote-mckinsey/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="麦肯锡五步法"><a href="#麦肯锡五步法" class="headerlink" title="麦肯锡五步法"></a>麦肯锡五步法</h2><p><a href="https://github.com/zhangga/picx-images-hosting/raw/master/booknote-mckinsiy1.1ape0smxzn.webp" title="pic1" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/booknote-mckinsiy1.1ape0smxzn.webp" alt="pic1"></a></p>
<ul>
<li>专家思维：“怎么做–实施的细节”</li>
<li>战略思维：“为什么–解决什么问题”</li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/booknote/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="一、Redis"><a href="#一、Redis" class="headerlink" title="一、Redis"></a>一、Redis</h1><p>1.《redis设计与实现》</p>
<p>2.《redis开发与运维》</p>
<span id="more"></span>

<h1 id="二、MySQL"><a href="#二、MySQL" class="headerlink" title="二、MySQL"></a>二、MySQL</h1><p>1.《MySQL技术内幕：InnoDB存储引擎》</p>
<h1 id="三、JAVA"><a href="#三、JAVA" class="headerlink" title="三、JAVA"></a>三、JAVA</h1><p>0.《Effective Java》</p>
<p>1.《Java程序性能优化》</p>
<p>2.《Java数据结构和算法》</p>
<p>3.《重构、改善既有代码的质量》</p>
<p>4.《深入理解Java虚拟机：JVM高级特性与最佳实现》</p>
<p>5.《Java并发编程的艺术》</p>
<p>6.《Java并发编程实战》  先读实战再读艺术</p>
<p>7.《分布式Java应用》</p>
<p>8.《自己动手写JAVA虚拟机》 </p>
<p>9.《Spring源码深度解析》</p>
<p>10.《深入浅出Spring Boot 2》</p>
<p>11.《JVM G1 源码分析和调优》 <strong>未读</strong></p>
<h1 id="四、技术"><a href="#四、技术" class="headerlink" title="四、技术"></a>四、技术</h1><p>1.《代码简洁之道》</p>
<p>2.《大话设计模式》</p>
<p>3.《垃圾回收的算法与实现》 <strong>50%</strong></p>
<p>4.《腾讯游戏开发精粹》 <strong>周末读</strong></p>
<p>5.《点石成金》 近期</p>
<p>6.《从小工到专家》 近期</p>
<p>7.《Clean Architecture: A Craftsman’s Guide to Software Structure and Design 》 购书清单</p>
<p>8.《DDIA：Designing Data-Intensive Applications。 》 购书清单</p>
<h1 id="五、综合"><a href="#五、综合" class="headerlink" title="五、综合"></a>五、综合</h1><p>1.《从领先到极致:互联网时代下的创业、创新与管理哲学》</p>
<p>2.《人月神话》</p>
<p>3.《影响力》</p>
<p>4.《自控力》</p>
<p>5.《情商》全6本 1/6</p>
<p>6.《如何阅读一本书》</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器被挖矿病毒感染！</title>
    <url>/cloud-ver/</url>
    <content><![CDATA[<div class=".article-gallery"><h4 id="记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。"><a href="#记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。" class="headerlink" title="记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。"></a><strong>记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。</strong></h4><p>一、3月13号发现服务器ssh连接困难，连上就掉线，根本无法操作，用top指令查看发现有进程名为：dblaunch高负载，占满cpu。没多想，联系腾讯云处理，最后给出的建议：做好快照，重启机器。腾讯帮忙注释掉了启动脚本中lampp中mysql的bin环境变量，现在来看，这个操作没任务作用。重启完后机器恢复正常，也就没再进一步追踪。</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1-3.png?resize=640,111" title="云服务器被挖矿病毒感染！ - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1-3.png?resize=640,111" alt="云服务器被挖矿病毒感染！ - 第1张  | 张嘎"></a></p>
<p>二、3月15号，公司下周去美国，需要搭建对外服务器在美国登陆，就部署到我的腾讯云服务器，由于我明天去日本的飞机，赶忙晚上部署服务器完毕，测试无恙，一切正常。</p>
<p>三、3月16号，在日本凌晨3点钟， 同事反应游戏服务器连不上，登陆ssh后台发现根本连不上， 再次联系腾讯云，最后还是强制重启解决，噩梦开始，由于人在日本，只能通过手机操作，没有别的办法，只能每天早上起床后第一件事就是重启机器，以保障美国方能正常展示游戏。</p>
<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2-2.png?resize=640,436" title="云服务器被挖矿病毒感染！ - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2-2.png?resize=640,436" alt="云服务器被挖矿病毒感染！ - 第2张  | 张嘎"></a></p>
<p>四、回国后开始排查问题，发现进程sustse跑满cpu，网上查看后才知道是被挖矿病毒感染，第一次服务器被病毒感染的经历。随后开始了各种尝试，试图删尽病毒，病毒的urlget地址为：<a href="http://107.174.47.156/mr.sh%E3%80%82%E5%9C%A8%E7%BB%8F%E8%BF%87%E4%BA%86%E5%90%84%E7%A7%8D%E5%AF%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8A%A0%E6%9D%83%E9%99%90%EF%BC%8C%E5%88%A0%E9%99%A4%E7%97%85%E6%AF%92%E6%96%87%E4%BB%B6%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%90%8E%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%91%E7%8E%B0%E8%BF%98%E6%98%AF%E5%BE%92%E5%8A%B3%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E4%BB%8E%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E7%97%85%E6%AF%92%E8%BF%98%E6%98%AF%E5%86%8D%E6%AC%A1%E5%87%BA%E7%8E%B0%EF%BC%8C%E8%85%BE%E8%AE%AF%E5%AE%98%E6%96%B9%E7%BB%99%E5%87%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E4%B9%9F%E6%98%AF%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E6%B0%B8%E8%BF%9C%E4%B9%9F%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BA%86%E7%97%85%E6%AF%92%E8%A2%AB%E5%88%A0%E9%99%A4%E5%B9%B2%E5%87%80%EF%BC%8C%E5%9C%A8%E8%BF%99%E6%A0%B7%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AE%B9%E8%B6%8A%E5%A4%9A%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%88%90%E6%9C%AC%E5%92%8C%E9%A3%8E%E9%99%A9%E8%B6%8A%E5%A4%A7%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%AA%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E3%80%82">http://107.174.47.156/mr.sh。在经过了各种对文件夹加权限，删除病毒文件及各种定时任务后，最后发现还是徒劳，不知道从什么地方病毒还是再次出现，腾讯官方给出的建议也是重装系统，因为你永远也保证不了病毒被删除干净，在这样的机器上继续使用的话，自己的内容越多，文件丢失的成本和风险越大，最后只能重装系统，重新部署环境。</a></p>
<p>五、经此一役和挖矿病毒的斗争，或者说被虐也好，教训就是，做好服务器的快照备份，数据无价，万一真的丢失了恢复不了，那是真崩了。还好这次没什么重大损失。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos creator使用protobuf ts版</title>
    <url>/cc-proto/</url>
    <content><![CDATA[<div class=".article-gallery"><p>一、安装npm nodejs下的包管理器</p>
<p>官网：<a href="https://nodejs.org/">https://nodejs.org</a>  下载最新稳定版安装。如node-v8.11.4-x64.msi。</p>
<span id="more"></span>

<p>双击安装</p>
<p>一路点next下去，安装完成。</p>
<p>在nodejs文件夹下新建两个文件夹：node_cache、node_global。</p>
<p>然后运行以下两条命令：</p>
<h3 id="npm-config-set-prefix-“D-IDE-nodejs-node-global”"><a href="#npm-config-set-prefix-“D-IDE-nodejs-node-global”" class="headerlink" title="npm config set prefix “D:\IDE\nodejs\node_global”"></a>npm config set prefix “D:\IDE\nodejs\node_global”</h3><h3 id="npm-config-set-cache-“D-IDE-nodejs-node-cache”"><a href="#npm-config-set-cache-“D-IDE-nodejs-node-cache”" class="headerlink" title="npm config set cache “D:\IDE\nodejs\node_cache”"></a>npm config set cache “D:\IDE\nodejs\node_cache”</h3><h3 id="npm-config-set-registry-http-registry-npm-taobao-org-配置镜像站"><a href="#npm-config-set-registry-http-registry-npm-taobao-org-配置镜像站" class="headerlink" title="npm config set registry=http://registry.npm.taobao.org  配置镜像站"></a>npm config set registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>  配置镜像站</h3><p>配置完后使用npm config list显示所有配置信息。</p>
<h3 id="增加环境变量NODE-PATH-内容是：D-IDE-nodejs-node-global-node-modules"><a href="#增加环境变量NODE-PATH-内容是：D-IDE-nodejs-node-global-node-modules" class="headerlink" title="增加环境变量NODE_PATH 内容是：D:\IDE\nodejs\node_global\node_modules"></a>增加环境变量NODE_PATH 内容是：D:\IDE\nodejs\node_global\node_modules</h3><p>重启命令行生效。</p>
<p>二、安装protobufjs</p>
<p>命令行执行：npm init</p>
<p>然后安装：npm install protobufjs -g</p>
<p>安装成功后，在nodejs\node_global文件夹下有对应文件。</p>
<p>三、生成js、ts文件</p>
<p>编写proto文件。</p>
<p>进入node_modules.bin目录，或者添加到环境变量path里<br>* 第一步生成js:<br>* pbjs -t static-module -w commonjs -o test.js test.proto<br>* 第二步生成ts:<br>* pbts -o test.d.ts test.js</p>
<p>四、项目中使用proto</p>
<p>在项目的根目录下，运行命令</p>
<p>npm init</p>
<p>npm install protobufjs</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Debugging Go compiler performance in a large codebase[zz]</title>
    <url>/debug-go-compiler/</url>
    <content><![CDATA[<div class=".article-gallery"><p>zz: <a href="https://incident.io/blog/go-build-faster">https://incident.io/blog/go-build-faster</a></p>
<p>As <a href="https://incident.io/blog/monolith">we’ve talked about before</a>, our app is a monolith: all our backend code lives together and gets compiled into a single binary. One of the reasons I prefer monolithic architectures is that they make it much easier to focus on shipping features without having to spend much time thinking about where code should live and how to get all the data you need together quickly.</p>
<p>However, I’m not going to claim there aren’t disadvantages too. One of those is compile times. Because all the backend code needs to be built into a single artefact, the time it takes to do that inevitably increases as the amount of code to compile grows.</p>
<p>That’s bad for shipping quickly: a slower build means it takes longer to get code from “pull request merged” to “running for customers”. It’s also bad for developer experience: time spent waiting for the compiler isn’t productive time, and it can really break your flow.</p>
<p>While <a href="https://incident.io/blog/festive-macbooks">faster MacBooks can make a big difference</a>, we can also apply some performance-optimising tools that come with Golang to figure out where the bottlenecks are and remove them!</p>
<h2 id="Visualising-the-build-process"><a href="#Visualising-the-build-process" class="headerlink" title="Visualising the build process"></a>Visualising the build process</h2><p>The first thing to note is that the Go compiler caches previously-compiled code, so to get a clearer picture of the <em>worst case</em> scenario, I cleared that cache before each run, using <code>go cache -clean</code>.</p>
<p>Looking at the docs, there are a few interesting-looking flags you can pass to <code>go build</code>:</p>
<ul>
<li><code>-debug-actiongraph</code> - this tells you what the compiler is doing at different points, and can be inspected with <a href="https://github.com/icio/actiongraph">https://github.com/icio/actiongraph</a>.</li>
<li><code>-debug-trace</code> - this produces a trace, which can be visualised in a tool like <a href="https://ui.perfetto.dev/#!/viewer">Perfetto</a></li>
</ul>
<p>I found the trace view felt more familiar: at <a href="http://incident.io/">incident.io</a> we debug things by reading traces <em>all the time</em>, and the Perfetto UI is really familiar if you’ve had to optimise JavaScript performance with the Chrome DevTools before.</p>
<p>So, with a clean cache, I ran <code>go build ./cmd/app/ -debug-trace=tmp/trace.json</code>, and dropped that into Perfetto:</p>
<p><a href="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/b145104608fe8490391ffc0a4047167e34a12e45-2648x1516.png?q=75&fit=clip&auto=format&w=3840&q=75" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/b145104608fe8490391ffc0a4047167e34a12e45-2648x1516.png?q=75&fit=clip&auto=format&w=3840&q=75" alt="img"></a></p>
<p>Well, that is pretty, but what does it tell us? Broadly there’s three phases:</p>
<ol>
<li>Planning: up at the top-left, there’s a bunch of short spans which are the compiler figuring out which packages import which other packages, and planning out the build. This is pretty quick!</li>
<li>Next there’s a <em>really dense</em> set of spans: this is almost entirely compiling external dependencies. This uses all 8 cores and isn’t all that interesting to us: these packages don’t change much and therefore the build cache should be very effective at avoiding recompiling them.</li>
<li>At about 25s in, we finally start compiling our own code. This code has a lot more dependencies between packages, which creates those gaps where every package waiting to be compiled imports something that is currently being compiled, and so has to wait.</li>
</ol>
<p>At this point, there’s only really one path to making this faster: eliminating as much of the empty space in the trace where there’s only one or two cores doing any work.</p>
<p>The first thing to tackle is the turquoise span I’ve circled. That’s a package called <code>./pkg/domain</code>, which defines a struct for each table in our database. Things like:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Incident</span> struct &#123;</span><br><span class="line">  <span class="variable constant_">ID</span> <span class="built_in">string</span></span><br><span class="line">  <span class="title class_">Name</span> <span class="built_in">string</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It makes sense that a <em>lot</em> of our code will import that package: if you’re using the database, you need to! It also makes sense that it’s a relatively big package, since we have around 250 tables. Once you add in the <a href="https://incident.io/blog/code-generation#builders">builders we generate</a>, that gets up to around 800 files, containing almost 100k lines of code.</p>
<p>To speed things up there were two strategies I tried:</p>
<h2 id="Start-sooner-finish-sooner"><a href="#Start-sooner-finish-sooner" class="headerlink" title="Start sooner, finish sooner"></a>Start sooner, finish sooner</h2><p>The first option I tried at this point was removing dependencies from <code>pkg/domain</code>, so the compiler could get started on building it sooner.</p>
<p>We were already using a great little linter called <code>depguard</code> to set rules that help us avoid import cycles. I started off setting an ultra-strict rule, saying <code>pkg/domain</code> cannot import anything except the standard library:</p>
<p><a href="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/58a6bc56a12beb19c09887c55f07455e3fe744df-1594x1074.png?q=75&fit=clip&auto=format&w=3840&q=75" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/58a6bc56a12beb19c09887c55f07455e3fe744df-1594x1074.png?q=75&fit=clip&auto=format&w=3840&q=75" alt="img"></a></p>
<p>This produced a <em>long</em> list of violations! Working through those one-by-one let me check each of the packages we were importing and either add them to the <code>allow</code> list, or figure out how to break that dependency.</p>
<p>After breaking each dependency I cleared the cache and did a fresh build to see if the trace had really changed much. The biggest improvement was removing the dependency on <a href="https://github.com/yuin/goldmark">yuin/goldmark</a>, a markdown parsing library, which allowed these two large packages to be compiled in parallel, and got <code>pkg/domain</code> started at around 15s in, rather than 25s!</p>
<p><a href="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/4063c53eff31d8458b730265277e711dada2d686-2656x1462.png?q=75&fit=clip&auto=format&w=3840&q=75" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/4063c53eff31d8458b730265277e711dada2d686-2656x1462.png?q=75&fit=clip&auto=format&w=3840&q=75" alt="img"></a></p>
<h2 id="Break-it-up"><a href="#Break-it-up" class="headerlink" title="Break it up"></a>Break it up</h2><p>That helped a lot with the worst case compile without anything cached. Luckily, that’s not all that common: a more frequent situation is that someone has changed a file inside <code>pkg/domain</code>. In that case, the compiler will recompile that package <em>plus anything that imports it</em>, which here means pretty much the whole app! A trace of that looks something like this:</p>
<p><a href="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/978bb9ee4a6228f6329ea7fe5b1bd27bf61970c8-3600x542.png?q=75&fit=clip&auto=format&w=3840&q=75" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/978bb9ee4a6228f6329ea7fe5b1bd27bf61970c8-3600x542.png?q=75&fit=clip&auto=format&w=3840&q=75" alt="img"></a></p>
<p>Look at all those sad, bored CPUs not doing anything while we’re building <code>pkg/domain</code>!</p>
<p>The only solution here is to make this package smaller. At first that seemed like a pretty complex task: there are lots of bidirectional relationships between different structs in this code for good reason! For example, we have code like this:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in incident.go</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Incident</span> struct &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">IncidentUpdates</span> []*<span class="title class_">IncidentUpdate</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in incident_update.go</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IncidentUpdate</span> struct &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Incident</span> *<span class="title class_">Incident</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This lets us write code that loads both an incident with all its updates, or an update with the incident it belongs to. Splitting these across two packages creates an import cycle.</p>
<p>That’s just one example - splitting this package up seemed like a recipe for nasty import cycles and unhappy engineers.</p>
<p>Luckily, there was another axis to split this code along: app code vs test code. We <a href="https://incident.io/blog/code-generation#matchers">generate type-safe <code>gomega</code> matchers</a> for each of these domain types, to make writing tests like this really simple:</p>
<p><a href="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/ae6d4d76526bacf5a0f1b698937d547b279c42a4-1102x578.png?q=75&fit=clip&auto=format&w=3840&q=75" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/ae6d4d76526bacf5a0f1b698937d547b279c42a4-1102x578.png?q=75&fit=clip&auto=format&w=3840&q=75" alt="img"></a></p>
<p>That’s a big chunk of code that could live in a separate package, that will only be imported by tests. Moving those out into <code>pkg/domain/matchers</code> reduced the time to compile <code>pkg/domain</code> by about 30%, which adds up pretty quickly when that package get rebuilt 10-20 times a day across the team.</p>
<p>That same example now looks like this:</p>
<p><a href="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/be4a5b2c81b238dda65376921db0ef02b58e8257-1120x578.png?q=75&fit=clip&auto=format&w=3840&q=75" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://incident.io/_next/image?url=https://cdn.sanity.io/images/oqy5aexb/production/be4a5b2c81b238dda65376921db0ef02b58e8257-1120x578.png?q=75&fit=clip&auto=format&w=3840&q=75" alt="img"></a></p>
<h2 id="What-did-I-learn"><a href="#What-did-I-learn" class="headerlink" title="What did I learn?"></a>What did I learn?</h2><p>Developer tools like compilers can feel strange and scary if (like me) you’ve never really taken a look at what they’re doing. When you find something annoying about them, like a slow build or a dodgy error message it’s all <em>just more code</em> that you can use your normal skills and tools to work on.</p>
<p>Your teammates will appreciate it 🫶</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Debugging Remotely with Go in Kubernetes[zz]</title>
    <url>/debug-remote-go-k8s/</url>
    <content><![CDATA[<div class=".article-gallery"><p>zz: <a href="https://alexsniffin.medium.com/debugging-remotely-in-kubernetes-with-go-fda4f3332316">https://alexsniffin.medium.com/debugging-remotely-in-kubernetes-with-go-fda4f3332316</a></p>
<p>Proper testing can be difficult and even seem impossible. Following best practices to test your code is a good start, but you’re still going to run into edge cases where things aren’t as expected. One challenge in particular, is being able to accurately simulate your deployments remote environment.</p>
<p>Figuring out the inconsistencies to why your program works on your local machine but not on another machine can be painstakingly frustrating. Maybe it’s the version of your compiler, your operating system, configuration, or certain dependencies that were missed— etcetera-etcetera.</p>
<p>This has been a common problem with software development and why the rise of <a href="https://www.ibm.com/topics/containerization">virtualization and containerization have become so popular, especially in cloud-based applications</a>. Even so, things can still go wrong with your VM’s and containers.</p>
<p>Let’s take a look into how debugging your application’s runtime in it’s deployed environment can help you quickly find the root cause to what isn’t working as expected. For this example we’ll use Go to write the application and deploy it to Kubernetes in a Docker container.</p>
<h1 id="Example-Code"><a href="#Example-Code" class="headerlink" title="Example Code"></a>Example Code</h1><p>Lets create a simple API that can calculate a value in the Fibonacci sequence that we want to be able to debug. I’ll be using <a href="https://github.com/go-chi/chi">Chi</a> as the router and then use the <a href="https://pkg.go.dev/net/http@go1.19.3">stdlib</a> to run the server. I’ve tried to keep the example simple, you can checkout the <a href="https://github.com/alexsniffin/go-blog3-example">repo</a> to see all of the code.</p>
<p>Let’s first create a handler that takes a query parameter of n and calls the Fibonacci function.</p>
<iframe src="https://alexsniffin.medium.com/media/ab6e886ad4073a10f0ee293e70940f46" allowfullscreen="" frameborder="0" height="307" width="680" title="Blog3Example1_1.go" class="fp n gf dv bg" scrolling="no" style="box-sizing: inherit; top: 0px; width: 680px; height: 307px; position: absolute; left: 0px;"></iframe>

<p>Then for the Fibonacci function, I wrote the <a href="https://www.geeksforgeeks.org/what-is-memoization-a-complete-tutorial/">memoized</a> implementation.</p>
<iframe src="https://alexsniffin.medium.com/media/8a2375ee5e2710f323efc71d9763427b" allowfullscreen="" frameborder="0" height="329" width="680" title="Blog3Example1_1.go" class="fp n gf dv bg" scrolling="no" style="box-sizing: inherit; top: 0px; width: 680px; height: 329px; position: absolute; left: 0px;"></iframe>

<h1 id="Remote-Debugging"><a href="#Remote-Debugging" class="headerlink" title="Remote Debugging"></a>Remote Debugging</h1><p>To debug the container we’ll need to set up remote debugging, to do this, we can use the popular Go debugger <a href="https://github.com/derekparker/delve">Delve</a>. Delve supports attaching to a process and will allow us to introspect our application in the runtime. To debug, Delve is supported in a few IDE’s and editors including <a href="https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/">GoLand</a> and <a href="https://code.visualstudio.com/docs/languages/go#_debugging">VS Code</a>. For this example I’ll be using GoLand.</p>
<p>We’ll need a Dockerfile which has the Delve binary in it which we’ll be able to remotely execute the application binary. The command I’ll be using is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dlv --listen=:40000 --headless=true --api-version=2 --log exec ./example</span><br></pre></td></tr></table></figure>

<p>Where the listening port is 40,000 and it points to the example binary. The complete Dockerfile downloads Delve, builds the app, and starts the Delve process.</p>
<iframe src="https://alexsniffin.medium.com/media/55081a02d05948e449d3bc87c0d1541c" allowfullscreen="" frameborder="0" height="637" width="680" title="Blog3Example1_3.debug.Dockerfile" class="fp n gf dv bg" scrolling="no" style="box-sizing: inherit; top: 0px; width: 680px; height: 637px; position: absolute; left: 0px;"></iframe>

<p>When running the container, we want to make sure we set the binded ports to map with what we’re using for the example app and Delve. The following build and run commands will work for this example.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t go-blog3-example -f .\debug.Dockerfile .</span><br><span class="line">docker run -p 8080:8080 -p 40000:40000 --name example go-blog3-example:latest</span><br></pre></td></tr></table></figure>

<p>Similarly, we can use the interface in GoLand to do this too.</p>
<p><a href="https://miro.medium.com/v2/resize:fit:700/1*LRql3LDD2wVDg1jgLz3V_g.png" title="docker in goland" class="gallery-item" style="box-shadow: none;"> <img src="https://miro.medium.com/v2/resize:fit:700/1*LRql3LDD2wVDg1jgLz3V_g.png" alt="docker in goland"></a></p>
<p>Now for the fun part, lets remotely connect! In GoLand we can do this by creating a new Run configuration with the Go Remote option.</p>
<p><a href="https://miro.medium.com/v2/resize:fit:211/1*ElWmHRQ1vlOoZ_IVnUDi_Q.png" title="run configuration for go remote" class="gallery-item" style="box-shadow: none;"> <img src="https://miro.medium.com/v2/resize:fit:211/1*ElWmHRQ1vlOoZ_IVnUDi_Q.png" alt="run configuration for go remote"></a></p>
<p>Then using the following settings.</p>
<p><a href="https://miro.medium.com/v2/resize:fit:700/1*_xrt7a_nDH0kZQ3bfahoeQ.png" title="go remote settings" class="gallery-item" style="box-shadow: none;"> <img src="https://miro.medium.com/v2/resize:fit:700/1*_xrt7a_nDH0kZQ3bfahoeQ.png" alt="go remote settings"></a></p>
<p>With the container running, we should be able to remotely start the debugging session.</p>
<p><a href="https://miro.medium.com/v2/resize:fit:588/1*BV7-2OOWvPpwgN8i55LYyA.png" title="debug window" class="gallery-item" style="box-shadow: none;"> <img src="https://miro.medium.com/v2/resize:fit:588/1*BV7-2OOWvPpwgN8i55LYyA.png" alt="debug window"></a></p>
<p>Awesome! That’s it but now lets see how we can utilize this through Kubernetes with a pod to debug the container in the same environment that it normally runs in.</p>
<h1 id="Debugging-the-Pod"><a href="#Debugging-the-Pod" class="headerlink" title="Debugging the Pod"></a>Debugging the Pod</h1><p>Lets say we currently already have the container running normally as a Deployment and it’s currently receiving traffic. We’ve noticed that there’s odd behavior happening and we can’t accurately replicate what’s happening locally. For this, we’ll want to stand up a new pod along side our current deployment and start debugging.</p>
<p>To do this, we can add the new container as a standalone pod from the normal deployment. If you have additional resources that you’ll need, you’ll want to be sure to include them too. You can do that with kubectl apply, your Kubernetes package manager or CD tool.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; kubectl run example --image=asniffin/go-blog3-example:latest --namespace=blog</span><br><span class="line">pod/example created</span><br></pre></td></tr></table></figure>

<p>We should be able to check the state of the pod and see it’s running.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; kubectl describe pod example --namespace=blog</span><br><span class="line">...</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Then checking the logs, we can see that it’s listening for a connection.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; kubectl logs example --namespace=blog</span><br><span class="line">API server listening at: [::]:40000</span><br><span class="line">2022-11-23T18:37:00Z warning layer=rpc Listening for remote connections (connections are not authenticated nor encrypted)</span><br><span class="line">2022-11-23T18:37:00Z info layer=debugger launching process with args: [./example]</span><br></pre></td></tr></table></figure>

<p>Now to debug from our local machine, we need to tunnel to the pod with the correct ports and protocol. To do this, we can use the port-forward kubectl command provided our pod and ports.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; kubectl port-forward pods/example 8080:8080 40000:40000 --namespace=blog</span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:40000 -&gt; 40000</span><br><span class="line">Forwarding from [::1]:40000 -&gt; 40000</span><br></pre></td></tr></table></figure>

<p>Now when running the remote debugger we should be able to connect and start debugging! Let’s try with sending a request to the fib endpoint.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; curl http://localhost:8080/fib?n=10</span><br><span class="line">55</span><br></pre></td></tr></table></figure>

<p><a href="https://miro.medium.com/v2/resize:fit:621/1*YngWz7M0Y419StR8H2G9nQ.png" title="debug window from kubernetes" class="gallery-item" style="box-shadow: none;"> <img src="https://miro.medium.com/v2/resize:fit:621/1*YngWz7M0Y419StR8H2G9nQ.png" alt="debug window from kubernetes"></a></p>
<p>Nice 😎! We can see that we’re able to both debug and send requests to the pod. With this, we can accurately debug the container and pod in the same environment where it’s deployed and with all of it’s remote resources. Remember to remove your pod when you’ve finished!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; kubectl delete pod example --namespace=blog</span><br><span class="line">pod &quot;example&quot; deleted</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Debugging is an effective tool that every developer should keep on their tool belt. When it’s difficult to simulate your applications environment, being able to accurately pinpoint the root cause to a problem can prove to be difficult. Remotely debugging your application lets you quickly introspect the runtime and observe the behavior of your application.</p>
<p>Thanks for reading!</p>
<p><em>Disclaimer: Doing this in production should be done with caution, probably best left in a development or QA environment!</em></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式笔记</title>
    <url>/design-mode/</url>
    <content><![CDATA[<div class=".article-gallery"><p>1.简单工厂模式</p>
<p>2.策略模式</p>
<span id="more"></span>

<p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
<p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。</p>
<p>3.单一职责原则</p>
<p>规则总是很美好，呵呵</p>
<p>就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p>
<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p>
<p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>
<p>4.开放-封闭原则</p>
<p>开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。</p>
<p>对于扩展是开放的，对于更改是封闭的。</p>
<p>无论模块是多么封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。</p>
<p>等到变化发生时立即采取行动。</p>
<p>开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
<p>5.依赖倒转原则</p>
<p>高层模块不应该依赖低层模块，两个都应该依赖抽象。</p>
<p>抽象不应该依赖细节，细节应该依赖抽象。</p>
<p>里氏代换原则：子类型必须能够替换掉它们的父类型。</p>
<p>6.装饰模式</p>
<p>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person穿衣服为例：</span><br><span class="line">abstract class Show &#123;</span><br><span class="line"></span><br><span class="line">public abstract void show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Persion : Show &#123;</span><br><span class="line"></span><br><span class="line">public override void show() &#123; 具体实现 &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Decorator : Show &#123;</span><br><span class="line"></span><br><span class="line">protected Show show;</span><br><span class="line"></span><br><span class="line">public void setDecorator(Show show) &#123;</span><br><span class="line"></span><br><span class="line">this.show = show;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override void show() &#123;</span><br><span class="line"></span><br><span class="line">if (show != null) &#123;</span><br><span class="line"></span><br><span class="line">show.show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DecoratorA : Decorator &#123;</span><br><span class="line"></span><br><span class="line">public override void show() &#123; super.show(); 具体实现; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">装饰模式：</span><br><span class="line"></span><br><span class="line">Person p = new Person();</span><br><span class="line"></span><br><span class="line">DecoratorA da = new DecoratorA();</span><br><span class="line"></span><br><span class="line">DecoratorB db = new DecoratorB();</span><br><span class="line"></span><br><span class="line">DecoratorC dc = new DecoratorC();</span><br><span class="line"></span><br><span class="line">da.setDecorator(p);</span><br><span class="line"></span><br><span class="line">db.setDecorator(da);</span><br><span class="line"></span><br><span class="line">dc.setDecorator(db);</span><br><span class="line"></span><br><span class="line">dc.show();</span><br></pre></td></tr></table></figure>

<p>7.代理模式</p>
<p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>
<figure class="highlight plaintext"><figcaption><span>class Subject &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">public abstract void request();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealSubject : Subject &#123;</span><br><span class="line"></span><br><span class="line">public override void request() &#123;实现&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy : Subject &#123;</span><br><span class="line"></span><br><span class="line">RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">public override void request() &#123;</span><br><span class="line"></span><br><span class="line">realSubject.request();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Client:</span><br><span class="line"></span><br><span class="line">Proxy proxy = new Proxy();</span><br><span class="line"></span><br><span class="line">proxy.request();</span><br></pre></td></tr></table></figure>

<p>8.工厂方法模式</p>
<p>9.原型模式</p>
<p>对象拷贝。深拷贝。浅拷贝。</p>
<p>10.模板方法模式</p>
<p>11.迪米特法则</p>
<p>迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
<p>强调类之间的松耦合。</p>
<p>12.外观模式</p>
<p>13.建造者模式</p>
<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</p>
<p>14.观察者模式</p>
<p>当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。</p>
<p>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>
<p>总结：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p>
<p>C#的委托delegate</p>
<p>委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看做是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。</p>
<p>一个委托可以搭载多个方法，所有方法被依次唤起。可以使得委托对象所搭载的方法并不需要属于同一个类。</p>
<p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</p>
<p>15.抽象工厂模式</p>
<p>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>16.状态模式</p>
<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p>
<p>17.适配器模式</p>
<p>适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作了。</p>
<p>18.备忘录模式</p>
<p>备忘录：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p>19.组合模式</p>
<p>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>20.迭代器模式</p>
<p>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>
<p>21.单例模式</p>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式和静态工具类Static方法的区别：静态工具类不保存状态，仅提供一些静态方法或静态属性来让你使用，而单例类是有状态的。静态工具类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。静态类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。</p>
<h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;    // 加volatile的作用，防止singleton变量在new的时候引用逃逸</span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22.桥接模式</p>
<p>合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。组合优于继承。</p>
<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>
<p>23.命令模式</p>
<p>24.职责链模式</p>
<p>职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>25.中介者模式</p>
<p>26.享元模式</p>
<p>27.解释器模式</p>
<p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p>28.访问者模式</p>
<p>访问者模式：表示一个作用于某对象结构中的各元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>容器的网络模式</title>
    <url>/docker-net/</url>
    <content><![CDATA[<div class=".article-gallery"><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>独立netns隔离了网络，容器间网络不互相影响，容器内的IP地址是私有网段，仅本地可见，通过NAT与外部交互</p>
<p>Bridge 模式可以看作服务被放在一个独立的网络空间里，它的 IP 是一个虚拟 IP，任何的端口都是可以使用的。但是对外提供服务的时候，需要通过 NAT 转发。</p>
<span id="more"></span>

<p>需要进行的配置：</p>
<ul>
<li><p>配置服务信息中需要填写一个服务主端口</p>
</li>
<li><p>配置以后的实例列表：</p>
<p>可以看到，Bridge 模式下的实例会有不同的 NodeIP 和内部 IP，内部 IP 是一个虚拟 IP，它通过 NAT 转发映射到 NodeIP。内部端口是配置的固定端口，访问端口是动态配置的转发端口。</p>
</li>
</ul>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>标准的Host网络</p>
<p>Host 模式使用的是宿主机的端口，相比 Bridge 而言，少了一次内核栈的调用，也没有 NAT 转发的损耗。对于高吞吐，或有大文件传输的业务服务而言，Bridge 模式不符合性能要求，所以架构组又推出来了 Host 模式。</p>
<p>在  Host 模式下，服务端口都是平台自动分配的，因此不同的实例端口可能不同。平台会根据每台机器的可用端口，按照服务的需要，分配给实例对应的端口并保存在环境变量中，从 PORT0 开始保存。</p>
<p>例如，服务需要一个端口（配置的是 4608），平台会分配两个可用端口（9001、9002），写到环境变量 PORT0 和 PORT1 中，因此需要服务自己进行动态的配置和替换。</p>
<p>在环境变量中，”$IS_HOST_NETWORK” == “1” 表示 Host 模式。</p>
<h3 id="Auto-Host"><a href="#Auto-Host" class="headerlink" title="Auto Host"></a>Auto Host</h3><p>通过hookbind重映射bind的端口号，其他行为同Host</p>
<p>在上面的 Host 模式中，平台把动态分配端口的使用权下放给了应用，需要应用自己进行复杂的配置，并在应用中动态修改配置，有比较高的维护成本。另外，如果选择 Host 模式，但是依旧按照 Bridge 的方式进行配置，则有产生端口冲突的风险。于是架构组又推出了 Auto Host 模式。</p>
<p>Auto Host 模式的做法是在内核层对 syscall 的 listen api 进行截获，然后替换上动态分配的端口。</p>
<p>Auto Host 模式需要进行的配置与 Bridge 模式有两点不同：</p>
<ul>
<li>选择不同的模式</li>
<li>需要配置的端口数与 Host 模式相同，是 Bridge 模式的两倍，Bridge 模式只要配置 uwsgi 的端口，这边需要 uwsgi 和 nginx 的端口</li>
</ul>
<p>Auto Host 模式启动以后的实例列表，这边由于不需要进行 NAT 转发，因此 NodeIP 和 内部 IP是一样的，9003 和 9006 是平台动态分配的端口。</p>
<p><strong>以下全文仅讨论Bridge网络模式，Host网络的隔离性以及功能扩展性远不如Bridge，且Bridge在BPF加速后，</strong>性能略高于Host网络。</p>
</div>]]></content>
      <categories>
        <category>服务器技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>容器下设置正确的GOMAXPROCS</title>
    <url>/docker-setgomax/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>跑在k8s容器的战斗验证服务启动了比resource limit更多的worker</p>
<p><code>runtime.GOMAXPROCS</code> 默认设置为物理核心数。但当在加了resource limit的容器下 <code>runtime.GOMAXPROCS()</code> 获得的不是被限额的，依然是宿主机器的物理核心数。</p>
<p>当GOMAXPROCS超过了其分配的配额时，可能导致不必要的上下文切换和调度开销，因为更多的 goroutines 试图在有限的 CPU 时间片上运行。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>uber开源的<a href="https://github.com/uber-go/automaxprocs">https://github.com/uber-go/automaxprocs</a></p>
<p>自动将GOMAXPROCS设置到容器下被限额的cpu数</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>import _ “go.uber.org/automaxprocs”</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>当你的程序是计算密集型或者需要有固定worker数的类型时，并且要部署到容器环境中时，可以参考上面的方法来解决<code>GOMAXPROCS</code> 和cpu限额不匹配的问题</p>
<p>参考</p>
<p><a href="https://nemre.medium.com/is-your-go-application-really-using-the-correct-number-of-cpu-cores-20915d2b6ccb">https://nemre.medium.com/is-your-go-application-really-using-the-correct-number-of-cpu-cores-20915d2b6ccb</a></p>
<p><a href="https://segmentfault.com/a/1190000043930543">https://segmentfault.com/a/1190000043930543</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下.net环境问题</title>
    <url>/dotnet-env/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><ul>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/core/runtime-discovery/troubleshoot-app-launch?pivots=os-macos">https://learn.microsoft.com/zh-cn/dotnet/core/runtime-discovery/troubleshoot-app-launch?pivots=os-macos</a></li>
</ul>
<p>我遇到的问题是mac上装了多个.net环境，在Rider下运行.net程序报错，.NET location: Not found。</p>
<h1 id="net相关路径"><a href="#net相关路径" class="headerlink" title=".net相关路径"></a>.net相关路径</h1><ol>
<li><p>Mac下.net的安装路径在该文件下</p>
<p><code>/etc/dotnet/install_location</code></p>
</li>
<li><p>我的电脑上两个.net的路径在</p>
<ul>
<li>/usr/local/share/dotnet/</li>
<li>~/.dotnet</li>
</ul>
</li>
<li><p>删除一个多余的，只保留一个</p>
</li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Go语言开发eBPF程序</title>
    <url>/goebpf/</url>
    <content><![CDATA[<div class=".article-gallery"><p>原文地址：<a href="https://tonybai.com/2022/07/19/develop-ebpf-program-in-go/">https://tonybai.com/2022/07/19/develop-ebpf-program-in-go/</a></p>
<h1 id="使用Go语言开发eBPF程序"><a href="#使用Go语言开发eBPF程序" class="headerlink" title="使用Go语言开发eBPF程序"></a>使用Go语言开发eBPF程序</h1><ul>
<li>七月 19, 2022</li>
<li><a href="https://tonybai.com/2022/07/19/develop-ebpf-program-in-go/#respond">0 条评论</a></li>
</ul>
<p><a href="https://tonybai.com/wp-content/uploads/develop-ebpf-program-in-go-1.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://tonybai.com/wp-content/uploads/develop-ebpf-program-in-go-1.png" alt="img"></a></p>
<p><a href="https://tonybai.com/2022/07/19/develop-ebpf-program-in-go">本文永久链接</a> – <a href="https://tonybai.com/2022/07/19/develop-ebpf-program-in-go">https://tonybai.com/2022/07/19/develop-ebpf-program-in-go</a></p>
<p>在前面的<a href="https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch">《使用C语言从头开发一个Hello World级别的eBPF程序》</a>一文中，我们详细说明了如何基于C语言和libbpf库从头开发一个eBPF程序(包括其用户态部分)。那篇文章是后续有关eBPF程序开发文章的基础，因为到目前为止，无论eBPF程序的用户态部分用什么语言开发，运行于内核态的eBPF程序内核态部分还是必须由C语言开发的。这样一来，其他编程语言只能拼一下如何让eBPF程序的用户态部分的开发更为简单了，Go语言也不例外。</p>
<p>在Go社区中，目前最为活跃的用于开发eBPF用户态部分的Go eBPF包莫过于cilium项目开源的<a href="https://github.com/cilium/ebpf/">cilium/ebpf</a>，cilium项目背后的<a href="https://isovalent.com/">Isovalent公司</a>也是eBPF技术在云原生领域应用的主要推手之一。</p>
<p>本文我们就来说说<strong>基于cilium/ebpf开发eBPF程序的套路</strong>！</p>
<h3 id="一-探索cilium-ebpf项目示例"><a href="#一-探索cilium-ebpf项目示例" class="headerlink" title="一. 探索cilium/ebpf项目示例"></a>一. 探索cilium/ebpf项目示例</h3><p>cilium/ebpf项目借鉴了<a href="https://github.com/libbpf/libbpf-bootstrap">libbpf-boostrap</a>的思路，通过代码生成与bpf程序内嵌的方式构建eBPF程序用户态部分。为了搞清楚基于cilium/ebpf开发ebpf程序的套路，我们先来探索一下cilium/ebpf项目提供的示例代码。</p>
<p>我们首先来下载和看看ebpf的示例的结构。</p>
<ul>
<li>下载cilium/ebpf项目</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/cilium/ebpf.git</span><br><span class="line">Cloning into &#x27;ebpf&#x27;...</span><br><span class="line">remote: Enumerating objects: 7054, done.</span><br><span class="line">remote: Counting objects: 100% (183/183), done.</span><br><span class="line">remote: Compressing objects: 100% (112/112), done.</span><br><span class="line">remote: Total 7054 (delta 91), reused 124 (delta 69), pack-reused 6871</span><br><span class="line">Receiving objects: 100% (7054/7054), 10.91 MiB | 265.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (4871/4871), done.</span><br></pre></td></tr></table></figure>

<ul>
<li>探索ebpf项目示例代码结构</li>
</ul>
<p>ebpf示例在examples目录下，我们以tracepoint_in_c为例看看其组织形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$tree tracepoint_in_c</span><br><span class="line">tracepoint_in_c</span><br><span class="line">├── bpf_bpfeb.go</span><br><span class="line">├── bpf_bpfeb.o</span><br><span class="line">├── bpf_bpfel.go</span><br><span class="line">├── bpf_bpfel.o</span><br><span class="line">├── main.go</span><br><span class="line">└── tracepoint.c</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>根据经验判断，这里面的tracepoint.c对应的是ebpf程序内核态部分，而main.go和bpf_bpfel.go/bpf_bpfeb.go则是ebpf程序用户态部分，至于bpf_bpfeb.o/bpf_bpfel.o应该是某种中间目标文件。通过readelf -a bpf_bpfeb.o查看该中间文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$readelf -a bpf_bpfeb.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 02 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, big endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Linux BPF</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1968 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 1</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>我们看到这是一个内含linux bpf字节码的elf文件(Machine: Linux BPF)。</p>
<p>阅读了cilium/ebpf的相关文档，我搞明白了这几个文件的关系，用下面示意图呈现给大家：</p>
<p><a href="https://tonybai.com/wp-content/uploads/develop-ebpf-program-in-go-2.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://tonybai.com/wp-content/uploads/develop-ebpf-program-in-go-2.png" alt="img"></a></p>
<p>ebpf程序的源码文件(比如图中tracepoint.c)经过bpf2go(cilium/ebpf提供的一个代码生成工具)被编译(bpf2go调用clang)为ebpf字节码文件bpf_bpfeb.o(大端)和bpf_bpfel.o(小端)，然后bpf2go会基于ebpf字节码文件生成bpf_bpfeb.go或bpf_bpfel.go，ebpf程序的字节码会以二进制数据的形式内嵌到这两个go源文件中，以bpf_bpfel.go为例，我们可以在其代码中找到下面内容(利用<a href="https://tonybai.com/2021/02/25/some-changes-in-go-1-16">go:embed特性</a>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//go:embed bpf_bpfel.o</span><br><span class="line">var _BpfBytes []byte</span><br></pre></td></tr></table></figure>

<p>main.go则是ebpf程序用户态部分的主程序，将main.go与bpf_bpfeb.go或bpf_bpfel.go之一一起编译就形成了ebpf程序。</p>
<p>有了对cilium/ebpf项目示例的初步探索后，我们来构建ebpf示例代码。</p>
<h3 id="二-构建ebpf示例代码"><a href="#二-构建ebpf示例代码" class="headerlink" title="二. 构建ebpf示例代码"></a>二. 构建ebpf示例代码</h3><p>cilium/ebpf提供了便利的构建脚本，我们只需在ebpf/examples下面执行”make -C ..”即可进行示例代码的构建。</p>
<p>make构建过程会基于quay.io/cilium/ebpf-builder镜像启动构建容器，不过在国内的童鞋需要像下面一样对Makefile内容做一丁点修改，增加GOPROXY环境变量，否则wall外的go module无法拉取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git diff ../Makefile</span><br><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index 3a1da88..d7b1712 100644</span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ -48,6 +48,7 @@ container-all:</span><br><span class="line">        $&#123;CONTAINER_ENGINE&#125; run --rm $&#123;CONTAINER_RUN_ARGS&#125; \</span><br><span class="line">                -v &quot;$&#123;REPODIR&#125;&quot;:/ebpf -w /ebpf --env MAKEFLAGS \</span><br><span class="line">                --env CFLAGS=&quot;-fdebug-prefix-map=/ebpf=.&quot; \</span><br><span class="line">+               --env GOPROXY=&quot;https://goproxy.io&quot; \</span><br><span class="line">                --env HOME=&quot;/tmp&quot; \</span><br><span class="line">                &quot;$&#123;IMAGE&#125;:$&#123;VERSION&#125;&quot; \</span><br><span class="line">                $(MAKE) all</span><br></pre></td></tr></table></figure>

<p>这之后再执行构建就会顺利得到我们所要的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd examples</span><br><span class="line">$ make -C ..</span><br><span class="line">make: Entering directory &#x27;/root/go/src/github.com/cilium/ebpf&#x27;</span><br><span class="line">docker run --rm  --user &quot;0:0&quot; \</span><br><span class="line">    -v &quot;/root/go/src/github.com/cilium/ebpf&quot;:/ebpf -w /ebpf --env MAKEFLAGS \</span><br><span class="line">    --env CFLAGS=&quot;-fdebug-prefix-map=/ebpf=.&quot; \</span><br><span class="line">    --env GOPROXY=&quot;https://goproxy.io&quot; \</span><br><span class="line">    --env HOME=&quot;/tmp&quot; \</span><br><span class="line">    &quot;quay.io/cilium/ebpf-builder:1648566014&quot; \</span><br><span class="line">    make all</span><br><span class="line">make: Entering directory &#x27;/ebpf&#x27;</span><br><span class="line">find . -type f -name &quot;*.c&quot; | xargs clang-format -i</span><br><span class="line">go generate ./cmd/bpf2go/test</span><br><span class="line">go: downloading golang.org/x/sys v0.0.0-20210906170528-6f6e22806c34</span><br><span class="line">Compiled /ebpf/cmd/bpf2go/test/test_bpfel.o</span><br><span class="line">Stripped /ebpf/cmd/bpf2go/test/test_bpfel.o</span><br><span class="line">Wrote /ebpf/cmd/bpf2go/test/test_bpfel.go</span><br><span class="line">Compiled /ebpf/cmd/bpf2go/test/test_bpfeb.o</span><br><span class="line">Stripped /ebpf/cmd/bpf2go/test/test_bpfeb.o</span><br><span class="line">Wrote /ebpf/cmd/bpf2go/test/test_bpfeb.go</span><br><span class="line">go generate ./internal/sys</span><br><span class="line">enum AdjRoomMode</span><br><span class="line">enum AttachType</span><br><span class="line">enum Cmd</span><br><span class="line">enum FunctionId</span><br><span class="line">enum HdrStartOff</span><br><span class="line">enum LinkType</span><br><span class="line">enum MapType</span><br><span class="line">enum ProgType</span><br><span class="line">enum RetCode</span><br><span class="line">enum SkAction</span><br><span class="line">enum StackBuildIdStatus</span><br><span class="line">enum StatsType</span><br><span class="line">enum XdpAction</span><br><span class="line">struct BtfInfo</span><br><span class="line">... ...</span><br><span class="line">attr ProgRun</span><br><span class="line">attr RawTracepointOpen</span><br><span class="line">cd examples/ &amp;&amp; go generate ./...</span><br><span class="line">go: downloading github.com/cilium/ebpf v0.8.2-0.20220424153111-6da9518107a8</span><br><span class="line">go: downloading golang.org/x/sys v0.0.0-20211001092434-39dca1131b70</span><br><span class="line">Compiled /ebpf/examples/cgroup_skb/bpf_bpfel.o</span><br><span class="line">Stripped /ebpf/examples/cgroup_skb/bpf_bpfel.o</span><br><span class="line">Wrote /ebpf/examples/cgroup_skb/bpf_bpfel.go</span><br><span class="line">Compiled /ebpf/examples/cgroup_skb/bpf_bpfeb.o</span><br><span class="line">Stripped /ebpf/examples/cgroup_skb/bpf_bpfeb.o</span><br><span class="line">Wrote /ebpf/examples/cgroup_skb/bpf_bpfeb.go</span><br><span class="line">Compiled /ebpf/examples/fentry/bpf_bpfeb.o</span><br><span class="line">Stripped /ebpf/examples/fentry/bpf_bpfeb.o</span><br><span class="line">Wrote /ebpf/examples/fentry/bpf_bpfeb.go</span><br><span class="line">Compiled /ebpf/examples/fentry/bpf_bpfel.o</span><br><span class="line">Stripped /ebpf/examples/fentry/bpf_bpfel.o</span><br><span class="line">Wrote /ebpf/examples/fentry/bpf_bpfel.go</span><br><span class="line">Compiled /ebpf/examples/kprobe/bpf_bpfel.o</span><br><span class="line">Stripped /ebpf/examples/kprobe/bpf_bpfel.o</span><br><span class="line">Wrote /ebpf/examples/kprobe/bpf_bpfel.go</span><br><span class="line">Stripped /ebpf/examples/uretprobe/bpf_bpfel_x86.o</span><br><span class="line">... ...</span><br><span class="line">Wrote /ebpf/examples/uretprobe/bpf_bpfel_x86.go</span><br><span class="line">ln -srf testdata/loader-clang-14-el.elf testdata/loader-el.elf</span><br><span class="line">ln -srf testdata/loader-clang-14-eb.elf testdata/loader-eb.elf</span><br><span class="line">make: Leaving directory &#x27;/ebpf&#x27;</span><br><span class="line">make: Leaving directory &#x27;/root/go/src/github.com/cilium/ebpf&#x27;</span><br></pre></td></tr></table></figure>

<p>以uretprobe下面的ebpf为例，我们运行一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$go run -exec sudo uretprobe/*.go</span><br><span class="line">2022/06/05 18:23:23 Listening for events..</span><br></pre></td></tr></table></figure>

<p>打开一个新的terminal，然后在用户home目录下执行vi .bashrc。在上面的uretprobe程序的执行窗口我们能看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022/06/05 18:24:34 Listening for events..</span><br><span class="line">2022/06/05 18:24:42 /bin/bash:readline return value: vi .bashrc</span><br></pre></td></tr></table></figure>

<p>这就表明uretprobe下面的ebpf程序如预期地执行了。</p>
<h3 id="三-使用cilium-ebpf为前文的Hello-World-eBPF程序开发用户态部分"><a href="#三-使用cilium-ebpf为前文的Hello-World-eBPF程序开发用户态部分" class="headerlink" title="三. 使用cilium/ebpf为前文的Hello World eBPF程序开发用户态部分"></a>三. 使用cilium/ebpf为前文的Hello World eBPF程序开发用户态部分</h3><p>有了对cilium/ebpf示例程序的初步了解，下面我们就来为前面的<a href="https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch">《使用C语言从头开发一个Hello World级别的eBPF程序》</a>一文中的那个helloworld ebpf程序开发用户态部分。</p>
<p>回顾一下那个hello world ebpf程序的C源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld-go/helloworld.bpf.c</span><br><span class="line">#include &lt;linux/bpf.h&gt;</span><br><span class="line">#include &lt;bpf/bpf_helpers.h&gt;</span><br><span class="line"></span><br><span class="line">SEC(&quot;tracepoint/syscalls/sys_enter_execve&quot;)</span><br><span class="line"></span><br><span class="line">int bpf_prog(void *ctx) &#123;</span><br><span class="line">  char msg[] = &quot;Hello, World!&quot;;</span><br><span class="line">  bpf_printk(&quot;invoke bpf_prog: %s\n&quot;, msg);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;;</span><br></pre></td></tr></table></figure>

<p>当这个ebpf程序被加载到内核中后，每当execve这个系统调用被执行，该ebpf程序都会被调用一次，我们就会在/sys/kernel/debug/tracing/trace_pipe中看到对应的日志输出。</p>
<h4 id="1-使用bpf2go将ebpf核心态程序转换为Go代码"><a href="#1-使用bpf2go将ebpf核心态程序转换为Go代码" class="headerlink" title="1. 使用bpf2go将ebpf核心态程序转换为Go代码"></a>1. 使用bpf2go将ebpf核心态程序转换为Go代码</h4><p>根据我们在前面探索cilium/ebpf示例程序时所得到的“套路”，我们接下来第一个要做的就是将helloworld.bpf.c转换为Go代码文件，这一转换过程不可缺少的工具就是cilium/ebpf提供的bpf2go工具，我们先来安装一下该工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$go install github.com/cilium/ebpf/cmd/bpf2go@latest</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以直接使用bpf2go工具将helloworld.ebpf.c转换为对应的go源文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$GOPACKAGE=main bpf2go -cc clang-10 -cflags &#x27;-O2 -g -Wall -Werror&#x27; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /home/tonybai/test/ebpf/libbpf/include/uapi -I /usr/local/bpf/include -idirafter /usr/local/include -idirafter /usr/lib/llvm-10/lib/clang/10.0.0/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include</span><br><span class="line"></span><br><span class="line">Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o</span><br><span class="line">Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o</span><br><span class="line">Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go</span><br><span class="line">Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o</span><br><span class="line">Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o</span><br><span class="line">Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go</span><br></pre></td></tr></table></figure>

<p>不过这里有一个问题，那就是bpf2go命令行后面的一系列提供给clang编译器的头文件引用路径参考了<a href="https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch">《使用C语言从头开发一个Hello World级别的eBPF程序》</a>一文中的Makefile。如果按照这些头文件路径来引用，虽然bpf2go转换可以成功，但是我们需要依赖并安装libbpf这个库，这显然不是我们想要的。</p>
<p>cilium/ebpf在examples中提供了一个headers目录，这个目录中包含了开发ebpf程序用户态部分所需的所有头文件，我们使用它作为我们的头文件引用路径。不过要想基于这个headers目录构建ebpf，我们需要将helloworld.bpf.c中的原头文件include语句由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/bpf.h&gt;</span><br><span class="line">#include &lt;bpf/bpf_helpers.h&gt;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;common.h&quot;</span><br></pre></td></tr></table></figure>

<p>接下来我们再来执行bpf2go工具进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$GOPACKAGE=main bpf2go -cc clang-10 -cflags &#x27;-O2 -g -Wall -Werror&#x27; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /home/tonybai/go/src/github.com/cilium/ebpf/examples/headers</span><br><span class="line"></span><br><span class="line">Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o</span><br><span class="line">Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o</span><br><span class="line">Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go</span><br><span class="line">Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o</span><br><span class="line">Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o</span><br><span class="line">Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go</span><br></pre></td></tr></table></figure>

<p>我们看到bpf2go顺利生成ebpf字节码与对应的Go源文件。</p>
<h4 id="2-构建helloworld-ebpf程序用户态部分"><a href="#2-构建helloworld-ebpf程序用户态部分" class="headerlink" title="2. 构建helloworld ebpf程序用户态部分"></a>2. 构建helloworld ebpf程序用户态部分</h4><p>下面是参考cilium/ebpf示例而构建的helloword ebpf程序用户态部分的main.go源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;os/signal&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line"></span><br><span class="line">    &quot;github.com/cilium/ebpf/link&quot;</span><br><span class="line">    &quot;github.com/cilium/ebpf/rlimit&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    stopper := make(chan os.Signal, 1)</span><br><span class="line">    signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">    // Allow the current process to lock memory for eBPF resources.</span><br><span class="line">    if err := rlimit.RemoveMemlock(); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Load pre-compiled programs and maps into the kernel.</span><br><span class="line">    objs := bpfObjects&#123;&#125;</span><br><span class="line">    if err := loadBpfObjects(&amp;objs, nil); err != nil &#123;</span><br><span class="line">        log.Fatalf(&quot;loading objects: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer objs.Close()</span><br><span class="line"></span><br><span class="line">    //SEC(&quot;tracepoint/syscalls/sys_enter_execve&quot;)</span><br><span class="line">    // attach to xxx</span><br><span class="line">    kp, err := link.Tracepoint(&quot;syscalls&quot;, &quot;sys_enter_execve&quot;, objs.BpfProg, nil)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatalf(&quot;opening tracepoint: %s&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer kp.Close()</span><br><span class="line"></span><br><span class="line">    log.Printf(&quot;Successfully started! Please run \&quot;sudo cat /sys/kernel/debug/tracing/trace_pipe\&quot; to see output of the BPF programs\n&quot;)</span><br><span class="line"></span><br><span class="line">    // Wait for a signal and close the perf reader,</span><br><span class="line">    // which will interrupt rd.Read() and make the program exit.</span><br><span class="line">    &lt;-stopper</span><br><span class="line">    log.Println(&quot;Received signal, exiting program..&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道一个ebpf程序有几个关键组成：</p>
<ul>
<li>ebpf程序数据</li>
<li>map：用于用户态与内核态的数据交互</li>
<li>挂接点(attach point)</li>
</ul>
<p>根据<a href="https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md">cilium/ebpf架构</a>的说明，ebpf包将前两部分抽象为了一个数据结构bpfObjects：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go</span><br><span class="line"></span><br><span class="line">// bpfObjects contains all objects after they have been loaded into the kernel.</span><br><span class="line">//</span><br><span class="line">// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.</span><br><span class="line">type bpfObjects struct &#123;</span><br><span class="line">    bpfPrograms</span><br><span class="line">    bpfMaps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，main函数通过生成的loadBpfObjects函数将ebpf程序加载到内核，并填充bpfObjects结构，一旦加载bpf程序成功，后续我们便可以使用bpfObjects结构中的字段来完成其余操作，比如通过link包的函数将bpf程序与目标挂节点对接在一起(如文中的link.Tracepoint函数），这样挂接后，bpf才能在对应的事件发生后被回调执行。</p>
<p>下面编译执行一下该helloworld示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$go run -exec sudo main.go bpf_bpfel.go</span><br><span class="line">[sudo] password for tonybai:</span><br><span class="line">2022/06/05 14:12:40 Successfully started! Please run &quot;sudo cat /sys/kernel/debug/tracing/trace_pipe&quot; to see output of the BPF programs</span><br></pre></td></tr></table></figure>

<p>之后新打开一个窗口，执行sudo cat /sys/kernel/debug/tracing/trace_pipe，当execve被调用时，我们就能看到类似下面的日志输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;...&gt;-551077  [000] .... 6062226.208943: 0: invoke bpf_prog: Hello, World!</span><br><span class="line">&lt;...&gt;-551077  [000] .... 6062226.209098: 0: invoke bpf_prog: Hello, World!</span><br><span class="line">&lt;...&gt;-551079  [007] .... 6062226.215421: 0: invoke bpf_prog: Hello, World!</span><br><span class="line">&lt;...&gt;-551079  [007] .... 6062226.215578: 0: invoke bpf_prog: Hello, World!</span><br><span class="line">&lt;...&gt;-554756  [007] .... 6063476.785212: 0: invoke bpf_prog: Hello, World!</span><br><span class="line">&lt;...&gt;-554756  [007] .... 6063476.785378: 0: invoke bpf_prog: Hello, World!</span><br></pre></td></tr></table></figure>

<h4 id="3-使用go-generate来驱动bpf2go的转换"><a href="#3-使用go-generate来驱动bpf2go的转换" class="headerlink" title="3. 使用go generate来驱动bpf2go的转换"></a>3. 使用go generate来驱动bpf2go的转换</h4><p>在生成代码方面，Go工具链原生提供了go generate工具，cilium/ebpf的examples中也是利用go generate来驱动bpf2go将bpf程序转换为Go源文件的，这里我们也来做一下改造。</p>
<p>首先我们在main.go的main函数上面增加一行go:generate指示语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/main.go</span><br><span class="line"></span><br><span class="line">// $BPF_CLANG, $BPF_CFLAGS and $BPF_HEADERS are set by the Makefile.</span><br><span class="line">//go:generate bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS -target bpfel,bpfeb bpf helloworld.bpf.c -- -I $BPF_HEADERS</span><br><span class="line">func main() &#123;</span><br><span class="line">    stopper := make(chan os.Signal,  1)</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当我们显式执行go generate语句时，go generate会扫描到该指示语句，并执行后面的命令。这里使用了几个变量，变量是定义在Makefile中的。当然如果你不想使用Makefile，也可以将变量替换为相应的值。这里我们使用Makefile，下面是Makefile的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/Makefile</span><br><span class="line"></span><br><span class="line">CLANG ?= clang-10</span><br><span class="line">CFLAGS ?= -O2 -g -Wall -Werror</span><br><span class="line"></span><br><span class="line">LIBEBPF_TOP = /home/tonybai/go/src/github.com/cilium/ebpf</span><br><span class="line">EXAMPLES_HEADERS = $(LIBEBPF_TOP)/examples/headers</span><br><span class="line"></span><br><span class="line">all: generate</span><br><span class="line"></span><br><span class="line">generate: export BPF_CLANG=$(CLANG)</span><br><span class="line">generate: export BPF_CFLAGS=$(CFLAGS)</span><br><span class="line">generate: export BPF_HEADERS=$(EXAMPLES_HEADERS)</span><br><span class="line">generate:</span><br><span class="line">    go generate ./...</span><br></pre></td></tr></table></figure>

<p>有了该Makefile后，我们执行make命令便可以执行bpf2go对bpf程序的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$make</span><br><span class="line">go generate ./...</span><br><span class="line">Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o</span><br><span class="line">Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o</span><br><span class="line">Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go</span><br><span class="line">Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o</span><br><span class="line">Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o</span><br><span class="line">Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go</span><br></pre></td></tr></table></figure>

<h3 id="四-小结"><a href="#四-小结" class="headerlink" title="四. 小结"></a>四. 小结</h3><p>本文我们讲解了如何基于cilium/ebpf包来开发ebpf的用户态部分。</p>
<p>ebpf借鉴了libbpf的思路，通过生成代码与数据内嵌的方式来构建ebpf的用户态部分。</p>
<p>ebpf提供了bpf2go工具，可以将bpf的C源码转换为相应的go源码。</p>
<p>ebpf将bpf程序抽象为bpfObjects，通过生成的loadBpfObjects完成bpf程序加载到内核的过程，然后利用ebpf库提供的诸如link之类的包实现ebpf与内核事件的关联。</p>
<p>ebpf包的玩法还有很多，这一篇仅仅是为了打好基础，在后续文章中，我们还会针对各种类型的bpf程序做进一步学习和说明。</p>
<p>本文代码可以在<a href="https://github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld-go">这里</a>下载。</p>
<h3 id="无-参考资料"><a href="#无-参考资料" class="headerlink" title="无. 参考资料"></a>无. 参考资料</h3><ul>
<li><a href="https://www.ebpf.top/post/ebpf_go/">使用Go语言管理和分发ebpf程序</a> – <a href="https://www.ebpf.top/post/ebpf_go/">https://www.ebpf.top/post/ebpf_go/</a></li>
<li><a href="https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf">A Pure Go eBPF library</a> – <a href="https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf">https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf</a></li>
<li><a href="https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md">cilium ebpf library architecture</a> – <a href="https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md">https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md</a></li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd go客户端无法正常连接</title>
    <url>/etcd_go_proxy/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>golang项目在Windows下开发没问题，换到Linux下发现etcd无法连接。</p>
<h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><ol>
<li>排查网络。Linux机器和etcd服务之前网络是通的</li>
<li>排查etcd用户名，密码。使用etcdctl发现是能正常获取值的</li>
<li>降级etcd clientV3版本，降到之前确认没问题的版本，发现还是不行</li>
<li>基本确认是这台Linux机器有一些什么特别的设置</li>
<li>在本地安装Linux服务，发现无论是否开启密码验证，都能连接本地etcd服务</li>
<li>确认是网络的问题</li>
<li>检查发现开启了HTTP_PROXY和HTTPS_PROXY，关闭后可以正确连接远程etcd服务<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1>问了下gpt goClient和etcdctl之前的区别，回答如下：</li>
</ol>
<p>你遇到的现象是：</p>
<p>系统设置了 HTTP_PROXY（或 http_proxy）环境变量。<br>用 Go 的 etcd client（如 go.etcd.io/etcd/client/v3）连接 etcd 失败。<br>但用 etcdctl 命令行工具却能正常连接。<br>这实际上是一个在企业/云环境下很常见的情况，下面详细解释原因和解决办法。</p>
<p>原因分析<br>Go 的 etcd client 默认遵循 HTTP(S)_PROXY 环境变量。<br>Go 1.4+ 的 http(s) 库会自动读取 HTTP_PROXY、HTTPS_PROXY、NO_PROXY 等变量，把所有 HTTP、HTTPS 请求通过代理转发。<br>虽然 etcd client 默认是 gRPC，但底层用的 net/http/transport，依然会读取代理环境变量。<br>etcdctl 默认不走代理。<br>etcdctl 用自己的 dial 方式，不理会 HTTP_PROXY。<br>etcd 节点通常在内网，走代理会失败。<br>解决方法<br>方案1：设置 NO_PROXY<br>让 Go client 直连内网 etcd，不走代理，需要设置 NO_PROXY 变量，指定 etcd 的 IP/域名/端口：</p>
<p>假设 etcd 地址为 10.37.55.13:2369</p>
<p>bash<br>export NO_PROXY=10.37.55.13,127.0.0.1,localhost<br>或者（如果端口也要区分，可以写成如下，但一般只填主机）：</p>
<p>bash<br>export NO_PROXY=10.37.55.13,10.37.55.13:2369,127.0.0.1,localhost<br>你可以把这句加到你的服务启动脚本前面，或者在 shell 里全局设置。</p>
<p>方案2：Go 代码里禁用代理<br>如果你不能或不想改环境变量，可以在代码里禁用代理。例如：</p>
<p>Go<br>import (<br>    “net/http”<br>    “go.etcd.io/etcd/client/v3”<br>)</p>
<p>tr := http.DefaultTransport.(*http.Transport).Clone()<br>tr.Proxy = nil // 禁用代理</p>
<p>cli, err := clientv3.New(clientv3.Config{<br>    Endpoints:   []string{“<a href="http://10.37.55.13:2369&quot;}">http://10.37.55.13:2369&quot;}</a>,<br>    DialTimeout: 5 * time.Second,<br>    DialOptions: []grpc.DialOption{<br>        grpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {<br>            d := net.Dialer{}<br>            return d.DialContext(ctx, “tcp”, addr)<br>        }),<br>    },<br>})<br>不过直接设置 NO_PROXY 更简单。</p>
<p>总结<br>etcdctl 不受 HTTP_PROXY 影响；Go etcd client 会被 HTTP_PROXY 影响。<br>解决方案：设置 NO_PROXY 包含你 etcd 的 IP/域名。<br>推荐方法：在你的 shell 或服务启动脚本里加上 export NO_PROXY=…。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Flutter进行APP开发流程</title>
    <url>/flutter-dev/</url>
    <content><![CDATA[<div class=".article-gallery"><p><a href="https://imgtu.com/i/hBsVC6"><a href="https://z3.ax1x.com/2021/09/01/hBsVC6.md.png" title="hBsVC6.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/09/01/hBsVC6.md.png" alt="hBsVC6.md.png"></a></a></p>
<h1 id="资源加载："><a href="#资源加载：" class="headerlink" title="资源加载："></a>资源加载：</h1><h3 id="1-本地"><a href="#1-本地" class="headerlink" title="1.本地"></a>1.本地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const String DEFAULT_USER_ICON = &#x27;static/images/logo.png&#x27;;</span><br><span class="line">Image.asset(AppICons.DEFAULT_USER_ICON, width: AppICons.USER_ICON_WIDTH, height: AppICons.USER_ICON_HEIGHT),</span><br></pre></td></tr></table></figure>

<h3 id="2-iconfont。-https-www-iconfont-cn"><a href="#2-iconfont。-https-www-iconfont-cn" class="headerlink" title="2.iconfont。 https://www.iconfont.cn/"></a>2.iconfont。 <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></h3><p>在iconfont网站上传资源。下载到本地，放入项目资源文件夹下。</p>
<p>pubspec.yaml中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fonts:</span><br><span class="line">  - family: myIconFont</span><br><span class="line">    fonts:</span><br><span class="line">      - asset: static/font/iconfont.ttf</span><br></pre></td></tr></table></figure>

<h3 id="3-UI编辑器。-https-norbert515-github-io-widget-maker-website"><a href="#3-UI编辑器。-https-norbert515-github-io-widget-maker-website" class="headerlink" title="3.UI编辑器。 https://norbert515.github.io/widget_maker/website/"></a>3.UI编辑器。 <a href="https://norbert515.github.io/widget_maker/website/">https://norbert515.github.io/widget_maker/website/</a></h3><p><a href="https://github.com/Norbert515/flutter_ide">https://github.com/Norbert515/flutter_ide</a></p>
<p>项目中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const String FONT_FAMILY = &#x27;myIconFont&#x27;;</span><br><span class="line">static const IconData LOGIN_USER = const IconData(0xe652, fontFamily: AppICons.FONT_FAMILY);</span><br><span class="line">iconData: AppICons.LOGIN_USER,</span><br></pre></td></tr></table></figure>

<h1 id="原型开发："><a href="#原型开发：" class="headerlink" title="原型开发："></a>原型开发：</h1><p><a href="https://www.xiaopiu.com/">https://www.xiaopiu.com/</a></p>
<p>在上面设计开发，然后导出到本地，可以查看里面的资源文件。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器云基础设施介绍</title>
    <url>/game-server-cloud/</url>
    <content><![CDATA[<div class=".article-gallery"><p>服务器云基础设施介绍</p>
<ul>
<li><h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1></li>
</ul>
<p>大家好，我叫张泽强，很荣幸能来到这里和大家一起分享有关游戏服务器的一些生产环境下的应用和案例，希望大家对线上环境的技术方案和选型有一个初步的了解，这样平时在学校做一些课设或项目的时候，对于技术方案多一些选择，或者说可以更接近真实环境。</p>
<p>先做个简单的自我介绍吧。</p>
<span id="more"></span>

<p>从毕业到现在一直在做游戏后端的开发，做过多种不同类型的游戏，像休闲/卡牌/MMO/开放大世界，早期做过页游，后来主要都是做手游。做过千万级用户的游戏，也做个没上线就拉垮的项目。维护过不同环境的线上项目，从最早的物理机上的项目到云服务，以及近两年比较火的容器化服务。这些也是今天分享的主题。</p>
<p>我是去年夏天加入字节跳动的，在字节做游戏和之前最大的区别就是，身边都是一些优秀的同事，研发的氛围非常好，管理也更扁平化。现在在技术中心呢，在做的也是一些更有挑战的事情，得益于抖音和头条的流量吧，现在做的所有项目都是直接面向用户的，和用户的距离更近了。</p>
<p>那从毕业到现在总结收获呢，首先是拥有了强者的发型，那今天和大家来一起探讨如何拥有强者的发型吗？那显然不是啊，要不吓跑一堆同学了，今天主要是和大家一起分享下如何变得更强，借着这次分享希望能结识更多的同学，也期待大家以后能来到字节一起做更有趣的游戏。</p>
<p>在正式开始前，先聊一些游戏服务器研发方面的问题吧，这也是平时在校招的时候很多同学经常会问的，比如，你们做游戏服务器用什么语言啊？以我接触和了解到的游戏厂商来看，不负责任的说，毕竟是一个感官上的感受，没有具体的数据统计。大致情况是这样的，北京，大部分游戏厂商，80%以上都是java，最近开始有一些golang的游戏服务器了，主要是休闲类或slg类，剩下的主要就是c++。南方来说，主要是上海杭州深圳广州，以腾讯网易为代表的主要是c++。总的来说主要还是以java和c++为主。另外一个问题，游戏服务器使用到的技术栈都有哪些？这个可以说每个项目使用到的技术栈既不同也相同，不同主要体现在，游戏的品类太多了，不同的游戏类型适合的框架不太一样，比如休闲游戏弱交互和MMO交互性强的，一般使用的框架不一样，再比如FPS等一些竞技类的游戏又不一样，再加上每个公司或者工作室因为一些历史原因，框架也不一样。但是从另外一个层面说，这些不同的框架基本上都是对底层组件的封装，而由于游戏服务器是网络应用，那底层组件主要集中在网络和存储以及线程调度上，关于这些呢其实大学课程上都有涉及，那其实大家只要把基础理论知识学好，不管哪个项目使用什么框架都能很快上手。那具体到网络组件上，大家如果想去学习的话，可以看下java的netty库，数据库的话mysql/mongodb/redis了，特别是redis推荐大家去学习下。</p>
<h1 id="分享概述"><a href="#分享概述" class="headerlink" title="分享概述"></a>分享概述</h1><p>那正式开始今天的分享之前呢，先大概介绍下分享的整体内容，希望通过这次分享，让大家尽可能多的了解到真实的线上环境中服务器的方案和原理，包括但不限于，计算/存储和网络等方面，主要分享的侧重点是介绍他们的原理和特性，以及实际的应用，不会过多的涉及到具体使用方面，因为如何使用这个东西即使你现在看了，可能吃了晚饭后就忘了，而且使用的话相信以后大家遇到具体案例要去实操的时候去相应的官网一看就能上手。今天主要是和大家一起了解下他们背后的原理和特性以及一些真实的案例，这样在你们以后学校的一些项目中可以多一些技术选型的参考，更接近于线上环境。</p>
<p>我们首先会介绍下云服务的概述，看下我们在游戏研发中碰到了哪些问题，云服务是否适合我们，帮助我们解决了这些问题。</p>
<p>接下来会详细的介绍一些云基础服务，以及他们在游戏服务器中的应用。</p>
<p>最后我们通过上面了解到的技术方案，去思考总结一下具体某个类型游戏服务器案例的使用。</p>
<ul>
<li><h1 id="云服务器概述"><a href="#云服务器概述" class="headerlink" title="云服务器概述"></a>云服务器概述</h1></li>
</ul>
<p>设想一下，如果我们现在有一款产品或游戏要发布，那我们需要考虑哪些方面呢？</p>
<p>首先我们在自己的开发机上开发完成，并且测试通过。接下来我们要对用户提供服务，我们可以选择将服务运行在我们的开发机上，这也是一种方案，我们都知道这种方案太草率，具体草率在哪些方面呢？稳定性不够，我们的电脑可能用来玩游戏，玩游戏有的时候还会死机，宿舍还可能会停电。安全性不够，我们电脑还运行了一些和应用本身无关的其他程序。扩展性也不够，如果我们游戏的用户多了，cpu，内存不够了，我们升级电脑硬件，如果我们游戏用户又流失了，资源又溢出了，我们不能一直换电脑吧。另一种方案，我们把服务部署在专用的服务器机房内，稳定性和安全性比我们开发机上好很多了，但是扩展性还是不够，主要受限于硬件，已经国际化部署问题。还有就是维护性方面，需要我们自己去监控机器的状态，包括内存，cpu，网络等。那么有什么方案能解决我们上面提到的这些问题呢？云服务器，大家肯定都有一些了解。那我们接下来就深入了解下云服务器的特性。</p>
<ul>
<li><strong>云服务是什么？</strong></li>
</ul>
<p>云服务是将数据中心资源虚拟化，通过互联网提供给大家使用。云服务的这句定义非常简单，其中包括两个主要的名词，一个是数据中心，那数据中心又是什么呢？数据中心指的就是计算，存储，网络等。另一个是虚拟化，什么是虚拟化呢？这个接下来我们会详细介绍。图上是国内常用的云服务供应商：腾讯云，阿里云，字节云。可以看到他们提供的产品和服务非常多，接下来我们也会介绍下主要的基础云服务设施，以及他们在游戏中的应用。</p>
<ul>
<li><strong>云计算的历史</strong></li>
</ul>
<p>我们首先来了解下云计算的历史，对他的发展有个基本的概念。云计算发展过程中有这么几个重要的节点。首先是虚拟化理论的提出和发展，虚拟化技术一会我们会根据不同的运用具体展开介绍。然后是虚拟化技术的落地，其中最重要的2001年基于x86的VM的诞生，意味着可以在一台物理机上运行多个虚拟机，启动速度和弹性远超虚拟机。另一个是KVM的出现，随后KVM模块的源码被纳入Linux内核，是现在最常用的服务器虚拟机。在虚拟化技术成熟以后，云计算才真正出现，此时基于虚拟机技术诞生了很多云计算产品，包括IaaS,PaaS,SaaS,FaaS,公有云,私有云等。接下来就是近几年大火的容器技术，容器技术对软件开发行业和微服务的发展有着深远的影响，最后就是k8s在容器编排大战的胜出。</p>
<ul>
<li><strong>云服务的分类</strong></li>
</ul>
<p>一切皆服务，他是将基于云的，以软件为主体进行交付的IT资源。我们来看最底层的数据中心，包括服务器，存储，网络等，在这之上通过虚拟化之后作为虚拟机，然后再装上操作系统，这就是一台最基础的云服务器了，这就叫基础设施即服务IaaS，在这基础之上呢，我们可以再加上数据库，中间件等一些工具，作为开发平台提供服务，这个就叫平台即服务PaaS。再往上呢，我们可以直接开发应用，把应用拿出来给用户提供服务，这个就叫软件即服务SaaS。我们大概知道了这三类云服务，如果把这三类服务举个具体的例子呢，IaaS就好比一个地块，我们可以在这个地块上修建任何建筑，自由度比较高，但是需要我们有很强的动手能力。PaaS呢，就好比在地块上已经给我们修好了一些建筑，我们可以根据自己的使用用途来自己装修了，这个就比较适合有一定动手能力的。最后SaaS呢，就好比图书馆，食堂之类的，可以直接提供服务了，我们只需要使用就可以了。我们再来看下，都有哪些厂商来提供这些云服务呢？首先是基础设施包括国外的亚马逊，Google，微软了，国内的阿里，腾讯，华为。字节呢现在主要还是提供私有云为主，服务公司内部。平台服务呢，大部分提供基础服务的都提供平台服务，像我们刚开始放的云厂商那张图片里一样，字节也提供了很多平台服务。最后是软件服务，这个大家是大家平时日常生活中接触最多的了。</p>
<ul>
<li><strong>什么是****PaaS</strong></li>
</ul>
<p>那什么是PaaS呢？为什么我们单独把这个拿出来说呢，因为iaas和SaaS比较好理解，IaaS就是CPU内存这些服务器资源，SaaS就是软件服务。PaaS是我们日常开发中接触最多的，他是以便利开发者为目标的中间件。我们再回头思考下，我们最开始提出的问题，我们知道了在本地发布我们的游戏服务器稳定性不够，物理机上发布一次性投入成本和维护成本比较高，现在我们想将服务器发布到云上，应该采用哪种方案呢？我们先来看下IaaS，云服务器，我们需要考虑考虑cpu，内存这些，还得安装我们的环境，java开发的需要安装jdk，用到数据库的话，我们还得安装数据库，这些环境配置好了之后才能运行我们的代码。那PaaS呢，PaaS就是给我们提供好了开发平台，我们直接可以写代码运行了，需要的环境都已经安装好了，对开发者来说真的很友好。那SaaS呢，直接面向用户提供服务，比如我这次的PPT主要就是在飞书doc上在线写的。通过他们这些特性呢，我们就能知道他们面向服务的群体了，PaaS面向运维工程师，iaas面向软件开发者，SaaS面向的是用户。</p>
<ul>
<li><strong>云服务的优势</strong></li>
</ul>
<p>那我们到现在对云服务有了一个概括性的了解之后呢，我们来看下他有哪些优势呢？</p>
<p>按需灵活配置：根据我们用户的量级预估资源的配置，申请云服务器。</p>
<p>简化容量管理：如果我们应用的人数比预期高了或低了，我们都能扩缩容我们的机器，现在云厂商都支持在线扩缩容了。</p>
<ul>
<li><h1 id="基础云服务及应用"><a href="#基础云服务及应用" class="headerlink" title="基础云服务及应用"></a>基础云服务及应用</h1></li>
</ul>
<p>现在我们对云服务有了一个大概的了解，接下来我们针对性的介绍一些基础云服务以及他们在游戏中的应用。主要包括计算类的，云主机，容器，函数服务，以及网络类的VPC，负载均衡。存储类的我们今天就不介绍了，明天我们的同事有一个非常高质量的分享，欢迎大家到时候参加。</p>
<ul>
<li><strong>虚拟化技术</strong></li>
</ul>
<p>那在介绍云服务之前呢，我们首先要了解下上面提到过的虚拟化技术，这是云服务的基础。虚拟化技术是指通过资源管理技术，将计算机的实体资源分割成几个独立的环境。</p>
<p>对于一台电脑来说，我们很熟悉了，可以简单的划分为三层，从下到上分别是物理硬件层，操作系统层，应用程序层。对物理资源的虚拟划分有两种著名的方案，左边的是1型：直接凌驾于硬件之上，构建出多个隔离的操作系统环境。右边的是2型：依赖于宿主操作系统，在其上构建出多个隔离的操作系统环境。这两类方案在原理上区别是什么呢？第一种vmm是完全模拟了整个cpu指令集，将虚拟机的操作直接转化成cpu指令集执行，第二种vmm在虚拟机操作系统和计算机之前扮演了一个桥梁的作用，将虚拟机要执行的操作翻译成cpu指令在计算机上执行，这两个的区别有点像解释性语言和编译性语言的区别。像我们在电脑上经常安装的虚拟机是第二类的，他是依赖于宿主操作系统的。</p>
<p>接下来我们来看下现在云服务上主要使用的KVM，他是开源的，并且已经集成进Linux内核了，可以认为linux内核本身就是一个vmm。从图中我们可以看到KVM本身基于硬件辅助虚拟化只负责虚拟化cpu和内存，但是一台计算机不只有cpu和内存，还有各种io设备，QEMU负责这些设备的虚拟化。</p>
<ul>
<li><strong>云服务器</strong></li>
</ul>
<p>我们知道了一台物理机如果通过虚拟化技术形成多台环境隔离的虚拟机之后，我们现在将之前的游戏服务器发布到云服务器上，就清楚了更多的细节。云服务有哪些优势呢？云服务有哪些规格适合我们的服务器呢？AI训练，现在很多竞技游戏，包括棋牌类的AI都是机器学习了，这样的机器人操作更符合正常玩家的思维，提高了游戏玩家的体验。当然如果在字节发布云服务器的话，也可以发布在我们每个人的devbox上，每个程序都会有的一台云服务器，方便我们有的时候调试。</p>
<ul>
<li><strong>应用</strong></li>
</ul>
<p>以一个MMO游戏为例吧。我们在开新服的时候，只需要新增云服务器就可以了，如果一些服务器的玩家活跃人数少了之后，我们在需要进行合服的时候，只需要下掉几台云服务器就好了。数据库呢，我们可以选择直接用paas服务提供的即可，我们不需要去部署安装数据了，我们直接使用即可。现在我们将应用部署到云服务器上就稳定和方便了很多。</p>
<ul>
<li><strong>容器</strong></li>
</ul>
<p>在了解了使用云服务器来部署我们的应用后，已经基本能满足之前我们碰到的问题了。那在实际的开发环境中，我们经常又会碰到新的问题，比如服务在我们的开发机上可以运行，但是发布到服务器上却不能运行了，这是为什么呢？因为我们本地开发的环境和线上环境是不同的，依赖的工具包和配置也是不同的，比如我们本地的开发机上使用的jdk可能是11，线上安装的jdk是1.8，我们在开发中使用了11的一些新特性比如var变量，在本地可以正常运行，但是线上1.8的就会报错。还有另一种情况，本来我们的服务运行的非常稳定，但是在版本升级了之后却出现问题了，比如我们将mysql从5.7升级到了8.0，使用了8.0的一些特性，比如用rename直接修改列名，这样在5.7上就会失败。这些例子最主要的问题还是环境的差异，那为什么会有这些环境的差异呢？这是因为我们的发布流程是我们将我们编写的代码编译成最终运行的产物，比如exe或jar包war包，我们将最终产物上传到服务器上，运行环境和依赖使用的是我们云服务上的配置，我们在新加云服务器或升级配置的时候可能造成环境不一致的情况。那针对这种情况呢，容器技术的出现提供了另一种思路，我们可以将最终产物和我们的环境依赖一起打包，然后部署上线，这样一套流程走完，所有的环境和依赖都是一致的，这是容器化技术出现最大的特性。</p>
<p>但是这个流程最终如何实现的呢？我们可以借鉴下前端的流程，前端是在u3d或者ue上开发，然后打包成游戏包，安卓的话是apk，ios的话是ipa，然后将游戏包发布到应用商店，appstore或googlestore上，用户直接下载安装后就可以使用了。那我们后端是不是也可以呢，将jar/exe这些最终产物带上环境一起打包发布到远程应用商店里面，服务器只需要下载安装运行就可以了。这就是容器提供的标准交付解决方案。</p>
<p>容器另外一个最大的特性是通过打包装箱的思想进行应用程序级别的隔离，可以在一台云服务器上运行多个环境相互隔离的应用，已达到对资源的极致利用。</p>
<p>容器的工作原理，容器的虚拟化不是模拟了整个操作系统，他只是隔离了应用的环境，使用的还是宿主机的操作系统，非常轻量级。</p>
<ul>
<li><strong>容器编排</strong></li>
</ul>
<p>通过我们之前对容器的介绍，知道容器自身的价值主要是提供了标准化的交付，打包和分发的作用，和轻量级的应用环境隔离，但是如果不形成规模化的效应，是无法发挥出对资源利用的优势的，那形成规模化效应最大的问题就是容器的调度和编排上应该如何进行，所谓编排就是不同应用的容器间的关系的组织。那在这些编排工具中使用最广泛的就是我们要介绍的k8s，k8s是什么，他本身是一个跨主机的容器编排工具，他使用网络将多个主机构建成统一的集群，主节点作为控制中心，负责管理整个集群系统，其他节点为工作节点，工作节点以pod的形式运行服务，这种服务一般都是计算服务。总结来说k8s编排工具主要提供了容器间部署，更新，伸缩的管理服务，以及容器周边的编排比如网络存储等。k8s最主要的特性就是声明式api，我们只需要告诉他我们预期的结果是什么样就可以，剩余的事情全部交给k8s来完成。k8s的控制器模式来负责实现用户期望的状态，因此我们用k8s举例来说，大概就是我们告诉k8s，我们希望运行两个pod，pod如何去下载镜像，下载完后这个pod具体运行在集群中的哪个节点上，万一pod所在的节点宕机了，如何再重新启动起来等等这些，统统交给k8s来解决。我们使用声明式api的形式就是通过json文件或yaml文件来组织声明式api即可，和dockerfile一样简单。</p>
<p>到这里可能大家会有个疑问，我们之前介绍了容器，现在在说容器编排，但是他本身调度的不是容器而是pod，那pod又是什么呢？pod是k8s上运行应用的最小单位，pod是一到多个容器的集合，这些容器共享network，IPC，uts，这些主要是和网络通信和主机名相关的名称空间，还可以共享数据卷，我们之前介绍过容器间的文件是相互隔离的，那pod间的多个容器是如何实现共享的呢，每个pod上都会启动一个基础容器，叫pod infrastructure，他主要负责创建这些共享的名称空间，以及绑定数据卷，这样在这个pod上运行的其他容器就可以共享这些了。mount和user是隔离的，我们可以理解成pod是一组紧密相关的容器组成的，但事实上可能我们一个pod就只跑一个容器。一般我们不建议一个pod上跑多个容器，除非是必须的，比如sidecar模式，我们使用ipc进程间通信，提高性能，比如我们每个pod上可以跑一些日志采集的服务，或者性能分析的服务，那这些如果部署成不同的pod的话，就需要通过network进行通信呢，我们这时候可以选择以sidecar的模式将他们部署成一个pod。</p>
<p>有了这些基础了解之后，接下来我们来看下k8s的基础架构。我们刚才提到过一个k8s的系统主要由两类结构组成，一个是控制节点，另一个叫计算节点，主要是来运行我们的程序的。一般来说控制节点1个就能实现功能了，但是这样控制节点就成为了单点问题，实际中我们一般也会部署三个控制节点，因为他其中使用的etcd使用raft协议，进行选举时最好不少于三个节点。那计算节点按照我们的需求来部署相应的数量即可。控制节点呢主要由这几个组成，apiserver整个k8s程序的入口，所有数据的出入都通过apiserver完成。controler manager就是刚才提到的控制器模式，都放在这里。scheduler是负责调度用户或控制器创建的新的节点，究竟这个pod该运行在哪个节点上呢，就是有scheduler决定的。etcd是用来用来存储服务的状态，他是通过raft协议来构建的支持kv存储的一致性数据库。再看计算节点，每个计算节点上都会运行这样三个组件，一个是kubelet，是apiserver的客户端，负责和apiserver通信，接收apiserver的scheduler分发的由自己负责执行的任务。创建完pod后需要和其他pod进行通信，kube-proxy进行的，他还负责低层级的服务发现和负载均衡。最后就是我们真正运行的容器了。k8s可以运行在物理机，虚拟机，公有云私有云上面。</p>
<ul>
<li><strong>VM vs Docker</strong></li>
</ul>
<p>介绍了vm和docker后我们来看下这两个主要的区别的。</p>
<p>容器和虚拟机走的是完全不同的路线，虚拟机的目标是虚拟化出一台完整的计算机，拥有底层的物理硬件，操作系统，应用程序执行所需的环境。为了让虚拟机达到能模拟真实物理机上运行的环境，vmm做了很多繁重的事情，但其实对于应用程序来说这套环境可以说是有用但是又不完全有用，应用程序只需要独立的应用执行环境就可以了。这样做有什么好处呢？虚拟出一台计算机的代价是比较大的，可能一台物理机上虚拟出10台虚拟机就非常吃力了，但是虚拟出上百个独立的执行环境却非常轻松，另外一台虚拟机的启动远远比容器的启动要慢很多。另外容器的程序代码指令不需要翻译，就可以直接在cpu上运行，因为大家其实公用的是同一个操作系统，只是进行了软件层面上的逻辑隔离，性能更好。缺点呢就是隔离性比虚拟机要差，一旦利用内核漏洞发起攻击，程序突破容器限制，实现逃逸，危机宿主计算机，就会影响到整台物理机上的所有容器。</p>
<ul>
<li><strong>应用</strong></li>
</ul>
<p>我们都知道传统游戏不像app一样有那么高的日活，纵观游戏的生命周期我们发现大部分游戏都会有他的一个峰值时间点，而且大部分游戏的生命周期可能也不是很长，而且在一些节日活动的时候伴随着游戏中的活动，在线人数会迅速攀高，即使按天的时间来观察，也会发现游戏会有一个明显的高峰和低谷，以今年抖音和春晚的合作为例，芒果斗地主在抖音主会场的露出带来了大量的用户，而且由于春晚红包雨的这种瞬时高流量的玩法，给游戏部署带来了更多的挑战，如果是传统的云服务器的话，那我们可能事先就需要准备大量的服务器了，而且等春晚活动过后玩家一定会逐渐回归到一个正常的水平，那这些空闲的服务器归还也是一个问题。那得益于字节云提供的容器化服务，我们可以做到快速的响应，达到迅速自动扩缩容的要求，进一步控制成本。在几个热点服务上，比如牌局服务，这个是频繁创建和销毁的，为了应对春晚的流量，单个服务的容器就达到了几百个，这个如果是部署在传统的云服务器上，成本会比容器高很多。</p>
<ul>
<li><strong>函数服务</strong></li>
</ul>
<p>接下来我们介绍下函数服务，这个可能大家平时了解的比较少，函数服务也叫无服务器架构，他不同于我们上面介绍的云服务提供完整的应用功能，只是提供应用中某个功能的服务。这里的无服务器指的不是没有云服务器，而是无需我们关心云服务器。那具体他是怎么实现的呢？回忆下我们之前介绍的IaaS,PaaS平台，我们发布应用的时候需要将我们的可执行程序发布到服务器上，然后启动运行，我们拥有的是对后台服务器的权限，这也意味着我们需要去关心服务器的状态，包括我们之前提到的运行环境，负载均衡和容量等等，那如果我们的某些服务是一些非常轻量级的呢？可能这个服务的功能开发比我们去部署和管理的成本还高，那就可以选择函数服务，我们看函数服务的云服务器和之前相比位于更后端了，这个不代表云服务没了，只是不需要我们关心了，这些服务器的状态又厂商根据我们的需求来调整，我们只需要将代码上传到指定的地方，一般就是svn或gitlab了，上传之后一般通过事件来触发代码打包和执行，事件一般包括有对象存储事件，也就是说检测到有代码上传了，或者是一些指令事件，比如手动触发等。这样代码就在后台服务器执行了。相比之前我们现在只需要上传代码就可以了，环境和高可用这些就不需要我们关心了。而且函数服务一般是按需收费，就是代码真正运行的时候才收费。</p>
<ul>
<li><strong>应用</strong></li>
</ul>
<p>这俩游戏可能大部分同学都有玩过吧，尤其是上面的原神，下面这个是朝夕光年自研的航海王。现在很多游戏都有自拍分享功能，我们会上传分享自己在游戏中的一些图片，或者上传一些游戏中的高光时刻视频。那这个上传服务就可以使用函数服务，我们将图片，视频上传至后台对象存储，上传成功事件触发我们的函数服务，包括检测图片或视频中是否有一些违规或敏感信息，然后将文件进行压缩回传。这样我们不需要关心我们这个服务可以承载多少qps，这些有服务提供商来进行动态调整，而且只有在函数提供服务的时候我们才按需付费，节省了成本。</p>
<ul>
<li><strong>VPC</strong></li>
</ul>
<p>虚拟私有云，这个名字可能会让我们感觉怎么云服务里面还有云呢？那他其实是云里面的局域网。我们类比下本地局域网，本地局域网大家比较熟悉了，比如我们动画学院是一个子网，其他不同的学院也是不同的子网，不同的子网之间通过路由组成了整个学校的局域网。vpc就相当于云服务上的局域网，我们不同的服务在同一个子网下，比如之前我们提到的游戏服务器在同一个子网下，存储服务在另一个子网下，但他们整体在同一个局域网下，这样保证了通信的效率和安全性。</p>
<ul>
<li><strong>SLB</strong></li>
</ul>
<p>随着我们的游戏越来越火，我们服务器不能部署在一台服务器上，一个是随着硬件需求的增高，成本也在翻倍，单台服务器也有性能的瓶颈。另一个只有一台，服务器不能保证高可用，服务器一旦宕机了，整个服务就不可用了。我们之前提到的例子中呢，大部分其实都做成一个子网，由多台服务器组成，那slb就负责对多台云服务器进行流量分发和负载均衡。我们接下来看下slb工作的流程，游戏的请求发送到slb服务loadbalancer，loadbalancer也可以是多台部署，完全消除单点的隐患。然后loadbalancer根据我们定义的负载均衡策略和转发规则，将请求转发到我们后端的不同业务服务器，业务服务器也是多台部署，没有单点问题，业务服务处理完请求后，将消息结果返回给loadbalancer，再有loadbalancer返回给前端。</p>
<p>那slb除了流量分发之外还提供了很多其他特性，包括虚拟服务IP地址，我们可以把后端所有的服务节点视为同一个虚拟服务对外提供，保证了高性能和高可用的服务池。我们还可以自定义我们的协议转发规则，比如一些战斗协议转发到战斗服务器集群，消费协议转发到支付服务器集群等。还可以自定义调度规则，比如优先使用同地区的服务集群，或者最空闲的服务集群等。还提供了健康检测，新增服务器和删除服务器的时候，slb自动从可用节点中加入或删除，提高应用整体服务能力。防护能力，防DDoS攻击，还可以添加SSL证书，这样https的请求，就不需要我们在业务服务器中单独处理了。另外就是多区域容灾，这样即使我们的某一个机房出现问题，也不会影响我们服务的整体可用性。</p>
<ul>
<li><strong>应用</strong></li>
</ul>
<p>以我之前做过的一个卡牌游戏举例，在其中应用到多台slb的服务，一个是游戏更新的服务，在这个服务中包括了多台负责在游戏中一些需要资源热更的地方，slb将资源更新的请求发送到负载比较低的后台web服务上。另一个是游戏运行服务，所有游戏运行服务的节点都挂在这个slb下面，slb负责将玩家请求分发到对应的服务器上。首先通过不同的slb进行了业务方面的分流，不同的slb内部有不同的服务器去负责处理请求，这样极大的提升了系统的可扩展性，业务之间呢也相互隔离。然后每个服务之内呢也是部署了多台节点，保证了服务的高可用。</p>
<ul>
<li><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1></li>
</ul>
<p><a href="https://segmentfault.com/a/1190000022739178?from=from_parent_mindnote">https://segmentfault.com/a/1190000022739178?from=from_parent_mindnote</a></p>
<p><a href="https://main.qcloudimg.com/raw/document/product/pdf/375_12015_cn.pdf?from=from_parent_mindnote">https://main.qcloudimg.com/raw/document/product/pdf/375_12015_cn.pdf?from=from_parent_mindnote</a></p>
<p><a href="https://imgtu.com/i/5tm5HP"><a href="https://z3.ax1x.com/2021/10/17/5tm5HP.png" title="5tm5HP.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5tm5HP.png" alt="5tm5HP.png"></a></a><br><a href="https://imgtu.com/i/5tm74S"><a href="https://z3.ax1x.com/2021/10/17/5tm74S.png" title="5tm74S.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5tm74S.png" alt="5tm74S.png"></a></a><br><a href="https://imgtu.com/i/5tmb9g"><a href="https://z3.ax1x.com/2021/10/17/5tmb9g.png" title="5tmb9g.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5tmb9g.png" alt="5tmb9g.png"></a></a><br><a href="https://imgtu.com/i/5tmTN8"><a href="https://z3.ax1x.com/2021/10/17/5tmTN8.png" title="5tmTN8.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5tmTN8.png" alt="5tmTN8.png"></a></a><br><a href="https://imgtu.com/i/5tmoAf"><a href="https://z3.ax1x.com/2021/10/17/5tmoAf.png" title="5tmoAf.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5tmoAf.png" alt="5tmoAf.png"></a></a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>杂乱</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器G1详解</title>
    <url>/garbage-first/</url>
    <content><![CDATA[<div class=".article-gallery"><p>转载自：<a href="https://www.cnblogs.com/yanl55555/p/13366387.html">JVM七大垃圾回收器下篇G1(Garbage First)</a></p>
<h1 id="G1回收器-区域化分代式"><a href="#G1回收器-区域化分代式" class="headerlink" title="G1回收器:区域化分代式"></a>G1回收器:区域化分代式</h1><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong><br>  原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。<br>  与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。<br>  官方给G1设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量（高吞吐），所以才担当起“全功能收集器”的重任与期望。</p>
<span id="more"></span>

<h2 id="为什么名字叫做Garbage-First-（G1）呢？"><a href="#为什么名字叫做Garbage-First-（G1）呢？" class="headerlink" title="为什么名字叫做Garbage First （G1）呢？"></a><strong>为什么名字叫做Garbage First （G1）呢？</strong></h2><ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region） （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。</li>
<li>G1 （Garbage一First） 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li>
<li>在JDK1. 7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel 0ld组合。被Oracle官方称为“全功能的垃圾收集器” 。</li>
<li>与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） 。</li>
<li>G1在jdk8中还不是默认的垃圾回收器，需要使用一XX： +UseG1GC来启用。</li>
</ul>
<h2 id="G1垃圾回收器优势"><a href="#G1垃圾回收器优势" class="headerlink" title="G1垃圾回收器优势"></a>G1垃圾回收器优势</h2><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：四个特点：</p>
<ul>
<li>并行与并发<ul>
<li>➢并行性： G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li>分代收集<ul>
<li>➢从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>➢将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>➢和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
</li>
</ul>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144423293-687202683.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144423293-687202683.png" alt="img"></a><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144442615-1696089988.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144442615-1696089988.png" alt="img"></a></p>
<ul>
<li><p>空间整合</p>
</li>
<li><ul>
<li>➢CMS： “标记一清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>
<li>➢G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法。</li>
<li>但整体上实际可看作是标记一压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
</li>
<li><p>可预测的停顿时间模型（即：软实时soft real一time）</p>
<p>： 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li>➢由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>➢G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以 及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>➢相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要.好很多。</li>
</ul>
</li>
</ul>
<h2 id="G1缺点"><a href="#G1缺点" class="headerlink" title="G1缺点"></a>G1缺点</h2><ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。</li>
</ul>
<h2 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h2><ul>
<li>-XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。</li>
<li>-XX：G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>
<li>-XX：MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>
<li>-xX：ParallelGCThread 设置sTw.工作线程数的值。最多设置为8</li>
<li>-XX：ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</li>
<li>-XX：Ini tiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>
</ul>
<h2 id="G1回收器的常见操作步骤"><a href="#G1回收器的常见操作步骤" class="headerlink" title="G1回收器的常见操作步骤"></a>G1回收器的常见操作步骤</h2><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启G1垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。（后文详细讲）</p>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723143818066-1702622040.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723143818066-1702622040.png" alt="img"></a></p>
<h2 id="G1适用场景"><a href="#G1适用场景" class="headerlink" title="G1适用场景"></a>G1适用场景</h2><ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li>
<li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>
<li>用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：<br>①超过50%的Java堆被活动数据占用；<br>②对象分配频率或年代提升频率变化很大；<br>③GC停顿时间过长（长于0. 5至1秒）。</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC（线程优先级低）的多线程操作</li>
<li>而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
</ul>
<h2 id="分区region-化整为零"><a href="#分区region-化整为零" class="headerlink" title="分区region,化整为零"></a>分区region,化整为零</h2><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。</p>
<p>可以通过一 XX：G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑_上的连续。</p>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723150834993-49164173.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723150834993-49164173.png" alt="img"></a></p>
<ul>
<li>一个region 有可能属于Eden， Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。</li>
<li>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li>
</ul>
<h1 id="G1回收器垃圾回收过程"><a href="#G1回收器垃圾回收过程" class="headerlink" title="G1回收器垃圾回收过程"></a>G1回收器垃圾回收过程</h1><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC （Young GC ）</li>
<li>老年代并发标记过程（ Concurrent Marking）</li>
<li>混合回收（Mixed GC ）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723151103477-1084742760.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723151103477-1084742760.png" alt="img"></a></p>
<p> 顺时针， young gc 一&gt; young gc + concurrent mark 一&gt; Mixed GC顺序，进行垃圾回收。</p>
<p>1.应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的（多个回收线程）独占式(STW)收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>2.当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>3.标记完成马.上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起 被回收的。</p>
<p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31 个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h2 id="记忆集与写屏障"><a href="#记忆集与写屏障" class="headerlink" title="记忆集与写屏障"></a>记忆集与写屏障</h2><ul>
<li>一个对象被不同区域引用的问题(分代引用问题)</li>
<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li>
<li>在其他的分代收集器，也存在这样的问题（ 而G1更突出）</li>
<li>回收新生代也不得不同时扫描老年代？</li>
<li>这样的话会降低MinorGC的效率；</li>
</ul>
<p><strong>·解决方法：</strong></p>
<ul>
<li>➢无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：</li>
<li>➢每个Region都有 一个对应的Remembered Set；</li>
<li>➢每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .</li>
<li>➢然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；</li>
<li>➢如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>
<li>➢当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li>
</ul>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723152028598-2055678824.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723152028598-2055678824.png" alt="img"></a></p>
<h1 id="G1回收过程详解"><a href="#G1回收过程详解" class="headerlink" title="G1回收过程详解"></a>G1回收过程详解</h1><h2 id="过程1年轻代GC"><a href="#过程1年轻代GC" class="headerlink" title="过程1年轻代GC"></a>过程1年轻代GC</h2><ul>
<li>JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>
<li>年轻代垃圾回收只会回收Eden区（主动）和Survivor区（被动）。</li>
<li>YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li>
<li>复制算法（S、E–&gt;空闲区相当于To区）（S–&gt;寻找新的空闲区作为老年代）</li>
</ul>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723153515525-318612700.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723153515525-318612700.png" alt="img"></a></p>
<p>然后开始如下回收过程：</p>
<ul>
<li>第一阶段，扫描根<ul>
<li>根是：指static变量指向的对象（类生命周期，方法区引用的对象），正在执行的方法调用链条上的局部变量等（方法生命周期，虚拟机栈引用的对象）。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>
</ul>
</li>
<li><strong>第二阶段，更新RSet</strong></li>
</ul>
<p>​     处理dirty card queue（ 见备注）中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。</p>
<ul>
<li><ul>
<li>dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li>
<li>在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
</li>
<li><p><strong>第三阶段，处理RSet</strong>。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
</li>
<li><p><strong>第四阶段，复制对象</strong>。<br>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。</p>
</li>
<li><p><strong>第五阶段，处理引用</strong>。<br>处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
</li>
</ul>
<h2 id="过程2年轻代GC-并发标记过程"><a href="#过程2年轻代GC-并发标记过程" class="headerlink" title="过程2年轻代GC+并发标记过程"></a>过程2年轻代GC+并发标记过程</h2><ul>
<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一.次年轻代GC。</li>
<li>根区域扫描（Root Region Scanning） ： G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</li>
<li>并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li>再次标记（Remark）： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。</li>
<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。<ul>
<li>➢这个阶段并不会实际上去做垃圾的收集</li>
</ul>
</li>
<li>并发清理阶段：识别并清理完全空闲的区域。</li>
</ul>
<h2 id="过程3混合回收"><a href="#过程3混合回收" class="headerlink" title="过程3混合回收"></a>过程3混合回收</h2><p>当越来越多的对象晋升到老年代Oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个OldGC，除了回收整个Young Region，还会回收一部分的0ldRegion。这里需要注意：是一部分老年代， 而不是全部老年代。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过一XX： G1MixedGCCountTarget设置）被回收。</li>
<li>混合回收的回收集（Collection Set） 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，一xX： G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值一Xx： G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ul>
<h2 id="过程4Full-GC"><a href="#过程4Full-GC" class="headerlink" title="过程4Full GC"></a>过程4Full GC</h2><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。<br>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。<br>导致G1Full GC的原因可能有两个：</p>
<ul>
<li>1.Evacuation的时候没有足够的to一 space来存放晋升的对象；</li>
<li>2.并发处理过程完成之前空间耗尽。</li>
</ul>
<p><strong>补充：</strong></p>
<p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实.本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h1 id="G1回收器优化建议"><a href="#G1回收器优化建议" class="headerlink" title="G1回收器优化建议"></a>G1回收器优化建议</h1><ul>
<li>年轻代大小<ul>
<li>➢避免使用一Xmn或一XX：NewRatio等相关选项显式设置年轻代大小➢固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ul>
<h1 id="7种经典的垃圾回收器总结"><a href="#7种经典的垃圾回收器总结" class="headerlink" title="7种经典的垃圾回收器总结"></a>7种经典的垃圾回收器总结</h1><p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723155737552-624347732.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723155737552-624347732.png" alt="img"></a></p>
<p> 不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合（连线），如下图：</p>
<p><a href="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723160245863-1482952705.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723160245863-1482952705.png" alt="img"></a></p>
<ul>
<li>1.两个收集器间有连线，表明它们可以搭配使用： Serial/Serial 0ld、Serial /CMS、ParNew/Serial 0ld、ParNew/CMS、 Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；</li>
<li>2.其中Serial 0ld作 为CMS出现”Concurrent Mode Failure”失败 的后备预案。</li>
<li>3.（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial 0ld这两个组合声明为Deprecated （JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>4.（绿色虚线）JDK 14中：弃用ParallelScavenge 和Serial0ld GC组合 （JEP 366）</li>
<li>5.（青色虚线）JDK 14中：删除CMS垃圾回收器 （JEP 363 ） GC发展阶段： Serial =&gt; Parallel （并行） =&gt; CMS （并发） =&gt; G1 =&gt; ZGC</li>
</ul>
<h2 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a><strong>怎么选择垃圾回收器</strong></h2><ul>
<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>
<li>怎么选择垃圾收集器？<ul>
<li>1.优先调整堆的大小让JVM自适应完成。</li>
<li>2.如果内存小于100M，使用串行收集器</li>
<li>3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>
</ul>
</li>
<li>最后需要明确一一个观点：<ul>
<li>1.没有最好的收集器，更没有万能的收集；</li>
<li>2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
</li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>常见垃圾收集器的特点</title>
    <url>/gc-charator/</url>
    <content><![CDATA[<div class=".article-gallery"><h4 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h4><p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/11.png?resize=640,175" title="常见垃圾收集器的特点 - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/11.png?resize=640,175" alt="常见垃圾收集器的特点 - 第1张  | 张嘎"></a></p>
<p><strong>缺点：</strong>1.CMS收集器对CPU资源非常敏感。并发执行的特性，会对用户线程产生影响。<br>2.CMS收集器无法处理浮动垃圾。并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，CMS无法处理他们。<br>3.采用标记-清楚算法实现，产生内存碎片。</p>
<h4 id="G1（Garbage-First）收集器"><a href="#G1（Garbage-First）收集器" class="headerlink" title="G1（Garbage-First）收集器"></a>G1（Garbage-First）收集器</h4><p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/12.png?resize=640,173" title="常见垃圾收集器的特点 - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/12.png?resize=640,173" alt="常见垃圾收集器的特点 - 第2张  | 张嘎"></a></p>
<p><strong>特点：</strong>1.并发与并行。<br>2.分代收集。<br>3.空间整合。标记-整理算法。<br>4.可预测的停顿。降低停顿时间是G1和CMS共同的关注点。<br>5.G1可以进行垃圾收集的范围包括新生代和老年代。将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。<strong>化整为零的思路，并维护优先队列，使得G1收集器实现可预测的停顿。</strong><br>6.可达性分析时跨Region对象引用的问题，虚拟机维护Remembered Set来避免全堆扫描。</p>
<h4 id="ZGC（）收集器"><a href="#ZGC（）收集器" class="headerlink" title="ZGC（）收集器"></a>ZGC（）收集器</h4><h4 id="堆外内存导致溢出错误"><a href="#堆外内存导致溢出错误" class="headerlink" title="堆外内存导致溢出错误"></a>堆外内存导致溢出错误</h4><p>堆外内存不在垃圾回收的范围内，如果发生内存溢出的情况，也有可能是堆外内存引起的，常见的堆外内存包括：<br>1.Direct Memory。可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError: Direct buffer memory。<br>2.线程堆栈。可通过-Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread。<br>3.Socket缓存区。IOException: Too many open files。<br>4.JNI代码。调用本地库，本地库使用的内存也不在堆中。<br>5.虚拟机和GC。虚拟机和GC的代码执行也要消耗一定的内存。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>地理位置信息GeoHash算法及Google S2算法</title>
    <url>/geohash/</url>
    <content><![CDATA[<div class=".article-gallery"><p>最近在持续优化服务器3D场景建模的方案，受Redis的GEO启发，现在有一个空间和时间上都比较理想的方案，等实际测试和实现之后再整理完整文档。</p>
<p><a href="https://imgtu.com/i/hMnZuR"><a href="https://z3.ax1x.com/2021/08/27/hMnZuR.md.png" title="hMnZuR.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/27/hMnZuR.md.png" alt="hMnZuR.md.png"></a></a></p>
<p>先给出两篇不错的算法文章。</p>
<p>非常详细的算法分析：</p>
<p><a href="https://halfrost.com/go_spatial_search/">https://halfrost.com/go_spatial_search/</a></p>
<p><a href="https://www.cnblogs.com/LBSer/p/3310455.html">https://www.cnblogs.com/LBSer/p/3310455.html</a></p>
<p>Redis GEO使用：</p>
<p><a href="https://www.jianshu.com/p/c9801c4f9f6a">https://www.jianshu.com/p/c9801c4f9f6a</a></p>
<p>寻路算法：</p>
<p><a href="http://gad.qq.com/article/detail/33637">http://gad.qq.com/article/detail/33637</a></p>
<p><a href="https://zerowidth.com/2013/05/05/jump-point-search-explained.html">https://zerowidth.com/2013/05/05/jump-point-search-explained.html</a></p>
<p><a href="http://qiao.github.io/PathFinding.js/visual/">http://qiao.github.io/PathFinding.js/visual/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html">http://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>golang笔记</title>
    <url>/golang-summary/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="go-gc"><a href="#go-gc" class="headerlink" title="go gc"></a>go gc</h2><ul>
<li>开始标记：STW，开启写屏障，统计root对象。</li>
<li>三色标记：扫描root对象，包括全局指针和G栈上的，扫描G栈时G栈需要暂停。root标记灰色，没引用标记黑色，有引用标记黑色并把引用标记灰色，直到灰色队列为空。与用户程序并行。</li>
<li>重新扫描：STW，因为上一步并行，可能重新分配对象和赋值，通过写屏障记录下来。</li>
<li>回收白色对象</li>
<li>写屏障：记录第一次扫描时对象的状态，和第二次比对，引用状态变化的对象标记灰色，继续处理。</li>
</ul>
<span id="more"></span>

<h2 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h2><ul>
<li>CAS获取锁，成功则返回</li>
<li>判断是否可进入自旋，1当前锁非饥饿且已锁定，2次数小于4，3cpu&gt;1，4正在执行中，且队列空闲的P大于0。进入自旋会执行30次PAUSE指令。</li>
<li>自旋结束后判断当前锁的状态，饥饿模式下不会去请求锁，而会将goroutine加入队列末端。</li>
<li>自旋后CAS获取锁，成功则返回。失败则休眠当前goroutine，等待信号量唤醒。</li>
<li>goroutine被唤醒后会判断是否饥饿模式（锁等待超过1ms就会进入饥饿状态），饥饿状态下获得互斥锁，如果锁等待队列中只有当前goroutine则取消饥饿状态，如果判断是正常模式，设置唤醒，重置迭代次数并重新获取锁。</li>
<li>解锁没有绑定关系，可以一个goroutine锁定，另一个goroutine解锁。</li>
<li>解锁，atomic修改锁状态，如果设置后等待锁的goroutine为0则返回，不为0说明还有其他goroutine在等待锁。</li>
<li>饥饿模式下，直接将锁交给下一个等待的goroutine，不会退出饥饿模式。</li>
<li>正常模式下，判断有没有等待者，或者goroutine已被唤醒或处于锁定。唤醒等待者并移交锁。</li>
<li>读锁：<ul>
<li>加锁：原子方法将正在读的加1，返回负数，说明有其他写锁，等待。</li>
<li>解锁：正在读的减1，返回负数，说明有在等待的写操作，唤醒写操作</li>
</ul>
</li>
<li>写锁：<ul>
<li>加锁：调用互斥锁lock，获得互斥锁，将在读goroutine数设置为负值，阻塞后续读操作，如果仍然有在读的锁持有，等待读锁完成后唤醒。</li>
<li>解锁：恢复之前写入的负数，循环唤醒当前等待的读操作。</li>
</ul>
</li>
<li>sync.Once实现原理，用一个atomic变量判断函数是否已执行，如果执行过则不执行，如果未执行则尝试执行，可能多个goroutine同时尝试，加锁操作，获取锁后再检测上面的变量是否已执行，这里采用双重检测机制，执行完方法后，设置atomic变量。基本就是单例的原理。</li>
</ul>
<h2 id="kitex"><a href="#kitex" class="headerlink" title="kitex"></a>kitex</h2><ul>
<li>公司开源的RPC框架，<a href="https://github.com/cloudwego/kitex">github</a></li>
<li>底层网络基于Netpoll实现，kite基于golang的net实现，BIO，每个连接都需要一个goroutine，大量连接时，上下文切换开销。</li>
<li>Netpoll基于epoll实现，epoll是linux提供的多路复用网络IO模型，TCP读写都是通过缓冲区来实现的，操作系统为每个tcp连接维护读、写缓冲区。epoll基于监听读写缓冲区事件来实现对网络连接的读写和管理。epoll通过红黑树实现对fd(文件描述符)的高效查找，为每个监听的网络io向操作系统注册回调函数，有网络io发送的时候回调函数将对应的事件加入rdlist中，epoll只需要判断rdlist是不是空即可。<ul>
<li>自建epoll管理连接状态</li>
<li>自建内存池，提高buffer性能</li>
<li>支持批量系统命令调用</li>
<li>协程池</li>
<li>多种交互模式（双向streaming，Oneway）</li>
<li>协议扩展</li>
</ul>
</li>
<li>通过netpoll模型，实现G1在M上进行IO操作时，将G1移到epoll监听中，M继续执行P上其他可执行的G2，刚才那个阻塞G1IO调用结束后，再加回到P的队列中或Global队列中。实现以同步的模式写异步逻辑。</li>
</ul>
<h2 id="java-gc"><a href="#java-gc" class="headerlink" title="java gc"></a>java gc</h2><ul>
<li>将内存划分成region，每个region表示eden，survivor，old，huge。跟踪各个region垃圾回收价值，维护优先级列表，避免在整个堆中进行垃圾回收。</li>
<li>region间是复制算法</li>
<li>可预测停顿时间的模型</li>
<li>Eden younggc stw, 45%, 并发标记，混合回收，fullgc。</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><ul>
<li>减少string与byte[]转换。</li>
<li>文本连接用strings.Builder，和bytes.Buffer比起来底层没有内存分配和拷贝，是byte slice结构到string结构的转换。</li>
<li>同java一样，slice和map预分配空间，减少内存拷贝，map还可减少rehash。</li>
<li>函数中尽可能使用值而不是指针，这可能会和大家常听到的用指针避免对象的拷贝矛盾，主要是因为指针会使逃逸分析将变量分配在堆上。这个规则同样适用于函数的recv，指针仅仅应该表示可修改权。slice类型如非必要不要包含指针。但是channel传递的对象，无论指针还是值都会把对象分配到堆上，直接传指针就行。</li>
<li>map尽量存值而不是指针。</li>
<li>使用sync.Pool优化内存，适用短周期小内存对象，必须清楚对象的生命周期。放入pool前先置0。</li>
<li>不带缓冲区的channel不发生内存拷贝。</li>
<li>atomic优化。</li>
</ul>
<h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><ul>
<li>Cpu/heap/goroutine/mutex/block/thread</li>
<li>top/source/flame graph</li>
<li>trace，mmu可以查看用户程序cpu时间占比，确定gc是否耗时过长。</li>
<li>Cpu top视图和web视图<ul>
<li>flat函数自身耗时和占比</li>
<li>cum函数自身及其调用其他总耗时及占比</li>
<li>list根据制定的正则查找代码，显示每行时间占比</li>
</ul>
</li>
<li>heap<ul>
<li>同上类似 source视图查看每行代码内存情况</li>
<li>累计和当前持有的对象数和大小</li>
</ul>
</li>
<li>goroutine<ul>
<li>火焰图查看</li>
</ul>
</li>
<li>mutex<ul>
<li>可查看锁耗时的具体情况，以及代码</li>
</ul>
</li>
<li>block<ul>
<li>pprof中一些过小的调用节点可能不会展示，block中可能能看到的具体信息小于count计数</li>
</ul>
</li>
<li>采样原理<ul>
<li>cpu。进程开始采样，向操作系统启动定时器，操作系统每隔10ms向进程发送一次信号，进程收到信号，记录调用堆栈。进程会启动写缓冲的goroutine，每隔100ms将堆栈信息写入输出流，采样停止时，停止计时器，写缓冲结束输出。</li>
<li>goroutine和threadcreate。StopTheWorld-&gt;遍历用户发起的goroutine/m列表-&gt;输出创建g/m的堆栈-&gt;StartTheWorld。</li>
<li>heap。只能采样堆内存，每分配512K记录一次，记录分配情况和释放情况，可以算出当前使用情况。</li>
<li>metux/block。采样抢锁/阻塞操作次数和耗时，超过阈值才会记录。发生的时候上报时间和堆栈信息上报profiler，profiler根据策略进行一些丢弃和统计。</li>
</ul>
</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>Fetcher,BatchFetcher,Loader,BatchLoader.</li>
<li>回源(Loader)要保证安全，避免缓存击穿时引发雪崩。<ul>
<li>singleflight：锁加共享。</li>
<li>多级缓存。</li>
</ul>
</li>
<li>缓存穿透：不存在的数据要缓存。</li>
<li>缓存击穿：某一瞬间缓存失效，大量请求落到db上。</li>
<li>缓存策略：<ul>
<li>缓存优先：缓存命中返回。miss-&gt;回源-&gt;更新缓存-&gt;返回。</li>
<li>回源优先（兜底）：回源成功-&gt;更新缓存-&gt;返回结果。回源失败-&gt;缓存-&gt;命中返回，未命中返回失败。</li>
<li>缓存优先，同步回源，回源失败逻辑过期数据兜底：缓存命中返回。缓存miss-&gt;回源成功-&gt;更新缓存-&gt;返回，回源失败-&gt;逻辑过期数据返回，逻辑数据失败-&gt;返回失败。</li>
<li>缓存优先，过期数据兜底，异步回源：缓存命中返回。缓存miss-&gt;逻辑过期数据-&gt;返回-&gt;异步回源-&gt;更新缓存。缓存miss-&gt;逻辑过期数据失败-&gt;同步回源-&gt;更新缓存-&gt;返回结果。</li>
<li>只读缓存：只从缓存中读数据，有其他方式更新缓存，一般是全量缓存。</li>
<li>只回源：缓存降级。</li>
</ul>
</li>
<li>字节缓存：map&lt;int64, []byte&gt; 不包含指针，加速GC。对象缓存：map&lt;string, interface{}&gt;包含指针。</li>
<li>大key，10K或5000个元素。</li>
</ul>
<h2 id="java性能"><a href="#java性能" class="headerlink" title="java性能"></a>java性能</h2><ul>
<li><p>堆外内存</p>
</li>
<li><p>kwaibook春节笔记</p>
</li>
<li><p>缓存击穿：json反序列化和序列化性能，缓存失效后，读db前先加锁，本地缓存，拆除大key</p>
</li>
<li><p>sandbox笔记</p>
</li>
</ul>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><ul>
<li>open match有三个微服务，frontend，director，MMF。</li>
<li>简化了微服务的数量，可以在单个服务器运行，也可以在集群运行。</li>
<li>通过动态配置，方便不同项目组动态接入匹配模式。</li>
<li>支持一个游戏运行多个匹配模式，同一玩家可以同时匹配多个模式。</li>
<li>每个匹配模式对应一个匹配算法，如先来先匹配-斗地主，同城匹配。</li>
<li>支持了RPC和RMQ返回匹配结果。</li>
<li>匹配流程，gameserver创建ticket，发送给匹配服放入ticketpool中。匹配服务会定时从池中取出ticket，mmf算法会选取合适的ticket匹配，创建match。match创建进一步进行过滤，去除重复匹配的票，删除异常的match，最后将结果通知gameserver，删除ticket。</li>
<li>按elo分数组队，</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><a href="https://www.jianshu.com/p/125bba448cdd">https://www.jianshu.com/p/125bba448cdd</a></li>
<li><a href="https://cbsheng.github.io/posts/redis%E9%87%8C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86/">一个简单请求如何被处理</a></li>
<li>IO多路复用，监听端口6379，socket封装成事件，注册到事件循环器里，还有回调函数。client新连接建立时，回调函数accept，返回一个FD，也注册进事件循环器里。这样之后client发送请求时，FD可读，事件循环器捕获到事件并调用对应的函数。</li>
<li>每个连接都是client对象，存储命令，输入/出缓冲区。</li>
<li>事件循环器拿到就绪事件的文件描述符后，判断可读还是可写，调用对应的回调函数。</li>
<li>数据结构<ul>
<li>stirng： int、embstr、raw。不能用c++string来代替，c++string不支持预分配</li>
<li>List：ziplist、linkedlist</li>
<li>hash：ziplist、hashtable</li>
<li>set：intset、hashtable</li>
<li>zset：ziplist、skiplist+table</li>
<li>hash实现：sizemask=size-1，链地址头插法，rehash</li>
</ul>
</li>
</ul>
<h2 id="Limiter"><a href="#Limiter" class="headerlink" title="Limiter"></a>Limiter</h2><ul>
<li>滑动窗口：redis指令，ZREMRANGEBYSCORE上个窗口前的值，ZCARD查看当前值，判断和want是否限流，不限流的话，ZADD(timestamp, timestamp+i)，设置过期时间，返回当前ZCARD数。</li>
<li>固定窗口：根据时间封装key，可以是一些多维的参数key，incr方法返回判断是否限流，设置过期时间。</li>
</ul>
<p><del>性能分析 golang课程</del></p>
<p><del>匹配 p5 elo</del></p>
<p><del>网关</del></p>
<p>tcp、kcp</p>
<p><a href="https://zhuanlan.zhihu.com/p/388704023">https://zhuanlan.zhihu.com/p/388704023</a></p>
<h5 id="redis："><a href="#redis：" class="headerlink" title="redis："></a>redis：</h5><p><a href="https://segmentfault.com/a/1190000040206818">https://segmentfault.com/a/1190000040206818</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/148562122">https://zhuanlan.zhihu.com/p/148562122</a></p>
<p><a href="https://www.jianshu.com/p/125bba448cdd">https://www.jianshu.com/p/125bba448cdd</a></p>
<p><a href="https://cbsheng.github.io/posts/redis%E9%87%8C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86/">https://cbsheng.github.io/posts/redis%e9%87%8c%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e8%af%b7%e6%b1%82%e5%a6%82%e4%bd%95%e8%a2%ab%e5%a4%84%e7%90%86/</a></p>
<p>java锁流程，读写锁，延迟队列。</p>
<p><a href="https://segmentfault.com/a/1190000022904663">https://segmentfault.com/a/1190000022904663</a></p>
<p>java自带排序，blog</p>
<p>mysql，blog</p>
<p><a href="https://zhuanlan.zhihu.com/p/48327345">https://zhuanlan.zhihu.com/p/48327345</a></p>
<p><a href="https://www.w3school.com.cn/sql/sql_datatypes.asp">https://www.w3school.com.cn/sql/sql_datatypes.asp</a></p>
<p><a href="https://juejin.cn/post/6844903668571963406">https://juejin.cn/post/6844903668571963406</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&amp;mid=2247484041&amp;idx=1&amp;sn=76d3bf1772f9e3c796ad3d8a089220fa&amp;chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&amp;token=2025456560&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&amp;mid=2247484041&amp;idx=1&amp;sn=76d3bf1772f9e3c796ad3d8a089220fa&amp;chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&amp;token=2025456560&amp;lang=zh_CN#rd</a></p>
<p><a href="https://blog.csdn.net/ibigboy/article/details/104571930?depth_1-">https://blog.csdn.net/ibigboy/article/details/104571930?depth_1-</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<p>mongo</p>
<p><a href="https://www.infoq.cn/article/tencent-ranking-system-practice-and-challenges">https://www.infoq.cn/article/tencent-ranking-system-practice-and-challenges</a></p>
<p><a href="https://www.atzlinux.com/atzlinux/doc/os2atc2019/SPDK-bytedance-miaoyu.pdf">https://www.atzlinux.com/atzlinux/doc/os2atc2019/SPDK-bytedance-miaoyu.pdf</a></p>
<p><a href="http://point-blank-games.com/theses/Sara_Budde_Thesis.pdf">http://point-blank-games.com/theses/Sara_Budde_Thesis.pdf</a></p>
<p>byted open：</p>
<p><a href="https://www.jianshu.com/p/d7284007f883">https://www.jianshu.com/p/d7284007f883</a></p>
<p><a href="https://www.jianshu.com/p/dd5fb725331b">https://www.jianshu.com/p/dd5fb725331b</a></p>
<p><a href="https://docs.google.com/presentation/d/1k7ZlumJKxykn6CXWqdqsx1XcKMxt7HvWgYz1oxgN66E/edit#slide=id.g56a70cb717_0_263">https://docs.google.com/presentation/d/1k7ZlumJKxykn6CXWqdqsx1XcKMxt7HvWgYz1oxgN66E/edit#slide=id.g56a70cb717_0_263</a></p>
<p><a href="https://app.diandian.com/rank/ios/1-2-172-75-4?time=1620835200000&amp;device=1&amp;timetype=today">https://app.diandian.com/rank/ios/1-2-172-75-4?time=1620835200000&amp;device=1&amp;timetype=today</a></p>
<p><a href="https://www.appannie.com/en/apps/ios/top/japan/overall/iphone/">https://www.appannie.com/en/apps/ios/top/japan/overall/iphone/</a></p>
<p><a href="https://segmentfault.com/a/1190000022678327">https://segmentfault.com/a/1190000022678327</a></p>
<p><a href="https://segmentfault.com/a/1190000022731367">https://segmentfault.com/a/1190000022731367</a></p>
<p><a href="https://www.infoq.cn/article/goyirzr19vqvtupois92">https://www.infoq.cn/article/goyirzr19vqvtupois92</a></p>
<p><a href="https://mp.weixin.qq.com/s/_LovnIqJYAuDpTm2QmUgrA">https://mp.weixin.qq.com/s/_LovnIqJYAuDpTm2QmUgrA</a></p>
<p><a href="https://pandaychen.github.io/2020/03/03/BIGCACHE-ANALYSIS/">https://pandaychen.github.io/2020/03/03/BIGCACHE-ANALYSIS/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/91136759">https://zhuanlan.zhihu.com/p/91136759</a></p>
<p><a href="https://lailin.xyz/post/go-training-03.html">https://lailin.xyz/post/go-training-03.html</a></p>
<p><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">https://blog.wolfogre.com/posts/go-ppof-practice/</a></p>
<p><a href="https://juejin.cn/post/6844903887757901831">https://juejin.cn/post/6844903887757901831</a></p>
<p><a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>
<p><a href="https://blog.csdn.net/abcjennifer/article/details/47110991">https://blog.csdn.net/abcjennifer/article/details/47110991</a></p>
<p><a href="https://github.com/gogap/aop">https://github.com/gogap/aop</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1165876">https://cloud.tencent.com/developer/article/1165876</a></p>
<p>unity：</p>
<p><a href="https://developer.unity.cn/projects/openday-hangzhou-unity-probe">https://developer.unity.cn/projects/openday-hangzhou-unity-probe</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>向优秀团队学习（转载）</title>
    <url>/good-team/</url>
    <content><![CDATA[<div class=".article-gallery"><p>价值导向，数据驱动</p>
<ul>
<li>用产出和价值说话，推动力和执行力第一</li>
<li>数据驱动，主动做数据分析，而不是等着别人给数据</li>
<li>用数据和深入分析结果来讨论，不拍脑袋，通过数据分析跟产品一起找优化方向，不做纯执行者</li>
<li>承诺必达，关注交付，不延期 - 我们要追求极致，但不要追求完美，必要时需要在按时交付和追求极致间作出权衡，可以在尽最大努力的情况下，先按时交付，同时说明哪些地方还不够极致，交付后会持续、马上去优化 - 按时交付 和 追求极致之间不是妥协，是权衡，判断优先级<br>提倡</li>
<li>「研发：这个需求解决了用户什么痛点？目标用户是谁？优先级高吗？有运营计划吗？我还可以做点什么，还能再一起推动一下合作方吗？」「产品：😱」</li>
<li>项目很重要，排期实在太紧，不追求完美，以可行的最小方案保障项目上线，并把权衡考虑因素、影响同步到相关同学</li>
<li>需求上线后，积极主动关注上线效果；核心项目，长期关注数据波动、一线反馈<br>反对</li>
<li>「A：我真厉害呀，这个双月上线了 30 个接口」「用户：这些接口有啥用？一点价值没有～」</li>
<li>「A：这个项目各方资源投入 OK 吗？推进有什么困难吗？」「B：我这里没问题，运营、测试就要问 xxx 了，我也不知道。这个我觉得应该是产品的问题吧」</li>
<li>延期了也没事，就说有临时有事占用了时间～</li>
<li>我就要追求完美，就算项目延期我也要抠每一个细节点，延期一个月后，项目终于上线了：大家快来看，我的项目都是精品</li>
<li>我所有的工作在代码上线的那一刻就结束了，后面就不关我的事了</li>
</ul>
<p>成为解决问题的高手</p>
<ul>
<li>去解决问题，主动去解决，而不是等着团队分配，不挑容易的、喜欢的事</li>
<li>技术是为了解决问题，不为了技术而技术，不为了技术而造轮子，避免自嗨</li>
<li>去成为 owner，不仅仅是 coder - 每个角色要「边界清晰」（PM 出合理需求，RD、FE 高质量代码，QA 质量保障），更要「不设边界」，不要说「我觉得这是 xx 该做的」，可能确实是他该做的，But，我们是 one team，他没有 action，可以提醒他，可以跟他一起推进，我们的价值应该不仅仅是一个执行者 - Owner 感不是说我就是把代码写好了（我的极端看法：把代码写好是本质工作，并不是 owner 感的体现，owner 感体现在代码之外的事上）<br>提倡</li>
<li>「A：系统中有这么一个 bug，我们一起来配合优化下」「B：我来一起，对这个比较有兴趣」</li>
<li>主动承担起项目的 owner 角色，提前协调各方资源，同步风险，更大范围去寻找保证项目可以如期交付的办法</li>
<li>在做一个项目前，充分调研公司内部、开源方案，想清楚要解决的业务问题</li>
<li>你的方向有这个问题，是不是隔壁方向也可能会有 ？发起横向项目专项，一起系统化解决<br>反对</li>
<li>「B：我不想碰 A 写的代码，一坨屎。」，一年后，「C：我不想碰 B 写的代码，一坨屎。」</li>
<li>「A：系统中有这么一个 bug，我们一起来配合优化下」「B：嗨，C，不要跟 A 一起去合作，这个 bug 关我们什么事」</li>
<li>项目延期又不是我的问题，是 B delay 了，是 C 没有人力呀</li>
<li>「A：做这个项目是要解决什么业务问题啊？」「B: 不知道啊，我管它呢，我就觉得这个技术牛逼，就要做」</li>
<li>推动横向项目太麻烦了，累死个人，我就管我自己就好了<br>小故事分享</li>
<li>2 个小伙子被派去完成一个任务：去集市采购土豆</li>
<li>老板问小伙子 A：集市上有土豆吗？小伙子跑去集市看了以后回来说：有</li>
<li>老板又问：有多少家在卖？ 小伙子赶紧又跑回去看，回来说：有 10 家</li>
<li>老板又问：多少钱一斤？小伙子很委屈，你没有要我问价格呀，只好再跑去问</li>
<li>小伙子 B：看了市场上有多少土豆货源、价格、品质，市场需求，根据这些情况想好了如果批量采购，如何跟供应商谈价格，形成一个方案</li>
<li>预定酒店（纯属虚构）</li>
<li>公司需要预定当天某地酒店的一件朝南海景房，这个任务派给了同事 A</li>
<li>同事 A 马上打电话去酒店预定，但是发现这个酒店当天的海景房已经没有了，同事 A 向公司汇报了该情况，并询问是否可以换一个酒店或者不是海景房是否可以，在得到否定答案后，继续跟进</li>
<li>同事 A 向酒店打听了海景房被预定的情况，发现有一间海景房是被一对年轻情侣预定了，马上跟这对情侣联系，提出一个方案：这间海景房的钱由同事 A 补贴给他们，同时给他们定好另外一间非海景房。在成功预定到海景房后，跟公司汇报：海景房预定完成</li>
</ul>
<p>深挖本质，积极主动</p>
<ul>
<li>多问几个「为什么」，找到最根本的原因</li>
<li>多问几个「然后呢」，推演最深远的价值</li>
<li>主动发现问题，形成自己的理解和思考，提出想法，并推动落地<br>提倡<ul>
<li>「A: 服务有周期性报警，值班同学看下」「B：不需要管，框架的报错，它自己会好的」「A：为什么框架会报错呢？」「B: 服务端关闭链接了」「A：为什么服务端会偶发关闭链接？」</li>
<li>「产品：这个需求要做一下」「研发：这个需求要解决用户的什么问题啊？用户诉求强吗？需求很紧急吗？」</li>
<li>问题墙上的问题还没有人去解决，主动认领，钻研解决</li>
<li>团队安排的工作做完了，主动寻找有哪些优化工作可以做，跟团队沟通有哪些问题可以自己去解决<br>反对</li>
<li>「A: 服务有周期性报警，值班同学看下」「B：不需要管，瞬间波动，它自己会好的，不需要管」</li>
<li>有啥需求就做啥需求，管它重要不重要</li>
<li>又不是我的 bug，管我屁事，我需求做完了要下班的呀</li>
<li>排期多排一点真是好～</li>
</ul>
</li>
</ul>
<p>开放合作，持续精进</p>
<ul>
<li>多一些善意假设，少一些恶意揣测</li>
<li>乐观皮实，学习总结<ul>
<li>乐观：可以拓展为 坚韧的乐观，不会因为遇到一点困难、一点挫折就一蹶不振了。<ul>
<li>为什么我会遇到这种事 ？ ➡️ 这件事教会了我什么 ？</li>
</ul>
</li>
<li>皮实：不要玻璃心，说不得，不能接受任何建议，只希望听夸赞。 - 我们的工作不可能每件事都做的很成功很到位，不要想着我之前的事都做好了，就这件没做好，为什么要说我？ - 如果都不值得被说了，那是不是期望也不大了～ 最深的不爱，不是争吵，而是懒得吵<br>学习：学习是自己的事，团队只能给引导<br>总结：对某个需求质量的总结、对某次决策的总结、对过去一段时间自己表现的总结。并记录下来～<br>提倡</li>
<li>有误会，坦诚清晰的沟通，寻求合作和共同利益</li>
<li>新同事来了主动打招呼，一起吃饭，有困难主动帮助</li>
<li>善于思考、总结、沉淀，积极自省，并转化为下一步的提升计划</li>
<li>会对外输出最佳实践和技术积累，赋能团队的同时，也提升影响力<br>反对</li>
<li>「A 这个人不行，B 啥也不懂，我不想跟他们合作」</li>
<li>「他在群里这么说，不就是在针对我嘛」</li>
<li>他是 A 的实习生，关我什么事</li>
<li>玻璃心，接受不了团队/同事的建议</li>
<li>只埋头做需求，不总结、不沉淀、不输出、不提升</li>
<li>「我做的探索，为什么要告诉别人，他要用，自己研究去」</li>
</ul>
</li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>杂乱</tag>
      </tags>
  </entry>
  <entry>
    <title>首届hackathon的一些感想</title>
    <url>/hackathon/</url>
    <content><![CDATA[<div class=".article-gallery"><p>很开心我们团队能获得《最佳用户体验奖》。从零开始，全新的团队，30个小时出demo。</p>
<p><a href="https://imgtu.com/i/hBrcBd"><a href="https://z3.ax1x.com/2021/09/01/hBrcBd.jpg" title="hBrcBd.jpg" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/09/01/hBrcBd.jpg" alt="hBrcBd.jpg"></a></a></p>
<p>后续的一些想法，本身如果局限于旅行方面可能用户群里和内容生成有很大的局限性。</p>
<p>但是一些高度定制的行业，如教育，包括一些特殊产业，还是很有市场的，晚上团队聚餐的时候一起讨论下。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>杂乱</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress迁移Hexo</title>
    <url>/hello/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="搬新家了！"><a href="#搬新家了！" class="headerlink" title="搬新家了！"></a>搬<a href="http://kwaibook.com/">新家</a>了！</h1><p>在用了三年多 WordPress 后还是决定尝试下使用一些轻量的框架来搭建站点，比如 Hexo。<br>放弃 WordPress 主要出于以下几个方面的考虑吧：</p>
<ol>
<li>成本：需要单独的服务器部署。</li>
<li>效率：功能大而全，便利性方面还是很好的，但是敏捷性方面就稍显欠缺了，而 Hexo 支持 MD 语法，大大激活创作效率。</li>
<li>性能：网页加载图片的速度较慢。</li>
<li>美观：简洁才是王道</li>
<li>杀鸡用牛刀：在个人站点方面，静态的 Hexo 完全够了。</li>
</ol>
<span id="more"></span>

<p>站点搭建完了，现在的方案是，本地编写 MD 文件，提交 Github，Travis 自动发布。<br>皮肤：<a href="http://theme-next.iissnan.com/getting-started.html">next</a></p>
<p>皮肤: <a href="https://github.com/HiNinoJay/hexo-theme-A4">hexo-theme-A4</a></p>
<p>皮肤：<a href="https://butterfly.js.org/posts/ceeb73f/">butterfly</a></p>
<p>域名：</p>
<ul>
<li>github.io 在 DNS 中添加解析，见<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site</a></li>
</ul>
<p>后续需要的插件陆续添加吧。<br>主要参考的文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000021987832">Travis CI</a></li>
<li><del><a href="https://kchen.cc/2016/11/12/hexo-instructions/">Hexo 部署</a></del> (已经不免费)</li>
<li><a href="https://hexo.io/docs/github-pages">GithubActions CI</a></li>
</ul>
<h1 id="常用笔记"><a href="#常用笔记" class="headerlink" title="常用笔记"></a>常用笔记</h1><ol>
<li>新建博文：hexo new post $title</li>
<li>新建草稿：hexo new draft $title</li>
<li>文章目录：source_posts</li>
<li>图片目录：source\images</li>
<li><a href="https://typora.io/">https://typora.io/</a> markdown 工具</li>
<li><a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 语法</a></li>
<li><a href="http://blog.smallerpig.com/set-hexo-show-more-button-on-indexpage.html">参考链接</a></li>
<li><a href="https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/">参考链接</a></li>
<li><a href="https://huyongfei.com/posts/2324b80c.html">met 皮肤</a></li>
</ol>
<h1 id="hexo-博客插入图片与视频方法"><a href="#hexo-博客插入图片与视频方法" class="headerlink" title="hexo 博客插入图片与视频方法"></a>hexo 博客插入图片与视频方法</h1><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用。</p>
<h3 id="本地引用–绝对路径"><a href="#本地引用–绝对路径" class="headerlink" title="本地引用–绝对路径"></a>本地引用–绝对路径</h3><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 markdown 语法访问它们。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source/images/image.jpg</span><br><span class="line"></span><br><span class="line">![(可以写关于图片的描述)](/images/image.jpg)</span><br></pre></td></tr></table></figure>

<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>
<h3 id="本地引用–相对路径"><a href="#本地引用–相对路径" class="headerlink" title="本地引用–相对路径"></a>本地引用–相对路径</h3><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml 来生成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"></span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>将_config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令$ hexo new post_name，在 source/_posts 中会生成<br>文章 post_name.md 和同名文件夹 post_name。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_posts/post_name/image.jpg</span><br><span class="line"></span><br><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>

<p>上述是 markdown 的引用方式，图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_posts/post_name/image.jpg</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p><a href="https://picx.xpoet.cn/#/?jump=0">PicX在线</a><br>Upic(Mac)<br>PicGo(Windows)</p>
<h3 id="视频插入"><a href="#视频插入" class="headerlink" title="视频插入"></a>视频插入</h3><p>插入视频与图片不同，这里以 b 站的视频为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;（视频网址）&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;100%&quot;  height=&quot;580&quot; quality=&quot;high&quot; &gt; &lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p>这样直接插入的代码手机端不能自适应，效果不完美。<br><strong>最好这样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe</span><br><span class="line">src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot;</span><br><span class="line">frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%;</span><br><span class="line">height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li><p>Travis CI 发布失败</p>
<p>2022 年 07 月发现 github 提交后，网站没有自动更新成功。登录 Travis CI 后发现 CI 失败，如下图：</p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2022-07/20220727124915-rDXndx.jpg" title="20220727124915-rDXndx" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2022-07/20220727124915-rDXndx.jpg" alt="20220727124915-rDXndx"></a></p>
</li>
</ol>
<p>​ 原因是 node 版本问题，修改项目根目录下的<code>.travis.yml</code>文件中的 node_js 版本，原来是<code>stable</code>改为<code>lts</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">lts/*</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自动发版不生效<br>使用手动发版：</li>
</ol>
<ul>
<li>命令执行先 <code>hexo g</code> 生成</li>
<li>再执行 <code>hexo d</code> 发布</li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA HTTPS服务</title>
    <url>/https/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="分自签证书和CA证书两种方式。"><a href="#分自签证书和CA证书两种方式。" class="headerlink" title="分自签证书和CA证书两种方式。"></a>分自签证书和CA证书两种方式。</h2><h1 id="一、制作一张自签证书（jks格式）"><a href="#一、制作一张自签证书（jks格式）" class="headerlink" title="一、制作一张自签证书（jks格式）"></a>一、制作一张自签证书（jks格式）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#keytool -genkey -keysize 2048 -validity 3650 -keyalg RSA -dname &quot;CN=myyiba.com&quot; -keypass 123456 -storepass 123456 -keystore myyiba.jks</span><br></pre></td></tr></table></figure>

<p>keytool为JDK提供的生成证书工具</p>
<ul>
<li>-keysize 2048 密钥长度2048位（这个长度的密钥目前可认为无法被暴力破解）</li>
<li>-validity 3650 证书有效期3650天</li>
<li>-keyalg RSA 使用RSA非对称加密算法</li>
<li>-dname “CN=myyiba.com” 设置Common Name为myyiba.com，这是我的域名</li>
<li>-keypass 123456 密钥的访问密码为123456</li>
<li>-storepass 123456 密钥库的访问密码为123456（其实这两个密码也可以设置一样，通常都设置一样，方便记）</li>
<li>-keystore myyiba.jks 指定生成的密钥库文件为 myyiba .jks</li>
</ul>
<p>完了之后就拿到了myyiba.jks这个密钥库文件了，把它放到自己的项目目录下，比如：/usr/local/server/project/resource/myyiba.jks</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目示例：github下HttpServerInitializer</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="在程序初始化的时候生成SSLContext"><a href="#在程序初始化的时候生成SSLContext" class="headerlink" title="在程序初始化的时候生成SSLContext"></a>在程序初始化的时候生成SSLContext</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keyStore ks = KeyStore.getInstance(&quot;JKS&quot;);</span><br><span class="line">InputStream ksInputStream = new FileInputStream(&quot;/usr/local/server/project/resource/myyiba.jks&quot;);</span><br><span class="line">ks.load(ksInputStream, &quot;123456&quot;.toCharArray());</span><br><span class="line">keyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">kmf.init(ks, &quot;123456&quot;.toCharArray());</span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sslContext.init(kmf.getKeyManagers(), null, null);</span><br></pre></td></tr></table></figure>

<p>这个过程在整个程序周期只需要做一次，最好try-catch一下，以便检查异常，好了之后保存好sslContext，后面用到。</p>
<h1 id="在ChannelInitializer的initChannel中"><a href="#在ChannelInitializer的initChannel中" class="headerlink" title="在ChannelInitializer的initChannel中"></a>在ChannelInitializer的initChannel中</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">SSLEngine sslEngine = sslContext.createSSLEngine();</span><br><span class="line">sslEngine.setUseClientMode(false); //服务器端模式</span><br><span class="line">sslEngine.setNeedClientAuth(false); //不需要验证客户端</span><br><span class="line">socketChannel.pipeline().addLast(&quot;ssl&quot;, new SslHandler(sslEngine)); //搞定</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、CA证书"><a href="#二、CA证书" class="headerlink" title="二、CA证书"></a>二、CA证书</h1><p>例如微信小程序的服务器，需要CA证书的HTTPS服务，阿里云提供免费的SSL证书，申请证书后，下载tomcat版。解压有后两个文件：xxx.pfx和pfx-password.txt。</p>
<p><a href="https://imgtu.com/i/hBsD5q"><a href="https://z3.ax1x.com/2021/09/01/hBsD5q.md.png" title="hBsD5q.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/09/01/hBsD5q.md.png" alt="hBsD5q.md.png"></a></a></p>
<p>pfx文件类似上面的自签证书xxx.jks文件。加载证书的密码在<br>pfx-password.txt文件中。</p>
<p>同上面自签证书一样的方式加载CA证书SSL。项目地址见同一个GitHub项目。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>InfluxDB和Grafana搭建监控服务</title>
    <url>/influxdb-grafana/</url>
    <content><![CDATA[<div class=".article-gallery"><p>本篇为监控服务的环境搭建教程。</p>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p><a href="https://cloud.tencent.com/developer/article/1701451">安装教程</a></p>
<h4 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h4><p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/WX20211217-005210@2x-AlSghZ.png" title="WX20211217-005210@2x-AlSghZ" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/WX20211217-005210@2x-AlSghZ.png" alt="WX20211217-005210@2x-AlSghZ"></a></p>
<p>当前python环境为python3，修改/usr/bin/yum-config-manager使用的python版本为2即可。如下图</p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/WX20211217-005513@2x-8lyFc6.png" title="WX20211217-005513@2x-8lyFc6" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/WX20211217-005513@2x-8lyFc6.png" alt="WX20211217-005513@2x-8lyFc6"></a></p>
<h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p>下面一是service方式安装，二是docker方式安装，按需选择一种方式安装即可，<strong>推荐方式1</strong>。</p>
<ol>
<li><p><a href="https://docs.influxdata.com/influxdb/v2.1/install/?t=Linux#install-influxdb-as-a-service-with-systemd">Install InfluxDB as a service with systemd</a></p>
<p>我的是CentOS的系统，使用yum方式安装如下：</p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/20211220115000-i3NQOj.jpg" title="20211220115000-i3NQOj" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/20211220115000-i3NQOj.jpg" alt="20211220115000-i3NQOj"></a></p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/20211220115209-ElUVDl.jpg" title="20211220115209-ElUVDl" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/20211220115209-ElUVDl.jpg" alt="20211220115209-ElUVDl"></a></p>
<p>启动influxd：</p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/20211220115329-zLOFBX.jpg" title="20211220115329-zLOFBX" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/20211220115329-zLOFBX.jpg" alt="20211220115329-zLOFBX"></a></p>
</li>
<li><p>也可以选择<a href="https://docs.influxdata.com/influxdb/v2.1/install/?t=Docker">Docker方式安装</a></p>
</li>
</ol>
<h4 id="问题一：-1"><a href="#问题一：-1" class="headerlink" title="问题一："></a>问题一：</h4><p>如果服务器上已经使用yum安装了其他版本的influxDB，可以选择将旧版本卸载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -q influxdb</span><br><span class="line">rpm -e influxdb</span><br><span class="line">rpm -q influxdb</span><br></pre></td></tr></table></figure>



<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><ul>
<li><p>使用Grafana官网服务</p>
<ol>
<li><p><a href="https://grafana.com/grafana/">https://grafana.com/grafana/</a></p>
</li>
<li><p>创建自己的grafana cloud，如：<a href="https://zhangga.grafana.net/">https://zhangga.grafana.net/</a></p>
</li>
<li><p>配置数据源<a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds1-qTTC9g.jpg" title="ds1-qTTC9g" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds1-qTTC9g.jpg" alt="ds1-qTTC9g"></a></p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds2-3lfW1i.jpg" title="ds2-3lfW1i" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds2-3lfW1i.jpg" alt="ds2-3lfW1i"></a></p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds3-Ve1we7.jpg" title="ds3-Ve1we7" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds3-Ve1we7.jpg" alt="ds3-Ve1we7"></a></p>
</li>
<li><p>配置监控面板</p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds4-LUiCLt.jpg" title="ds4-LUiCLt" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/ds4-LUiCLt.jpg" alt="ds4-LUiCLt"></a></p>
</li>
</ol>
</li>
<li><p>云服务器安装Grafana</p>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1411555">安装指南</a>。</li>
<li>在腾讯云服务器(CentOS)上安装成功。</li>
<li>配置数据源同上。</li>
</ol>
</li>
</ul>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/WX20211217-002036@2x-x6aO5K.png" title="WX20211217-002036@2x-x6aO5K" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2021-12/WX20211217-002036@2x-x6aO5K.png" alt="WX20211217-002036@2x-x6aO5K"></a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA游戏服务器热更</title>
    <url>/java-hot/</url>
    <content><![CDATA[<div class=".article-gallery"><p>具体工程详见github:</p>
<p><a href="https://github.com/zhangga/HotswapJAVA.git">https://github.com/zhangga/HotswapJAVA.git</a></p>
<p>agentmain和premain方法都只能修改方法体。</p>
<p><a href="https://imgtu.com/i/hKvk5V"><a href="https://z3.ax1x.com/2021/08/27/hKvk5V.md.png" title="hKvk5V.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/27/hKvk5V.md.png" alt="hKvk5V.md.png"></a></a></p>
<p>jrebel可以热更类，新增、删除、修改等。</p>
<p>jrebel有eclipse和idea的插件，方便平时开发时，不用重启服务器。</p>
<p>破解版的插件在我的百度云盘里。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】 IO 多路复用</title>
    <url>/ionet/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="你管这破玩意叫-IO-多路复用？"><a href="#你管这破玩意叫-IO-多路复用？" class="headerlink" title="你管这破玩意叫 IO 多路复用？"></a>你管这破玩意叫 IO 多路复用？</h1><p>原创 闪客 <a href="javascript:void(0);">低并发编程</a> <em>2021-03-25 09:00</em></p>
<p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw">https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw</a></p>
<p>收录于合集</p>
<p>#破玩意儿25个</p>
<p>#网络4个</p>
<p>低并发编程</p>
<p>战略上藐视技术，战术上重视技术</p>
<p>为了讲多路复用，当然还是要跟风，采用鞭尸的思路，先讲讲传统的网络 IO 的弊端，用拉踩的方式捧起多路复用 IO 的优势。</p>
<p>为了方便理解，以下所有代码都是伪代码，知道其表达的意思即可。</p>
<p><strong>Let’s go</strong></p>
<h1 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a><strong>阻塞 IO</strong></h1><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listenfd = socket();   // 打开一个网络通信端口</span><br><span class="line">bind(listenfd);        // 绑定</span><br><span class="line">listen(listenfd);      // 监听</span><br><span class="line">while(1) &#123;</span><br><span class="line">  connfd = accept(listenfd);  // 阻塞建立连接</span><br><span class="line">  int n = read(connfd, buf);  // 阻塞读数据</span><br><span class="line">  doSomeThing(buf);  // 利用读到的数据做些什么</span><br><span class="line">  close(connfd);     // 关闭连接，循环等待下一个连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会执行得磕磕绊绊，就像这样。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zArJDictJLnnRWwXriaXkgJFXnUsibFTlxjqSaBicqpeH4NhXBCqWuFgc7VQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zArJDictJLnnRWwXriaXkgJFXnUsibFTlxjqSaBicqpeH4NhXBCqWuFgc7VQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zADM8nrhNkEtFpSpLjGicOemZ5mt7orYF8vFC7g83lPVDeSbnlgKl7XaA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zADM8nrhNkEtFpSpLjGicOemZ5mt7orYF8vFC7g83lPVDeSbnlgKl7XaA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAadgqoGRuEcAClAdesz7WTGhq6ugGbCKNiaghwqyAJJBC1GtVuYpkkmA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAadgqoGRuEcAClAdesz7WTGhq6ugGbCKNiaghwqyAJJBC1GtVuYpkkmA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></a></p>
<p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p>
<p>这肯定是不行的。</p>
<h1 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a><strong>非阻塞 IO</strong></h1><p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">  connfd = accept(listenfd);  // 阻塞建立连接</span><br><span class="line">  pthread_create（doWork);  // 创建一个新的线程</span><br><span class="line">&#125;</span><br><span class="line">void doWork() &#123;</span><br><span class="line">  int n = read(connfd, buf);  // 阻塞读数据</span><br><span class="line">  doSomeThing(buf);  // 利用读到的数据做些什么</span><br><span class="line">  close(connfd);     // 关闭连接，循环等待下一个连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA55fIbicSuYiad7vYdyLD0usibPibYiaAjBDR0gQPzArnzYlWXOZRyQzub3Q/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA55fIbicSuYiad7vYdyLD0usibPibYiaAjBDR0gQPzArnzYlWXOZRyQzub3Q/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p>
<p>所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，<strong>而是要恳请操作系统为我们提供一个非阻塞的 read 函数</strong>。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">int n = read(connfd, buffer) != SUCCESS);</span><br></pre></td></tr></table></figure>

<p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAT6rHhibbzK5rXiarLuJU0P4MGrHNl35vVCV4JdS4FeejOkl8bBGz9nVQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAT6rHhibbzK5rXiarLuJU0P4MGrHNl35vVCV4JdS4FeejOkl8bBGz9nVQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA4NCGPZZo9ydSiczrguMdwqFNvibGlzbaopiauFxTqrIa5po5faEAoY7HA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA4NCGPZZo9ydSiczrguMdwqFNvibGlzbaopiauFxTqrIa5po5faEAoY7HA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></a></p>
<h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a><strong>IO 多路复用</strong></h1><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAibNxnhFichNdFVYbbTYQ45AhMnzQm7MYRwg3gWUYNib9MKUDpuibHRINlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAibNxnhFichNdFVYbbTYQ45AhMnzQm7MYRwg3gWUYNib9MKUDpuibHRINlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></a></p>
<p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdlist.add(connfd);</span><br></pre></td></tr></table></figure>

<p>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">  for(fd &lt;-- fdlist) &#123;</span><br><span class="line">    if(read(fd) != -1) &#123;</span><br><span class="line">      doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就成功用一个线程处理了多个客户端连接。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zABlkKBoB04kDCApjketfzN9PWTwjwTng4ibWJTibCDmE3FsiaOTibAdaO3A/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zABlkKBoB04kDCApjketfzN9PWTwjwTng4ibWJTibCDmE3FsiaOTibAdaO3A/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>你是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h2><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>select系统调用的函数定义如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int select(</span><br><span class="line">    int nfds,</span><br><span class="line">    fd_set *readfds,</span><br><span class="line">    fd_set *writefds,</span><br><span class="line">    fd_set *exceptfds,</span><br><span class="line">    struct timeval *timeout);</span><br><span class="line">// nfds:监控的文件描述符集里最大文件描述符加1</span><br><span class="line">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span><br><span class="line">// writefds：监控写数据到达文件描述符集合，传入传出参数</span><br><span class="line">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span><br><span class="line">// timeout：定时阻塞监控时间，3种情况</span><br><span class="line">//  1.NULL，永远等下去</span><br><span class="line">//  2.设置timeval，等待固定时间</span><br><span class="line">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span><br></pre></td></tr></table></figure>

<p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">  connfd = accept(listenfd);</span><br><span class="line">  fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">  fdlist.add(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">  // 把一堆文件描述符 list 传给 select 函数</span><br><span class="line">  // 有已就绪的文件描述符就返回，nready 表示有多少个就绪的</span><br><span class="line">  nready = select(list);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">  nready = select(list);</span><br><span class="line">  // 用户层依然要遍历，只不过少了很多无效的系统调用</span><br><span class="line">  for(fd &lt;-- fdlist) &#123;</span><br><span class="line">    if(fd != -1) &#123;</span><br><span class="line">      // 只读已就绪的文件描述符</span><br><span class="line">      read(fd, buf);</span><br><span class="line">      // 总共只有 nready 个已就绪描述符，不用过多遍历</span><br><span class="line">      if(--nready == 0) break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如刚刚的动图中所描述的，其直观效果如下。（同一个动图消耗了你两次流量，气不气？）</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>可以看出几个细节：</p>
<p>\1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
<p>\2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
<p>\3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
<p>整个 select 的流程图如下。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAr5qibfgLBad0zoCEWXxdqC9I4v4mAYLR2SiafwtG4qOmdicHxa1Sx8MKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAr5qibfgLBad0zoCEWXxdqC9I4v4mAYLR2SiafwtG4qOmdicHxa1Sx8MKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></a></p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h2><p>poll 也是操作系统提供的系统调用函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_tnfds, int timeout);</span><br><span class="line"></span><br><span class="line">struct pollfd &#123;</span><br><span class="line">  intfd; /*文件描述符*/</span><br><span class="line">  shortevents; /*监控的事件*/</span><br><span class="line">  shortrevents; /*监控事件中满足条件返回的事件*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h2><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么？</p>
<p>\1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
<p>\2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
<p>\3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<p>\1. 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
<p>\2. 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
<p>\3. 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
<p>具体，操作系统提供了这三个函数。</p>
<p>第一步，创建一个 epoll 句柄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure>

<p>第二步，向内核添加、修改或删除要监控的文件描述符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int epoll_ctl(</span><br><span class="line">  int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>

<p>第三步，类似发起了 select() 调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int epoll_wait(</span><br><span class="line">  int epfd, struct epoll_event *events, int max events, int timeout);</span><br></pre></td></tr></table></figure>

<p>使用起来，其内部原理就像如下一般丝滑。</p>
<p><a href="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAjXNXJTV82eOqkbJdOrDpQpAaWiceBqvAXyFEOTdV5fC2dNsL29yBW7w/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" title="图片" class="gallery-item" style="box-shadow: none;"> <img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAjXNXJTV82eOqkbJdOrDpQpAaWiceBqvAXyFEOTdV5fC2dNsL29yBW7w/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></a></p>
<p>如果你想继续深入了解 epoll 的底层原理，推荐阅读飞哥的《<a href="http://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&chksm=a6e304d291948dc4fd7fe32498daaae715adb5f84ec761c31faf7a6310f4b595f95186647f12&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a>》，从 linux 源码级别，一行一行非常硬核地解读 epoll 的实现原理，且配有大量方便理解的图片，非常适合源码控的小伙伴阅读。</p>
<blockquote>
<blockquote>
<p><strong>后记</strong></p>
</blockquote>
</blockquote>
<p>大白话总结一下。</p>
<p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 <strong>阻塞 IO</strong>。</p>
<p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p>
<p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 <strong>非阻塞 IO</strong>。</p>
<p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p>
<p>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 <strong>IO 多路复用</strong>。</p>
<p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。</p>
<hr>
<p>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。</p>
<p>如果你建立了这样的思维，很容易发现网上的一些错误。</p>
<p>比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。</p>
<p>这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。</p>
<p>就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p>
<p>一个道理。</p>
<p>找时间我再专门写一篇，讲讲这块网络上鱼龙混杂的花式错误理解。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JVisualVM远程调试</title>
    <url>/jvm-remote/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="一、使用jstatd"><a href="#一、使用jstatd" class="headerlink" title="一、使用jstatd"></a>一、使用jstatd</h1><p>linux下使用 hostname -i  查看hostname对应的IP</p>
<p>确保远程连接使用的ip在列表里，不在的话jvisualvm无法使用ip远程连接。</p>
<p>不在的话vi /etc/hosts  在里面加入。</p>
<span id="more"></span>

<p>进入jdk的bin目录下：/usr/java/jdk1.8/bin/</p>
<p>新建文件jstatd.all.policy</p>
<p>写入内容：</p>
<p>grant codebase “file:${java.home}/../lib/tools.jar” {<br>permission java.security.AllPermission;<br>};</p>
<p>编写启动脚本：startJstatd.sh</p>
<p>#!/bin/bash<br>nohup $JAVA_HOME/bin/jstatd -J-Djava.rmi.server.hostname=172.16.200.82 -p 1099 -J-Djava.security.policy=jstatd.all.policy -J-Dcom.sun.management.jmxremote.authenticate=false -J-Dcom.sun.management.jmxremote.ssl=false -J-Dcom.sun.management.jmxremote.port=1199 &amp;</p>
<p>（-J-Djava.rmi.server.logCalls=true  参数能看到日志输出）</p>
<p>脚本里有jstatd 和 jmx的配置。只要jstatd的配置也OJBK。</p>
<p>确保linux的jstatd端口（默认1099）对外开放，然后使用jvisualvm远程连接即可。</p>
<h1 id="二、使用jmx"><a href="#二、使用jmx" class="headerlink" title="二、使用jmx"></a>二、使用jmx</h1><p>找到配置文件$JAVA_HOME/jre/lib/management/jmxremote.password.template,复制一份并改名为jmxremote.password,</p>
<p>使用chmod +w jmxremote.password  将文件加入写权限</p>
<p>然后打开jmxremote.passwrod，取消以下两行注释：</p>
<p>#monitorRole QED#controlRole R&amp;D monitorRole为用户名 QED为密码 执行：chmod 400 jmxremote.password指令。 JVM启动脚本加入启动参数：JAVA_PARAMS=”$JAVA_PARAMS -Djava.rmi.server.hostname=47.95.10.167 -Dcom.sun.management.jmxremote.port=1199 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true”（可以关闭验证也OJBK）</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手写JVM</title>
    <url>/jvm-self/</url>
    <content><![CDATA[<div class=".article-gallery"><p>根据《自己动手写Java虚拟机》一书</p>
<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/cover-300x179.png?resize=300,179" title="自己动手写JVM - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/cover-300x179.png?resize=300,179" alt="自己动手写JVM - 第1张  | 张嘎"></a></p>
<h2 id="实现的go代码在GitHub中：QJvm"><a href="#实现的go代码在GitHub中：QJvm" class="headerlink" title="实现的go代码在GitHub中：QJvm"></a>实现的go代码在GitHub中：<a href="https://github.com/zhangga/QJvm">QJvm</a></h2><h2 id="可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码"><a href="#可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码" class="headerlink" title="可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码"></a>可视化查看class文件的工具：<a href="https://github.com/zxh0/classpy">查看class工具</a>，启动类：ClasspyApp。书籍自身代码：<a href="https://github.com/zxh0/jvmgo-book">代码</a></h2> <span id="more"></span>

<h1 id="Class文件解析："><a href="#Class文件解析：" class="headerlink" title="Class文件解析："></a>Class文件解析：</h1><p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/22.png?resize=640,484" title="自己动手写JVM - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/22.png?resize=640,484" alt="自己动手写JVM - 第2张  | 张嘎"></a></p>
<p>如上图所示：</p>
<p>常量池解析：</p>
<p>1.读取16位的常量池大小cp_count。</p>
<p>2.索引从1到cp_count-1，依次读取常量信息。</p>
<p>3.常量信息有tag(8bit)表示常量类型。不同的类型读取数据方式不同。</p>
<p>// 常量池类型</p>
<p>const (</p>
<p>  CONSTANT_Class = 7</p>
<p>  CONSTANT_Fieldref = 9</p>
<p>  CONSTANT_Methodref = 10</p>
<p>  CONSTANT_InterfaceMethodref = 11</p>
<p>  CONSTANT_String = 8</p>
<p>  CONSTANT_Integer = 3</p>
<p>  CONSTANT_Float = 4</p>
<p>  CONSTANT_Long = 5</p>
<p>  CONSTANT_Double = 6</p>
<p>  CONSTANT_NameAndType = 12</p>
<p>  CONSTANT_Utf8 = 1</p>
<p>  CONSTANT_MethodHandle = 15</p>
<p>  CONSTANT_MethodType = 16</p>
<p>  CONSTANT_InvokeDynamic = 18</p>
<p>)</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/23.png?resize=640,490" title="自己动手写JVM - 第3张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/23.png?resize=640,490" alt="自己动手写JVM - 第3张  | 张嘎"></a></p>
<p>常量池类型可分为下面几大类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>具体代表类型</th>
<th>class存储格式</th>
</tr>
</thead>
<tbody><tr>
<td>numeric</td>
<td>数值型</td>
<td>int/float/double等</td>
<td>tag(8bit)+数值(具体类型决定)</td>
</tr>
<tr>
<td>string</td>
<td>指向字符串</td>
<td>string</td>
<td>tag(8bit)+指向utf8字符串的索引(16bit)</td>
</tr>
<tr>
<td>utf8</td>
<td>字符串</td>
<td>string</td>
<td>tag(8bit)+length(16b)+bytes(length)</td>
</tr>
<tr>
<td>class</td>
<td>类信息</td>
<td>class</td>
<td>tag(8bit)+指向utf8字符串的索引(16bit)</td>
</tr>
<tr>
<td>name&amp;type</td>
<td>名字和描述(参数)</td>
<td>字段、方法的名称和描述</td>
<td>tag(8bit)+指向name字符串索引(16bit)+指向描述字符串的索引(16bit)</td>
</tr>
<tr>
<td>member</td>
<td>成员信息</td>
<td>字段、方法、接口信息等</td>
<td>tag(8bit)+指向class索引(16bit)+指向name&amp;type的索引(16bit)</td>
</tr>
<tr>
<td>methodType</td>
<td>方法描述</td>
<td>方法</td>
<td>tag(8bit)+指向描述字符串的索引(16bit)</td>
</tr>
<tr>
<td>methodHandle</td>
<td>方法句柄</td>
<td>方法句柄</td>
<td>tag(8bit)+refKind(8b)+指向引用ref的索引(16b)</td>
</tr>
<tr>
<td>dynamic</td>
<td>动态调用</td>
<td>Lambda表达式</td>
<td>tag(8bit)+指定启动方法的索引(16b指向属性表)+指向name&amp;type的索引(16b)</td>
</tr>
</tbody></table>
<h1 id="动态调用：CONSTANT-InvokeDynamic-info"><a href="#动态调用：CONSTANT-InvokeDynamic-info" class="headerlink" title="动态调用：CONSTANT_InvokeDynamic_info"></a>动态调用：CONSTANT_InvokeDynamic_info</h1><p>为了更好的支持<a href="http://en.wikipedia.org/wiki/Dynamic_typing#DYNAMIC">动态类型语言</a>，<a href="https://www.baidu.com/s?wd=Java7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">Java7</a>通过<a href="https://jcp.org/en/jsr/detail?id=292">JSR292</a>给JVM增加了一条新的字节码指令：invokedynamic。Java8的Lambda表达式。</p>
<p>以下面代码为例：</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/24.png?resize=640,239" title="自己动手写JVM - 第4张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/24.png?resize=640,239" alt="自己动手写JVM - 第4张  | 张嘎"></a></p>
<p>使用javap -v -p指令反编译生成的class文件，找到main方法，可以看到生成了一条indy指令</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/25.png?resize=640,223" title="自己动手写JVM - 第5张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/25.png?resize=640,223" alt="自己动手写JVM - 第5张  | 张嘎"></a></p>
<p>指向常量池索引为#2，查看常量池可知，确实是一个CONSTANT_InvokeDynamic_info</p>
<p>CONSTANT_InvokeDynamic_info {</p>
<p>  u1 tag;</p>
<p>  u2 bootstrap_method_attr_index;</p>
<p>  u2 name_and_type_index;</p>
<p>}</p>
<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/26.png?resize=640,89" title="自己动手写JVM - 第6张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/26.png?resize=640,89" alt="自己动手写JVM - 第6张  | 张嘎"></a></p>
<p>可以看到有两个参数即我们上面表中总结的参数分别为：</p>
<p>指定启动方法的索引(16b指向属性表)+指向name&amp;type的索引(16b)</p>
<p>先看name&amp;type</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/35.png?resize=640,125" title="自己动手写JVM - 第7张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/35.png?resize=640,125" alt="自己动手写JVM - 第7张  | 张嘎"></a></p>
<p>它描述的是这样的一个方法：</p>
<p>Runnable run() {…}</p>
<p>再看bootstrap_method_attr_index</p>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21">JVM规范</a>规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定<strong>有且仅有一个</strong>BootstrapMethods属性。BootstrapMethods属性是个变长的表，结构如下所示：</p>
<p>BootstrapMethods_attribute {<br>u2 attribute_name_index;<br>u4 attribute_length;<br>u2 num_bootstrap_methods;<br>{   u2 bootstrap_method_ref;<br>u2 num_bootstrap_arguments;<br>u2 bootstrap_arguments[num_bootstrap_arguments];<br>} bootstrap_methods[num_bootstrap_methods];<br>}<br>每一个BootstrapMethod都包含一个bootstrap_method_ref和n个bootstrap_arguments。bootstrap_method_ref是个常量池索引，指向一个CONSTANT_MethodHandle_info。而每一个bootstrap_argument也都是常量池索引，可以指向下面这些结构：</p>
<ul>
<li>CONSTANT_String_info</li>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Integer_info</li>
<li>CONSTANT_Long_info</li>
<li>CONSTANT_Float_info</li>
<li>CONSTANT_Double_info</li>
<li>CONSTANT_MethodHandle_info</li>
<li>CONSTANT_MethodType_info</li>
</ul>
<p>本例中的启动方法反编译图：</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/28.png?resize=640,132" title="自己动手写JVM - 第8张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/28.png?resize=640,132" alt="自己动手写JVM - 第8张  | 张嘎"></a></p>
<p>确实存在一个BootstrapMethods表，这个表中只有一个BootstrapMethod，它的bootstrap_method_ref是常量池#23，有三个bootstrap_arguments，分别指向常量池#24，#25，#24：</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/30.png?resize=640,76" title="自己动手写JVM - 第9张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/30.png?resize=640,76" alt="自己动手写JVM - 第9张  | 张嘎"></a></p>
<h2 id="CONSTANT-MethodHandle-info"><a href="#CONSTANT-MethodHandle-info" class="headerlink" title="CONSTANT_MethodHandle_info"></a>CONSTANT_MethodHandle_info</h2><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8">CONSTANT_MethodHandle_info</a>结构包含两项信息，其结构参考上面表格。</p>
<p>reference_kind是一个1到9之间的整数，具体含义可以参考<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5">JVM规范</a>。reference_index是常量池索引，但具体索引的是什么类型的常量，需要看reference_kind：</p>
<table>
<thead>
<tr>
<th>constant_pool entry</th>
<th>reference_kind</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Fieldref_info</td>
<td>1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField), or 4 (REF_putStatic)</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial), or 8 (REF_newInvokeSpecial)</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>9 (REF_invokeInterface)</td>
</tr>
</tbody></table>
<p>通过观察常量池#23（上图中可以看到）可以看到，它的reference_kind是6（REF_invokeStatic），reference_index是#29，正好是个CONSTANT_Methodref_info：</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/32.png?resize=640,130" title="自己动手写JVM - 第10张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/32.png?resize=640,130" alt="自己动手写JVM - 第10张  | 张嘎"></a></p>
<p>引用的是java.lang.invoke.LambdaMetafactory类的静态方法metafactory()。</p>
<p>引用关系图：</p>
<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/33.png?resize=640,545" title="自己动手写JVM - 第11张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/33.png?resize=640,545" alt="自己动手写JVM - 第11张  | 张嘎"></a></p>
<p>JVM如何执行indy指令<br>前面从class文件的角度，分析了indy指令。下面让我们看看JVM是如何执行indy指令的。</p>
<ul>
<li>每一个indy指令出现的地方，都叫做一个dynamic call site（动态调用点）</li>
<li>根据indy指令的操作数，可以找到一个call site specifier（调用点说明符），根据前面的分析，这个说明符其实就常量池里的CONSTANT_InvokeDynamic_info</li>
<li>JVM解析（resolve）调用点说明符，得到下面三种信息：</li>
</ul>
<p>1.一个MethodHandle，指向<strong>bootstrap method</strong>（启动方法）</p>
<p>2.方法名和方法描述，表示动态调用的方法</p>
<p>3.其他提供给启动方法的参数</p>
<ul>
<li>接着JVM调用启动方法，并把上一步提到的信息通过参数传给启动方法</li>
<li>启动方法必须返回一个<strong>CallSite</strong>对象，并且，这个CallSite对象将永久和这个动态调用点关联</li>
<li>调用跟CallSite关联的MethodHandle指向的方法</li>
</ul>
<p>下面是一张示意图，画出了关键点：</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/31-1.png?resize=640,227" title="自己动手写JVM - 第12张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/31-1.png?resize=640,227" alt="自己动手写JVM - 第12张  | 张嘎"></a></p>
<p>接着回到我们上面的常量池解析，注意ConstantLongInfo和ConstantDoubleInfo在常量池占两个位置。至此常量池解析完成。</p>
<p>接着class文件中存放的是类访问标识。</p>
<p>然后是类，超类，接口信息。都是常量池索引。</p>
<p>然后字段表和方法表，这俩读取方式一样，以方法表为例：</p>
<p>1.读取16位的方法个数，member_count</p>
<p>2.依次读取member_count个方法信息：</p>
<p>访问标识(16bit)、名称索引(16bit指向常量池)、描述符索引(16bit指向常量池)、读取方法关联的属性表。</p>
<p>最后读取class文件的属性表Attributes。</p>
<p>1.读取16位的属性个数，attributes_count</p>
<p>2.依次读取attributes_count个属性信息：</p>
<p>属性名索引(指向常量池的UTF8)、属性长度(32bit)，</p>
<p>根据属性名和长度新建JVM实现的属性实例。</p>
<p>Java虚拟机规范预定义了23种属性，可分为三组。</p>
<p>一、Java虚拟机必须的，5种。</p>
<p>二、Java类库必须的，12种。</p>
<p>三、提供给工具使用的，6种。可选的。</p>
<p>例：Code、ConstantValue、Exceptions、LineNumberTable、LocalVariableTable、SourceFile、Synthetic等</p>
<p>至此class文件解析完成。</p>
<h1 id="线程启动："><a href="#线程启动：" class="headerlink" title="线程启动："></a>线程启动：</h1><p>从启动类中查找main方法。方法名：main、方法描述符：([Ljava/lang/String;)V</p>
<p>即：Void main(String[] xxx) {…}</p>
<p>解释并执行main方法。</p>
<p>线程Thread：</p>
<p>// 线程</p>
<p>type Thread struct {</p>
<p>  pc int</p>
<p>  stack *Stack  // 线程的帧栈</p>
<p>}</p>
<p>// jvm栈</p>
<p>type Stack struct {</p>
<p>  maxSize uint  // 最大大小</p>
<p>  size uint      // 当前大小</p>
<p>  _top *Frame  // 栈结构</p>
<p>}</p>
<p>// 帧</p>
<p>type Frame struct {</p>
<p>  lower *Frame  // 下一个帧，栈结构。</p>
<p>  localVars LocalVars // 局部变量表</p>
<p>  operandStack *OperandStack  // 操作数栈</p>
<p>  thread *Thread // 所属线程</p>
<p>  nextPC int // the next instruction after the call</p>
<p>}</p>
<p>根据main()方法的CodeAttribute(属性表，名称Code，存储方法执行的字节码信息)，获取其中的最大局部变量大小、最大操作数栈大小，新建Frame实例，将Frame实例压入当前线程的执行帧栈。</p>
<p>JVM会循环不停的从线程的帧栈中弹出帧Frame，执行Frame：</p>
<p>1.1获取frame要执行的指令编号NextPC</p>
<p>1.2将NextPC设置到thread的pc</p>
<p>2.1解码code，根据pc从CodeAttribute中的code(byte[]结构)解码</p>
<p>2.2先获取8bit操作指令，根据指令新建指令实例。</p>
<p>共分为11类：常量（constants）指令、加载（loads）指令、存储（stores）指令、<br>操作数栈（stack）指令、数学（math）指令、转换（conversions）指令、比<br>较（comparisons）指令、控制（control）指令、引用（references）指令、<br>扩展（extended）指令和保留（reserved）指令。</p>
<p>如：iconst_0，istore_1，iload_1，iinc{}，if_icmple，_goto，swap，i2b等。</p>
<p>2.3从属性表的code获取操作数，不同的指令具体实现。</p>
<p>如if_icmpeq指令，如果比较值相等则跳转，其中的跳转地址需要在方法属性表code中获取，读取code(byte[]结构)的下16位为跳转的偏移地址。</p>
<p>2.4设置frame的NextPC为code的pc，即记录code读取到哪个位置。</p>
<p>2.5执行指令实例，不同的指令具体实现。</p>
<p>如if_icmpeq指令，从帧的操作数栈中，弹出两个int值，比较两个值，如果相等，则设置帧frame的NextPC为 当前线程的pc + 偏移量（步骤2.3从code属性表中读取）。</p>
<p>重复1.1执行</p>
<p>上面是一个帧Frame完整的执行流程。</p>
<h3 id="上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。"><a href="#上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。" class="headerlink" title="上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。"></a><strong>上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。</strong></h3><h2 id="完整流程："><a href="#完整流程：" class="headerlink" title="完整流程："></a>完整流程：</h2><p>1.解析环境变量<br>2.类加载器<br>3.解析主类名<br>4.加载主类<br>加载类流程：内存中是否已加载该类，没有的话加载类<br>一、解析：<br>读取class文件字节码，解析<br>生成虚拟机可用的类数据，放入方法区。类数据：类基本信息、常量池、字段、方法、父类、接口、静态变量等信息。<br>加载类的时候会递归加载类的父类和接口。<br>二、链接：<br>1验证<br>2准备<br>计算实例字段的个数<br>计算静态字段的个数<br>分配并初始化静态变量，设置常量的值（字段信息里有常量指向的常量池的索引）</p>
<p>5.主类加载完成后，找到主入口方法main<br>6.解释执行main方法</p>
<h2 id="方法的调用过程："><a href="#方法的调用过程：" class="headerlink" title="方法的调用过程："></a>方法的调用过程：</h2><h2 id="invokeinterface-invokespecial-invokestatic-invokevirtual-1-创建帧（帧的主要组成是Method），将帧推入栈顶，-2-将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。-3-主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。-4-return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。"><a href="#invokeinterface-invokespecial-invokestatic-invokevirtual-1-创建帧（帧的主要组成是Method），将帧推入栈顶，-2-将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。-3-主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。-4-return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。" class="headerlink" title="invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。"></a>invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。</h2><p> 类初始化</p>
<h1 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h1><p>1.搜索class文件</p>
<p>1.hello world为例，加载前需要加载超类<strong>java.lang.Object</strong>，在调用main()方法前，虚拟机需要准备好参数数组，加载<strong>java.lang.String</strong>和<strong>java.lang.String[]<strong>，打印需要加载</strong>java.lang.System</strong>类。</p>
<p>2.类路径：启动类路径（bootstrap classpath）jre\lib、</p>
<p>扩展类路径（extension classpath） jre\lib\ext、</p>
<p>用户类路径（user classpath）-classpath或-cp指定，使用系统分隔符指定多个路径。</p>
<p>2.解析class文件</p>
<p>1.class文件的基本数据单位是字节，数据在class文件中以大端(big-endian)方式存储。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/KCP详解，及源码注解</title>
    <url>/kcp/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="KCP-Netty的中文注解版："><a href="#KCP-Netty的中文注解版：" class="headerlink" title="KCP-Netty的中文注解版："></a>KCP-Netty的中文注解版：</h1><p><a href="https://github.com/zhangga/kcp-netty">kcp-netty中文注释</a></p>
<h1 id="KCP-UDT比较："><a href="#KCP-UDT比较：" class="headerlink" title="KCP/UDT比较："></a>KCP/UDT比较：</h1><p><a href="https://github.com/libinzhangyuan/asio_kcp">kcp/udt</a></p>
<h1 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h1><p>传输层，可靠性，ARQ协议。</p>
<p>目的：解决在网络拥堵情况下tcp协议的网络速度慢的问题。可靠性，传输速度。</p>
<p>一般用udp作为下层传输协议，udp报文+控制头。</p>
<p>传输数据大于mss(最大报文段)时，kcp将数据分片存储在多个kcp包(Segment)中。</p>
<span id="more"></span>

<ol>
<li><ol>
<li><strong>滑动窗口机制：</strong>kcp采用滑动窗口机制来提高发送速度。由于UDP在网络中的传输是不可靠的，因此会出现丢包和包的乱序。kcp是可靠的保证数据有序的协议，所以为了纠正包的乱序。接收方维护一个接收窗口。接收窗口有一个起始序号rcv_nxt以及尾序号rcv_nxt+rcv_wnd。如果接收窗口收到序号为rcv_nxt的分片那么rcv_nxt就加一，形象一点的说法是滑动窗口右移,并把该数据放入接收队列供应用层取用。如果收到的数据在窗口范围内但不是rcv_nxt那么就把数据保存起来,等收到rcv_nxt序号的分片时再一并放入接收队列供应用层取用。</li>
</ol>
</li>
<li><p><strong>快速重传机制：</strong>数据在网络中的传输时间是不固定的，因此超时重传时间比较长。而为了尽早地判断出数据包的丢失，kcp引入了快速重传机制。快速重传机制工作原理是，当发送方发送了n,n+1,n+2…等等包出去后，接收方没有接收到n,而接收到n+1,n+2..等等n号包之后的包，这时因为n号包之后的包都已经接收到了，而n号包还没有接收到，所以可以认为n号包已经丢失了，告知发送方可以进行快速重传。kcp为了支持快速重传，接收方需要告诉发送方，哪些包已经成功收到了，哪些包没有收到。因此接收方返回发送方的确认数据（ack）中包含以下信息：接收窗口左端的序号rcv_nxt,接收到的大于rcv_nxt的包序号sn。rcv_nxt的含义是接收方已经成功按顺序接收了rcv_nxt序号之前的所有包,大于rcv_nxt的序号sn表示的是在接收窗口内的不连续的包。发送方接收到接收方发过来的数据时，首先解析rcv_nxt，把发送缓存中所有小于rcv_nxt序号的包全部移除掉（因为这些包全都都已经正确接收了）。然后再解析sn,遍历发送缓存，找到所有序号小于sn的包，这些包就是可能在网络中已经丢掉了的包,只是可能，因为有可能这些包只是拥堵在了网络中，需要更长的时间到达，所以这里我们设置一个快速重传的门限，对每个分片维护一个快速重传的计数，每收到一个ack解析sn后找到了一个分片，就把该分片的快速重传的计数加一，如果该计数达到了快速重传门限，那么就认为该分片已经丢失，可以触发快速重传，该门限值在kcp中可以设置，tcp中是3。</p>
</li>
<li><p><strong>选择重传机制：</strong>选择重传的关键在于接收方要告知发送方哪些包已经收到了，哪些包没有收到，为了最小化数据量，接收方可以告诉发送方哪些包已经按序收到了，哪些包是收到的但是不连续。所以返回的ack中包含rcv_nxt和sn。rcv_nxt代表收到的所有连续的包，sn代表哪些不连续的包收到了，那么根据这两个参数可以计算出来没有收到的包的序号。</p>
</li>
<li><p><strong>拥塞控制：</strong>拥塞控制就是告诉发送方，网络太堵了，应该少发一些数据，因此在滑动窗口的机制上引入了拥塞窗口，也就是说发送发发送的数据不得超过拥塞窗口，拥塞窗口的大小会随网络情况而变快，网络快拥塞窗口就大，反之同理。拥塞窗口的大小控制使用慢启动机制，具体参考TCP。</p>
</li>
</ol>
<p>应用：kcp采取一系列措施尽量提高网络传输速率，在网络实时性和可靠性要求比较高的场景下可以考虑kcp协议代替tcp协议。</p>
<p>名词说明（源码字段）：<br>用户数据：应用层发送的数据，如一张图片2Kb的数据<br>MTU：最大传输单元。即每次发送的最大数据<br>RTO：Retransmission TimeOut，重传超时时间。<br>cwnd:congestion window，拥塞窗口，表示发送方可发送多少个KCP数据包。与接收方窗口有关，与网络状况（拥塞控制）有关，与发送窗口大小有关。<br>rwnd:receiver window,接收方窗口大小，表示接收方还可接收多少个KCP数据包<br>snd_queue:待发送KCP数据包队列<br>snd_nxt:下一个即将发送的kcp数据包序列号<br>snd_una:下一个待确认的序列号</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1.png?resize=640,467" title="TCP/KCP详解，及源码注解 - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1.png?resize=640,467" alt="TCP/KCP详解，及源码注解 - 第1张  | 张嘎"></a></p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2.png?resize=640,351" title="TCP/KCP详解，及源码注解 - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2.png?resize=640,351" alt="TCP/KCP详解，及源码注解 - 第2张  | 张嘎"></a></p>
<p>[ KCP 发送过程 ]</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3.jpg?resize=485,296" title="TCP/KCP详解，及源码注解 - 第3张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3.jpg?resize=485,296" alt="TCP/KCP详解，及源码注解 - 第3张  | 张嘎"></a></p>
<p>[ RTO算法对比图 ]</p>
<p>KCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4.png?resize=365,353" title="TCP/KCP详解，及源码注解 - 第4张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4.png?resize=365,353" alt="TCP/KCP详解，及源码注解 - 第4张  | 张嘎"></a></p>
<p><strong>rcv_queue的数据是连续的，rcv_buf可能是间隔的</strong></p>
<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/5.png?resize=355,448" title="TCP/KCP详解，及源码注解 - 第5张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/5.png?resize=355,448" alt="TCP/KCP详解，及源码注解 - 第5张  | 张嘎"></a></p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/6.png?resize=466,424" title="TCP/KCP详解，及源码注解 - 第6张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/6.png?resize=466,424" alt="TCP/KCP详解，及源码注解 - 第6张  | 张嘎"></a></p>
<p>[ 数据确认包处理流程 ]</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/7.png?resize=574,403" title="TCP/KCP详解，及源码注解 - 第7张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/7.png?resize=574,403" alt="TCP/KCP详解，及源码注解 - 第7张  | 张嘎"></a></p>
<p>[ KCP快速确认 ]</p>
<p><strong>总结：TCP可靠简单，但是复杂无私，所以速度慢。KCP尽可能保留UDP快的特点下，保证可靠。</strong></p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/992994-20180616162318524-660296383.jpg?resize=640,323" title="TCP/KCP详解，及源码注解 - 第8张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/992994-20180616162318524-660296383.jpg?resize=640,323" alt="TCP/KCP详解，及源码注解 - 第8张  | 张嘎"></a></p>
<p>总结：UDP收到的包，不断通过kcp_input喂给KCP，KCP会对这部分数据（KCP协议数据）进行解包，重新封装成应用层用户数据，应用层通过kcp_recv获取。应用层通过kcp_send发送数据，KCP会把用户数据拆分kcp数据包，通过kcp_output，以UDP（send）的方式发送。</p>
<p><strong>KCP的配置模式</strong></p>
<p>\1. 工作模式：</p>
<blockquote>
<p>int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)</p>
</blockquote>
<ul>
<li>nodelay ：是否启用 nodelay模式，0不启用；1启用。</li>
<li>interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms</li>
<li>resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）</li>
<li>nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。</li>
</ul>
<p><strong>普通模式：</strong> ikcp_nodelay(kcp, 0, 40, 0, 0);</p>
<p><strong>极速模式：</strong> ikcp_nodelay(kcp, 1, 10, 2, 1)</p>
<p>\1. 最大窗口</p>
<blockquote>
<p>int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);</p>
</blockquote>
<p>该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。</p>
<p>\2. 最大传输单元：</p>
<p>纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。</p>
<p>\3. 最小RTO：</p>
<p>不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：<br>kcp-&gt;rx_minrto = 10;</p>
<p>KCP原理见：<a href="https://www.cnblogs.com/wetest/p/9190786.html">KCP原理</a></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>1.为流量设计（KB数据/秒），充分利用宽带。</p>
<p>2.安全可靠，丢包全部重传。</p>
<p>3.超时 = RTO * 2。</p>
<p>4.延迟ACK，充分利用宽带。</p>
<h4 id="UNA-vs-ACK-UNA："><a href="#UNA-vs-ACK-UNA：" class="headerlink" title="UNA vs ACK+UNA："></a>UNA vs ACK+UNA：</h4><p>ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到  ），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而  KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</p>
<h3 id="拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。"><a href="#拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。" class="headerlink" title="拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。"></a>拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。</h3><p><strong>慢开始算法</strong>：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p><a href="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120451114.jpg?resize=499,305" title="TCP/KCP详解，及源码注解 - 第9张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120451114.jpg?resize=499,305" alt="TCP/KCP详解，及源码注解 - 第9张  | 张嘎"></a></p>
<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>
<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>
<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120591634.jpg?resize=570,306" title="TCP/KCP详解，及源码注解 - 第10张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120591634.jpg?resize=570,306" alt="TCP/KCP详解，及源码注解 - 第10张  | 张嘎"></a></p>
<p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</p>
<p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。</p>
<p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。</p>
<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞。</strong></p>
<h3 id="快重传和快恢复算法："><a href="#快重传和快恢复算法：" class="headerlink" title="快重传和快恢复算法："></a>快重传和快恢复算法：</h3><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2010101122524670.jpg?resize=492,276" title="TCP/KCP详解，及源码注解 - 第11张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2010101122524670.jpg?resize=492,276" alt="TCP/KCP详解，及源码注解 - 第11张  | 张嘎"></a></p>
<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<p>&lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>
<p>&lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p>下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>
<p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101123101842.jpg?resize=621,313" title="TCP/KCP详解，及源码注解 - 第12张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101123101842.jpg?resize=621,313" alt="TCP/KCP详解，及源码注解 - 第12张  | 张嘎"></a></p>
<p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p>
<p>采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>
<p>接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。</p>
<p>发送方窗口的上限值 = Min [ rwnd, cwnd ]</p>
<p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>
<p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>服务流控方案总结</title>
    <url>/limiter/</url>
    <content><![CDATA[<div class=".article-gallery"><p>转载自：<a href="https://developer.aliyun.com/article/765912">https://developer.aliyun.com/article/765912</a></p>
<h3 id="一-流控的场景"><a href="#一-流控的场景" class="headerlink" title="一 流控的场景"></a>一 流控的场景</h3><p>流控的意义其实无需多言了。最常用的场景下，流控是为了保护下游有限的资源不被流量冲垮，保证服务的可用性，一般允许流控的阈值有一定的弹性，偶尔的超量访问是可以接受的。</p>
<p>有的时候，流控服务于收费模式，比如某些云厂商会对调用 API 的频次进行计费。既然涉及到钱，一般就不允许有超出阈值的调用量。</p>
<p>这些不同的场景下，适用的流控算法不尽相同。大多数情况下，使用 Sentinel 中间件已经能很好地应对，但 Sentinel 也并不是万能的，需要思考其他的流控方案。</p>
<span id="more"></span>

<h3 id="二-接口定义"><a href="#二-接口定义" class="headerlink" title="二 接口定义"></a>二 接口定义</h3><p>为了方便，以下所有的示例代码实现都是基于 Throttler 接口。</p>
<p>Throttler 接口定义了一个通用的方法用于申请单个配额。</p>
<p>当然你也可以定义一个 tryAcquire(String key, int permits) 签名的方法用于一次申请多个配额，实现的思路是一样的。</p>
<p>有些流控算法需要为每个 key 维护一个 Throttler 实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Throttler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 尝试申请一个配额</span><br><span class="line">     *</span><br><span class="line">     * @param key     申请配额的key</span><br><span class="line">     * @return 申请成功则返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    boolean tryAcquire(String key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-单机流控"><a href="#三-单机流控" class="headerlink" title="三 单机流控"></a>三 单机流控</h3><h4 id="1-简单窗口"><a href="#1-简单窗口" class="headerlink" title="1 简单窗口"></a>1 简单窗口</h4><blockquote>
<p>简单窗口是我自己的命名，有些地方也叫做固定窗口，主要是为了跟后面的滑动窗口区分。</p>
</blockquote>
<p>流控是为了限制指定时间间隔内能够允许的访问量，因此，最直观的思路就是基于一个给定的时间窗口，维护一个计数器用于统计访问次数，然后实现以下规则：</p>
<ul>
<li>如果访问次数小于阈值，则代表允许访问，访问次数 +1。</li>
<li>如果访问次数超出阈值，则限制访问，访问次数不增。</li>
<li>如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。这样就确保计数器统计的是最近一个窗口的访问量。</li>
</ul>
<p><strong>代码实现 SimpleWindowThrottler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 毫秒为单位的时间窗口</span><br><span class="line"> */</span><br><span class="line">private final long windowInMs;</span><br><span class="line">/**</span><br><span class="line"> * 时间窗口内最大允许的阈值</span><br><span class="line"> */</span><br><span class="line">private final int threshold;</span><br><span class="line">/**</span><br><span class="line"> * 最后一次成功请求时间</span><br><span class="line"> */</span><br><span class="line">private long lastReqTime = System.currentTimeMillis();</span><br><span class="line">/**</span><br><span class="line"> * 计数器</span><br><span class="line"> */</span><br><span class="line">private long counter;</span><br><span class="line"></span><br><span class="line">public boolean tryAcquire(String key) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    // 如果当前时间已经超过了上一次访问时间开始的时间窗口，重置计数器，以当前时间作为新窗口的起始值</span><br><span class="line">    if (now - lastReqTime &gt; windowInMs) &#123;       #1</span><br><span class="line">        counter = 0;</span><br><span class="line">        lastReqTime = now;                  #2</span><br><span class="line">    &#125;</span><br><span class="line">    if (counter &lt; threshold) &#123;                  #3</span><br><span class="line">        counter++;                          #4</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种常见的场景是根据不同的 key 来做流控，每个 key 有单独的时间窗口、阈值配置，因此需要为每个 key 维护一个单独的限流器实例。</p>
<p><strong>切换到多线程环境</strong><br>在现实应用中，往往是多个线程来同时申请配额，为了比较简洁地表达算法思路，示例代码里面都没有做并发同步控制。</p>
<p>以简单窗口的实现为例，要转换为多线程安全的流控算法，一种直接的办法是将 tryAcquire 方法设置为 synchronized。</p>
<p>当然一种感觉上更高效的办法也可以是修改读写变量的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private volatile long lastReqTime = System.currentTimeMillis();</span><br><span class="line">private LongAdder counter = new LongAdder();</span><br></pre></td></tr></table></figure>

<p>不过这样其实并不真正“安全”，设想以下的场景，两个线程 A、线程 B 前后脚尝试获取配额，#1 位置的判断条件满足后，会同时走到 #2 位置修改 lastReqTime 值，线程 B 的赋值会覆盖线程 A，导致时间窗口起始点向后偏移。同样的，位置 #3 和 #4 也会构成竞争条件。当然如果对流控的精度要求不高，这种竞争也是能接受的。</p>
<p><strong>临界突变问题</strong></p>
<p>简单窗口的流控实现非常简单，以 1 分钟允许 100 次访问为例，如果流量均匀保持 200 次/分钟的访问速率，系统的访问量曲线大概是这样的（按分钟清零）：</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/55c271e1437d49e2822a5f3114659474.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/55c271e1437d49e2822a5f3114659474.png" alt="image.png"></a></p>
<p>但如果流量并不均匀，假设在时间窗口开始时刻 0:00 有几次零星的访问，一直到 0:50 时刻，开始以 10 次/秒的速度请求，就会出现这样的访问量图线：</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/71496c33553043328fd24f9e6c58a352.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/71496c33553043328fd24f9e6c58a352.png" alt="image.png"></a></p>
<p>在临界的 20 秒内（0:50~1:10）系统承受的实际访问量是 200 次，换句话说，最坏的情况下，在窗口临界点附近系统会承受 2 倍的流量冲击，这就是简单窗口不能解决的临界突变问题。</p>
<h4 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2 滑动窗口"></a>2 滑动窗口</h4><p>如何解决简单窗口算法的临界突变问题？既然一个窗口统计的精度低，那么可以把整个大的时间窗口切分成更细粒度的子窗口，每个子窗口独立统计。同时，每过一个子窗口大小的时间，就向右滑动一个子窗口。这就是滑动窗口算法的思路。</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/64e7d74023a84b75a17fc320b152fa27.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/64e7d74023a84b75a17fc320b152fa27.png" alt="image.png"></a></p>
<p>如上图所示，将一分钟的时间窗口切分成 6 个子窗口，每个子窗口维护一个独立的计数器用于统计 10 秒内的访问量，每经过 10s，时间窗口向右滑动一格。</p>
<p>回到简单窗口出现临界跳变的例子，结合上面的图再看滑动窗口如何消除临界突变。如果 0:50 到 1:00 时刻（对应灰色的格子）进来了 100 次请求，接下来 1:00~1:10 的 100 次请求会落到黄色的格子中，由于算法统计的是 6 个子窗口的访问量总和，这时候总和超过设定的阈值 100，就会拒绝后面的这 100 次请求。</p>
<p><strong>代码实现（参考 Sentinel）</strong></p>
<p>Sentinel 提供了一个轻量高性能的滑动窗口流控算法实现，看代码的时候可以重点关注这几个类：</p>
<p>1）功能插槽 StatisticSlot 负责记录、统计不同纬度的 runtime 指标监控信息，例如 RT、QPS 等。</p>
<p>Sentinel 内部使用了 slot chain 的责任链设计模式，每个功能插槽 slot 有不同的功能（限流、降级、系统保护），通过 ProcessorSlotChain 串联在一起。</p>
<p>参考官方 Wiki：<br><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel%E5%B7%A5%E4%BD%9C%E4%B8%BB%E6%B5%81%E7%A8%8B">https://github.com/alibaba/Sentinel/wiki/Sentinel工作主流程</a></p>
<p>2）StatisticSlot 使用 StatisticNode#addPassRequest 记录允许的请求数，包含秒和分钟两个维度。</p>
<p>3）具体记录用到的是 Metric 接口，对应实现类 ArrayMetric，背后真正的滑动窗口数据结构是 LeapArray 。</p>
<p>4）LeapArray 内部维护了滑动窗口用到的关键属性和结构，包括：</p>
<p>a）总窗口大小 intervalInMs，滑动子窗口大小 windowLengthInMs，采样数量sampleCount：</p>
<p>sampleCount = intervalInMs / windowLengthInMs</p>
<p>当前实现默认为 2，而总窗口大小默认是 1s，也就意味着默认的滑动窗口大小是 500ms。可以通过调整采样数量来调整统计的精度。</p>
<p>b）滑动窗口的数组 array，数组中每个元素以 WindowWrap 表示，其中包含：</p>
<ul>
<li>windowStart：滑动窗口的开始时间。</li>
<li>windowLength：滑动窗口的长度。</li>
<li>value：滑动窗口记录的内容，泛型表示，关键的一类就是 MetricBucket，里面包含了一组 LongAdder 用于记录不同类型的数据，例如请求通过数、请求阻塞数、请求异常数等等。</li>
</ul>
<p>记录请求的逻辑说白了，就是根据当前时间获取所属的滑动窗口，然后将该窗口的统计值 +1 即可。但实际上，获取当前所属的时间窗口这一步隐含了不少细节，详细的实现可以从 LeapArray#currentWindow 中找到，源码的注释写得很详细，这里就不多提了。</p>
<p>这里借助一张其他同学画的图表述以上的流程：</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/94326f15088f4750acd811ec75b43252.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/94326f15088f4750acd811ec75b43252.png" alt="image.png"></a></p>
<p>以上的流程基于 3.9.21 版本的源码，早先版本的 Sentinel 内部版本实现不尽相同，使用了一个叫 SentinelRollingNumber 的数据结构，但原理是类似的。</p>
<p><strong>精度问题</strong></p>
<p>现在思考这么一个问题：滑动窗口算法能否精准地控制任意给定时间窗口 T 内的访问量不大于 N？</p>
<p>答案是否定的，还是将 1 分钟分成 6 个 10 秒大小的子窗口的例子，假设请求的速率现在是 20 次/秒，从 0:05 时刻开始进入，那么在 0:05<del>0:10 时间段内会放进 100 个请求，同时接下来的请求都会被限流，直到 1:00 时刻窗口滑动，在 1:00</del>1:05 时刻继续放进 100 个请求。如果把 0:05~1:05 看作是 1 分钟的时间窗口，那么这个窗口内实际的请求量是 200，超出了给定的阈值 100。</p>
<p>如果要追求更高的精度，理论上只需要把滑动窗口切分得更细。像 Sentinel 中就可以通过修改单位时间内的采样数量 sampleCount 值来设置精度，这个值一般根据业务的需求来定，以达到在精度和内存消耗之间的平衡。</p>
<p><strong>平滑度问题</strong></p>
<p>使用滑动窗口算法限制流量时，我们经常会看到像下面一样的流量曲线。</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/d80a395b5cb24ca59f2b97d4fb55893e.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/d80a395b5cb24ca59f2b97d4fb55893e.png" alt="image.png"></a></p>
<p>突发的大流量在窗口开始不久就直接把限流的阈值打满，导致剩余的窗口内所有请求都无法通过。在时间窗口的单位比较大时（例如以分为单位进行流控），这种问题的影响就比较大了。在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。</p>
<h4 id="3-漏桶"><a href="#3-漏桶" class="headerlink" title="3 漏桶"></a>3 漏桶</h4><p>滑动窗口无法很好地解决平滑度问题，再回过头看我们对于平滑度的诉求，当流量超过一定范围后，我们想要的效果不是一下子切断流量，而是将流量控制在系统能承受的一定的速度内。假设平均访问速率为 v, 那我们要做的流控其实是流速控制，即控制平均访问速率 v ≤ N / T。</p>
<p>在网络通信中常常用到漏桶算法来实现流量整形。漏桶算法的思路就是基于流速来做控制。想象一下上学时经常做的水池一边抽水一边注水的应用题，把水池换成水桶（还是底下有洞一注水就开始漏的那种），把请求看作是往桶里注水，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃的请求。在概念上类比：</p>
<ul>
<li>最大允许请求数 N：桶的大小</li>
<li>时间窗口大小 T：一整桶水漏完的时间</li>
<li>最大访问速率 V：一整桶水漏完的速度，即 N/T</li>
<li>请求被限流：桶注水的速度比漏水的速度快，最终导致桶内水溢出</li>
</ul>
<p>假设起始时刻桶是空的，每次访问都会往桶里注入一单位体积的水量，那么当我们以小于等于 N/T 的速度往桶里注水时，桶内的水就永远不会溢出。反之，一旦实际注水速度超过漏水速度，桶里就会产生越来越多的积水，直到溢出为止。同时漏水的速度永远被控制在 N/T 以内，这就实现了平滑流量的目的。</p>
<p>漏桶算法的访问速率曲线如下：<br><a href="https://ucc.alicdn.com/pic/developer-ecology/68127312b88a4bb3ac0b4a1caf297f6c.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/68127312b88a4bb3ac0b4a1caf297f6c.png" alt="image.png"></a></p>
<p>附上一张网上常见的漏桶算法原题图：</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/1299847fdcb042289fa10067ab074949.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/1299847fdcb042289fa10067ab074949.png" alt="image.png"></a></p>
<p><strong>代码实现 LeakyBucketThrottler</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当前桶内剩余的水</span><br><span class="line"> */</span><br><span class="line">private long left;</span><br><span class="line">/**</span><br><span class="line"> * 上次成功注水的时间戳</span><br><span class="line"> */</span><br><span class="line">private long lastInjectTime = System.currentTimeMillis();</span><br><span class="line">/**</span><br><span class="line"> * 桶的容量</span><br><span class="line"> */</span><br><span class="line">private long capacity;</span><br><span class="line">/**</span><br><span class="line"> * 一桶水漏完的时间</span><br><span class="line"> */</span><br><span class="line">private long duration;</span><br><span class="line">/**</span><br><span class="line"> * 桶漏水的速度，即 capacity / duration</span><br><span class="line"> */</span><br><span class="line">private double velocity;</span><br><span class="line"></span><br><span class="line">public boolean tryAcquire(String key) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    // 当前剩余的水 = 之前的剩余水量 - 过去这段时间内漏掉的水量</span><br><span class="line">    // 过去这段时间内漏掉的水量 = (当前时间-上次注水时间) * 漏水速度</span><br><span class="line">    // 如果当前时间相比上次注水时间相隔太久（一直没有注水），桶内的剩余水量就是0（漏完了）</span><br><span class="line">    left = Math.max(0, left - (long)((now - lastInjectTime) * velocity));</span><br><span class="line">    // 往当前水量基础上注一单位水，只要没有溢出就代表可以访问</span><br><span class="line">    if (left + 1 &lt;= capacity) &#123;</span><br><span class="line">        lastInjectTime = now;</span><br><span class="line">        left++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>漏桶的问题</strong></p>
<p>漏桶的优势在于能够平滑流量，如果流量不是均匀的，那么漏桶算法与滑动窗口算法一样无法做到真正的精确控制。极端情况下，漏桶在时间窗口 T 内也会放进相当于 2 倍阈值 N 的流量。</p>
<p>设想一下，如果访问量相比窗口大小 N 大很多，在窗口（0~T）一开始的 0 时刻就直接涌进来，使得漏桶在时间 t（ 0≈t</p>
<p>虽然可以通过限制桶大小的方式使得访问量控制在 N 以内，但这样做的副作用是流量在还未达到限制条件就被禁止。</p>
<p>还有一个隐含的约束是，漏桶漏水的速度最好是一个整数值（即容量 N 能够整除时间窗口大小 T ），否则在计算剩余水量时会有些许误差。</p>
<h4 id="4-令牌桶"><a href="#4-令牌桶" class="headerlink" title="4 令牌桶"></a>4 令牌桶</h4><p>漏桶模型中，请求来了是往桶里注水，如果反一下，把请求放行变成从桶里抽水，对应的，把注水看作是补充系统可承受流量的话，漏桶模型就变成了令牌桶模型。</p>
<p>理解漏桶之后，再看令牌桶就很简单了，抄一段令牌桶的原理：</p>
<blockquote>
<p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>
</blockquote>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/c17f0f04ac0642cd8764e477b0880e26.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/c17f0f04ac0642cd8764e477b0880e26.png" alt="image.png"></a></p>
<p><strong>代码实现 TokenBucketThrottler</strong></p>
<p>令牌桶与漏桶本质上是一样的，因此漏桶的代码稍微改下就可以变成令牌桶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long now = System.currentTimeMillis();</span><br><span class="line">left = Math.min(capacity, left + (long)((now - lastInjectTime) * velocity));</span><br><span class="line">if (left - 1 &gt; 0) &#123;</span><br><span class="line">    lastInjectTime = now;</span><br><span class="line">    left--;</span><br><span class="line">    return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产环境中使用令牌桶的话，可以考虑借助 Guava 中提供的 RateLimiter。它的实现是多线程安全的，调用 RateLimiter#acquire 时，如果剩余令牌不足，会阻塞线程一段时间直至有足够的可用令牌（而不是直接拒绝，这在某些场景下很有用）。除去默认的 SmoothBursty 策略外，RateLimiter 还提供了一种叫 SmoothWarmingUp 的策略，支持设置一个热身期，热身期内，RateLimiter 会平滑地将放令牌的速率加大，直致最大速率。设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存) 。RateLimiter 有一个缺点是只支持 QPS 级别。</p>
<p><strong>漏桶、令牌桶的区别</strong></p>
<p>虽然两者本质上只是反转了一下，不过在实际使用中，适用的场景稍有差别：</p>
<p>1）漏桶：用于控制网络中的速率。在该算法中，输入速率可以变化，但输出速率保持恒定。常常配合一个 FIFO 队列使用。</p>
<p>想象一下，漏桶的破洞是固定大小的，因此漏水的速率是可以保持恒定的。</p>
<p>2）令牌桶：按照固定速率往桶中添加令牌，允许输出速率根据突发大小而变化。</p>
<p>举个例子，一个系统限制 60 秒内的最大访问量是 60 次，换算速率是 1 次/秒，如果在一段时间内没有访问量，那么对漏桶而言此刻是空的。现在，一瞬间涌入 60 个请求，那么流量整形后，漏桶会以每秒 1 个请求的速度，花上 1 分钟将 60 个请求漏给下游。换成令牌桶的话，则是从令牌桶中一次性取走 60 个令牌，一下子塞给下游。</p>
<h4 id="5-滑动日志"><a href="#5-滑动日志" class="headerlink" title="5 滑动日志"></a>5 滑动日志</h4><p>一般情况下，上述的算法已经能很好地用于大部分实际应用场景了，很少有场景需要真正完全精确的控制（即任意给定时间窗口T内请求量不大于 N ）。如果要精确控制的话，我们需要记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。这就是滑动日志的算法思路。</p>
<p>设想某一个时刻 t 有一个请求，要判断是否允许，我们要看的其实是过去 t - N 时间段内是否有大于等于 N 个请求被放行，因此只要系统维护一个队列 q，里面记录每一个请求的时间，理论上就可以计算出从 t - N 时刻开始的请求数。</p>
<p>考虑到只需关心当前时间之前最长 T 时间内的记录，因此队列 q 的长度可以动态变化，并且队列中最多只记录 N 条访问，因此队列长度的最大值为 N。</p>
<blockquote>
<p>滑动日志与滑动窗口非常像，区别在于滑动日志的滑动是根据日志记录的时间做动态滑动，而滑动窗口是根据子窗口的大小，以子窗口维度滑动。</p>
</blockquote>
<p><strong>伪代码实现</strong></p>
<p>算法的伪代码表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化</span><br><span class="line">counter = 0</span><br><span class="line">q = []</span><br><span class="line"></span><br><span class="line"># 请求处理流程</span><br><span class="line"># 1.找到队列中第一个时间戳&gt;=t-T的请求，即以当前时间t截止的时间窗口T内的最早请求</span><br><span class="line">t = now</span><br><span class="line">start = findWindowStart(q, t)</span><br><span class="line"></span><br><span class="line"># 2.截断队列，只保留最近T时间窗口内的记录和计数值</span><br><span class="line">q = q[start, q.length - 1] </span><br><span class="line">counter -= start</span><br><span class="line"></span><br><span class="line"># 3.判断是否放行，如果允许放行则将这次请求加到队列 q 的末尾</span><br><span class="line">if counter &lt; threshold</span><br><span class="line">    push(q, t)</span><br><span class="line">    counter++</span><br><span class="line">    # 放行</span><br><span class="line">else</span><br><span class="line">    # 限流</span><br></pre></td></tr></table></figure>

<p>findWindowStart 的实现依赖于队列 q 使用的数据结构，以简单的数组为例，可以使用二分查找等方式。后面也会看到使用其他数据结构如何实现。</p>
<p>如果用数组实现，一个难点可能是如何截断一个队列，一种可行的思路是使用一组头尾指针 head 和 tail 分别指向数组中最近和最早的有效记录索引来解决， findWindowStart 的实现就变成在 tail 和 head 之间查找对应元素。</p>
<p><strong>复杂度问题</strong></p>
<p>虽然算法解决了精确度问题，但代价也是显而易见的。</p>
<p>首先，我们要保存一个长度最大为 N 的队列，这意味着空间复杂度达到 O(N)，如果要针对不同的 key 做流控，那么空间上会占用更多。当然，可以对不活跃 key 的队列进行复用来降低内存消耗。</p>
<p>其次，我们需要在队列中确定时间窗口，即通过 findWindowStart 方法寻找不早于当前时间戳 t - N 的请求记录。以二分查找为例，时间复杂度是 O(logN)。</p>
<h3 id="四-分布式流控"><a href="#四-分布式流控" class="headerlink" title="四 分布式流控"></a>四 分布式流控</h3><p>现实中的应用服务往往是分布式部署的，如果共用的资源（例如数据库）或者依赖的下游服务有流量限制，那么分布式流控就要派上用场了。</p>
<p>虽然可以给每台应用服务器平均分配流控配额，把问题转换为单机流控，但如果碰到流量不均匀、机器宕机、临时扩缩容等场景，这种做法的效果不佳。</p>
<p>分布式环境下做流控的核心算法思路其实与单机流控是一致的，区别在于需要实现一种同步机制来保证全局配额。同步机制的实现可以有中心化和去中心化两种思路：</p>
<p>1）中心化：配额由一个中心系统统一管控，应用进程通过向中心系统申请的方式获取流控配额。</p>
<ul>
<li>状态的一致性在中心系统维护，实现简单。</li>
<li>中心系统节点的不可用会导致流控出错，需要有额外的保护。例如，中心化流控在中心存储不可用时，往往会退化为单机流控。</li>
</ul>
<p>2）去中心化：应用进程独立保存和维护流控配额状态，集群内周期性异步通讯以保持状态一致。</p>
<ul>
<li>相比中心化方案，去中心化方案能够降低中心化单点可靠性带来的影响，但实现上比较复杂，状态的一致性难以保证。</li>
<li>在 CAP 中去中心化更加倾向于 A 而中心化更倾向于 C。</li>
</ul>
<p>去中心化方案在生产环境中没有见过，因此下文只讨论中心化流控的思路。</p>
<h4 id="1-接入层入口流控"><a href="#1-接入层入口流控" class="headerlink" title="1 接入层入口流控"></a>1 接入层入口流控</h4><p>应用接入的网络架构中，在应用服务器之前往往有一层 LVS 或 Nginx 做统一入口，可以在这一层做入口的流控。本质上这就是单机流控的场景。</p>
<p>以 Nginx 为例，Nginx 提供了 ngx_http_limit_req_module 模块用于流控，底层使用的是漏桶算法。</p>
<p>一个 Nginx 流控配置的示例如下，表示每个 IP 地址每秒只能请求 10 次 /login/ 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location /login/ &#123;</span><br><span class="line">        limit_req zone=mylimit;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://my_upstream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 的流控指令还支持更多配置，比如说配置 limit_req 指令时加上 burst 和 nodelay 参数来允许一定程度的突发，或者结合 geo 和 map 指令来实现黑白名单流控，具体可以参考 Nginx 官方文档：<br>Rate Limiting with NGINX and NGINX Plus（<a href="https://www.nginx.com/blog/rate-limiting-nginx/%EF%BC%89%E3%80%82">https://www.nginx.com/blog/rate-limiting-nginx/）。</a></p>
<p>如果自带的模块不能满足，那就上自定义的 lua 模块吧，参考 OpenResty 提供的 Lua 限流模块 lua-resty-limit-traffic。</p>
<h4 id="2-TokenServer-流控"><a href="#2-TokenServer-流控" class="headerlink" title="2 TokenServer 流控"></a>2 TokenServer 流控</h4><blockquote>
<p>这里借用了 Sentinel 中的 TokenServer 叫法，Sentinel 集群流控的介绍可以参考官方文档：Sentinel集群流控（<a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%EF%BC%89%E3%80%82">https://github.com/alibaba/Sentinel/wiki/集群流控）。</a></p>
</blockquote>
<p>这类流控的思路是找一个 TokenServer 来专门来管控流控配额，包括统计总调用量，判断单个请求是否允许等等，应用服务器作为客户端与 TokenServer 通信来获取配额。因为流控的逻辑在 TokenServer 内部统一处理，因此单机流控中讨论的算法同样适用。</p>
<p>很自然地能想到，这类流控非常依赖于 TokenServer 的性能和可用性。</p>
<p>性能方面，单点的 TokenServer 很容易成为瓶颈，查 Sentinel 源码，其中使用了 Netty 来做网络通信，数据包采用自定义格式，其他性能优化能找到的不多。</p>
<p>可用性方面，就像 Sentinel 官方文档中讲的，若在生产环境使用 TokenServer 集群限流，必须要解决以下问题：</p>
<p>Token Server 自动管理、调度（分配/选举 Token Server）</p>
<p>Token Server 高可用，在某个 Server 不可用时自动 failover 到其它机器</p>
<p>目前 Sentinel 的 TokenServer 默认并没有实现这些能力，需要定制或增加其他系统来实现，例如，采用一种分布式一致性协议来做集群选举，或者借助一组 monitor 来监控状态，实现成本还是挺高的。</p>
<h4 id="3-存储式流控"><a href="#3-存储式流控" class="headerlink" title="3 存储式流控"></a>3 存储式流控</h4><p>存储式流控的思想是通过一个存储系统来保存流控的计数值等统计信息，应用从存储中获取统计信息，然后将最新的请求信息再写入存储中。存储系统可以选择现成的 MySQL 数据库或者 Redis 缓存等，一般从性能出发选择缓存的比较多。这里选择 Tair 和 Redis 做例子。</p>
<p><strong>Tair 流控</strong></p>
<p>比较简单，直接上代码实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean tryAcquire(String key) &#123;</span><br><span class="line">  // 以秒为单位构建tair的key</span><br><span class="line">  String wrappedKey = wrapKey(key);</span><br><span class="line">  // 每次请求+1，初始值为0，key的有效期设置5s</span><br><span class="line">  Result&lt;Integer&gt; result = tairManager.incr(NAMESPACE, wrappedKey, 1, 0, 5);</span><br><span class="line">  return result.isSuccess() &amp;&amp; result.getValue() &lt;= threshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String wrapKey(String key) &#123;</span><br><span class="line">  long sec = System.currentTimeMillis() / 1000L;</span><br><span class="line">  return key + &quot;:&quot; + sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉太简单了点？得益于 Tair 的高性能，这种方式可以很好地支撑大流量。</p>
<p>这种 Tair 流控的方案实际上用的简单窗口的思路，每个 key 以每秒为一个时间窗口做 QPS 控制（QPM/QPD 原理类似）。关键在于用到了 Tair 的这个 API：</p>
<blockquote>
<p>incr</p>
</blockquote>
<p>Result incr(int namespace, Serializable key, int value, int defaultValue, int expireTime)<br>描述<br>增加计数。注意：incr 前不要 put！！<br>参数<br>namespace - 申请时分配的 namespace<br>key - key 列表，不超过 1k<br>value - 增加量<br>defaultValue - 第一次调用 incr 时的 key 的 count 初始值，第一次返回的值为 defaultValue + value。<br>expireTime - 数据过期时间，单位为秒，可设相对时间或绝对时间（Unix 时间戳）。expireTime = 0，表示数据永不过期。expireTime &gt; 0，表示设置过期时间。若 expireTime &gt; 当前时间的时间戳，则表示使用绝对时间，否则使用相对时间。expireTime &lt; 0，表示不关注过期时间，若之前设过过期时间，则已之前的过期时间为准，若没有，则作为永不过期处理，但当前 mdb 统一当做永不过期来处理。<br>返回值<br>Result 对象，返回值可为负值。当 key 不存在时，第一次返回 defaultValue+ value。后续的 incr 基于该值增加 value。</p>
<p>当然这种方式也有缺点：</p>
<ul>
<li>简单窗口的临界突变问题。</li>
<li>Tair 的可靠性问题，需要有降级方案。上面其实也说了，中心化的流控一般都需要搭配降级的单机流控。</li>
<li>集群机器的时间同步问题。由于生成 key 会用到集群机器的本地时间，因此要求机器时间必须是一致的。</li>
</ul>
<p>打个比方，不同机器时间稍微差个 10ms，在时间窗口的间隔点上的统计就会产生比较大的误差，比如说在同一时刻，一台机器时间是 0.990，一台是 1.000，两者调用 incr 时操作的 key 不一样，精度自然就会受影响。</p>
<p><strong>Redis 流控</strong></p>
<p>Redis 支持丰富的数据结构，性能也不错，其“单进程”模型方便同步控制，因此非常适合用来做分布式流控的存储。</p>
<p>1）简单窗口实现</p>
<p>使用 Redis 实现简单窗口流控的思路跟使用 Tair 是一致的。Redis 也提供了 INCR 命令用于计数，同时 Redis 的“单进程”模型也提供了很好的并发保护。Redis 的官方文档就写了如何使用 INCR 来实现 Rate Limiter，我这里稍作翻译了下：</p>
<blockquote>
<p>Redis INCR key(<a href="https://redis.io/commands/incr">https://redis.io/commands/incr</a>)</p>
</blockquote>
<p>以简单窗口为例，最简单直接的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">ts = CURRENT_UNIX_TIME()</span><br><span class="line">keyname = ip+&quot;:&quot;+ts</span><br><span class="line">current = GET(keyname)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    MULTI</span><br><span class="line">        INCR(keyname,1)</span><br><span class="line">        EXPIRE(keyname,10)</span><br><span class="line">    EXEC</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>实现上与上述的 Tair 类似，也是对每个 key 以秒为单位维护一个计数器，差别在于因为 Redis 没有提供原子的 INCR + EXPIRE 指令，所以在 INCR 之后需要再调用一次 EXPIRE 来设置 key 的有效期。同时在外层以 MULTI 和 EXEC 包裹以保证事务性。</p>
<p>如果不想每次都调用 EXPIRE，可以考虑第二种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip):</span><br><span class="line">current = GET(ip)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    value = INCR(ip)</span><br><span class="line">    IF value == 1 THEN</span><br><span class="line">        EXPIRE(ip,1)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>计数器的有效期在第一次 INCR 时设置为 1s，因此不需要对 key 进行额外处理。</p>
<p>不过需要注意的是，这种方式存在一种隐藏的竞争条件。如果客户端在第一次调用了 INCR 后，由于应用崩溃或其他原因没有调用 EXPIRE，计数器会一直存在。</p>
<p>针对方式二的这个问题，可以用 lua 脚本解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local current</span><br><span class="line">current = redis.call(&quot;incr&quot;,KEYS[1])</span><br><span class="line">if tonumber(current) == 1 then</span><br><span class="line">    redis.call(&quot;expire&quot;,KEYS[1],1)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>第三种方式是通过 Redis 的 list 结构来实现。更复杂一些但可以记录下每次的请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">current = LLEN(ip)</span><br><span class="line">IF current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    IF EXISTS(ip) == FALSE              #1</span><br><span class="line">        MULTI</span><br><span class="line">            RPUSH(ip,ip)</span><br><span class="line">            EXPIRE(ip,1)</span><br><span class="line">        EXEC</span><br><span class="line">    ELSE</span><br><span class="line">        RPUSHX(ip,ip)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>这里也有一个隐含的竞争条件，在执行到 EXIST 判断这一行（#1 位置）时，两个客户端的 EXIST 命令可能都会返回 false，因此 MULTI/EXEC 块里的命令会被执行两次，不过这种情况很少出现，不太会影响计数器的准确性。</p>
<p>上述的几种方式还可以进一步优化，因为 INCR 和 RPUSH 这些命令都会返回操作后的计数器值，所以可以使用 set-then-get 的方式获取计数器值。</p>
<p>将简单窗口改造成滑动窗口也是类似的思路，把单一的 key 换成一个 hash 结构，hash 里面为每个子窗口保存一个计数值，在统计时，将同个 hash 中所有子窗口的计数值相加即可。</p>
<p>2）令牌桶/漏桶实现</p>
<p>用 Redis 实现令牌桶或者漏桶也非常简单。以令牌桶为例，在实现上，可以用两个 key 分别存储每个用户的可用 token 数和上次请求时间，另一种可能更好的办法是使用 Redis 的 hash 数据结构。</p>
<p>下图的示例是一个用户 user_1 当前在 Redis 中保存的流控配额数据：令牌桶中当前剩余 2 个 token，最近一次访问的时间戳是 1490868000。</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/7a12af696eef4851ab16afb0d44426ea.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/7a12af696eef4851ab16afb0d44426ea.png" alt="image.png"></a></p>
<p>当收到一个新请求时，Redis 客户端要执行的操作与我们在单机流控算法中看到的一样。首先，从对应 hash 中获得当前配额数据（HGETALL），根据当前时间戳、上次请求的时间戳和 token 填充速度计算要填充的 token 数；然后，判断是否放行，更新新的时间戳和 token 数（HMSET）。</p>
<p>一个示例如下：</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/2e0a53670860429faca7b77337931117.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/2e0a53670860429faca7b77337931117.png" alt="image.png"></a></p>
<p>同样的，如果要求比较高的精度，这里必须要对客户端的操作做并发控制。</p>
<p>不做同步控制可能导致的问题示例：桶里只有一个 token，两个客户端同时请求时出现并发冲突，结果是请求都会放行。</p>
<p><a href="https://ucc.alicdn.com/pic/developer-ecology/c86cda7753e4469b8f517da77be5a4af.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/c86cda7753e4469b8f517da77be5a4af.png" alt="image.png"></a></p>
<p>lua 代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local tokens_key = KEYS[1]</span><br><span class="line">local timestamp_key = KEYS[2]</span><br><span class="line"></span><br><span class="line">local rate = tonumber(ARGV[1])</span><br><span class="line">local capacity = tonumber(ARGV[2])</span><br><span class="line">local now = tonumber(ARGV[3])</span><br><span class="line">local requested = tonumber(ARGV[4])</span><br><span class="line"></span><br><span class="line">local fill_time = capacity/rate</span><br><span class="line">local ttl = math.floor(fill_time*2)</span><br><span class="line"></span><br><span class="line">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span><br><span class="line">if last_tokens == nil then</span><br><span class="line">  last_tokens = capacity</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span><br><span class="line">if last_refreshed == nil then</span><br><span class="line">  last_refreshed = 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local delta = math.max(0, now-last_refreshed)</span><br><span class="line">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span><br><span class="line">local allowed = filled_tokens &gt;= requested</span><br><span class="line">local new_tokens = filled_tokens</span><br><span class="line">if allowed then</span><br><span class="line">  new_tokens = filled_tokens - requested</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span><br><span class="line">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span><br><span class="line"></span><br><span class="line">return &#123; allowed, new_tokens &#125;</span><br></pre></td></tr></table></figure>

<p>3）滑动日志实现</p>
<p>得益于 Redis 的 Sorted Set 结构，实现滑动日志变得异常简单。流程大致如下：</p>
<p>a）每个用户有一个对应的 Sorted Set 记录请求日志。</p>
<ul>
<li>其中每个元素的 key 和 value 可以是相同的，即请求的时间戳。</li>
<li>Sorted Set 可以根据时间窗口大小设置有效期，比如时间窗口为 1s 时设置过期时间 5s，在请求量不大时可以节省 Redis 服务器内存。</li>
</ul>
<p>b）当收到一个新的用户请求时，首先通过 ZREMRANGEBYSCORE 命令删除 Sorted Set 中过期的元素，这里的过期即：</p>
<p>请求时间戳 t &lt; 当前时间戳 now - 时间窗口大小 interval</p>
<p>c）使用 ZADD 将当前请求添加到 Set 中。</p>
<p>d）使用 ZCOUNT 获取当前剩余 Set 大小，判断是否需要流控。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long now = System.currentTimeMillis();</span><br><span class="line">long maxScoreMs = now - windowInSecond * 1000;</span><br><span class="line"></span><br><span class="line">Transaction redis = jedisPool.getResource().multi();</span><br><span class="line">redis.zremrangeByScore(key, 0, maxScoreMs);</span><br><span class="line">redis.zadd(key, now, now + &quot;-&quot; + Math.random()); // 加入一个随机值使得member不重复</span><br><span class="line">redis.expire(key, windowInSecond);</span><br><span class="line">redis.exec();</span><br></pre></td></tr></table></figure>

<p>另一个 JS 实现的代码示例：<br><a href="https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js">https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js</a></p>
<p>由于滑动日志算法的空间复杂度较其他算法高，使用滑动日志算法时，需要注意监控 Redis 内存的使用量。</p>
<p>4）并发控制</p>
<p>上面的几种算法都提到了不做并发控制可能带来的竞态条件，但额外的并发控制必然会带来性能下降，通常需要在精度和性能之间做取舍。Redis 流控的并发控制常见的有几类：</p>
<ul>
<li>使用 Redis 事务 MULTI/EXEC。</li>
<li>使用 RedLock（<a href="https://redis.io/topics/distlock%EF%BC%89">https://redis.io/topics/distlock）</a> 等分布式锁，要求每个客户端操作前先获取对应 key 的分布式锁。</li>
<li>Lua 脚本。</li>
</ul>
<p>最好通过性能测试来决定使用哪一种方式。</p>
<h4 id="4-扩展的一些思考"><a href="#4-扩展的一些思考" class="headerlink" title="4 扩展的一些思考"></a>4 扩展的一些思考</h4><p>分布式流控带来了网络通信、加锁同步等开销，会对性能带来一定影响。同时分布式环境的可靠性也会带来更多挑战。如何设计一个高性能、高可靠性的分布式流控系统？这可能是个涉及到整个系统方方面面的大话题。</p>
<p>分享一下个人的一些思考，欢迎讨论：</p>
<p>1）根据实际诉求，合理搭配不同层的多级流控是个不错的方式，尽量把流量拦在外层。例如常见的接口层 Nginx 流控 + 应用层流控。</p>
<p>2）选择一个合适的缓存系统保存流控的动态数据，这个一般跟着公司的统一技术架构走。</p>
<p>3）将流控的静态配置放到配置中心（例如 Diamond）。</p>
<p>4）设计时要考虑分布式流控不可用的情况（例如缓存挂掉），必要时切到单机流控，使用 Sentinel 成熟可靠。</p>
<p>5）很多时候对精度的要求没那么高，因为一般都会允许一定的突发量。这时候可以做一些性能的优化。性能的最大瓶颈在于每次请求都会访问一次缓存，我之前在设计时就采用了一种折中的办法：</p>
<ul>
<li>将可用配额的一部分，按一定比例（例如 50%），先预分配给集群内的机器。一般是平均分配，如果预先就已经知道每台机器的流量权重，可以加权分配。每台机器消耗配额的速率不同，中间也可能有机器宕机，可能有扩缩容，因此预分配的比例不宜太大，当然也不宜太小。</li>
<li>每台机器在配额耗尽时，向中心系统请求配额，这里的一个优化点是每台机器会记录自身配额消耗的速率（等同于承受的流量速率），按照速率大小申请不同大小的配额，消耗速率大则一次性申请更多。</li>
<li>在整体可用配额不足一定比例时（例如 10%），限制每台机器一次可申请的配额数，按剩余窗口大小计算发放配额的大小，并且每次发放量不超过剩余配额的一定比例（例如 50%），使得剩余的流量能够平滑地过渡。</li>
</ul>
<p>五 总结</p>
<p>分布式流控的算法其实是单机流控的延伸，算法本质是一样的。这里按我的个人理解总结了上述几种流控算法的复杂度和适用场景。<br><a href="https://ucc.alicdn.com/pic/developer-ecology/4ba212a1a7de40a6ba7601faa653b4d9.png" title="image.png" class="gallery-item" style="box-shadow: none;"> <img src="https://ucc.alicdn.com/pic/developer-ecology/4ba212a1a7de40a6ba7601faa653b4d9.png" alt="image.png"></a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/linux-note/</url>
    <content><![CDATA[<div class=".article-gallery"><h4 id="Linux查看物理CPU个数、核数、逻辑CPU个数"><a href="#Linux查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="Linux查看物理CPU个数、核数、逻辑CPU个数"></a>Linux查看物理CPU个数、核数、逻辑CPU个数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 总核数 = 物理CPU个数 X 每颗物理CPU的核数 </span><br><span class="line"># 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>

<h4 id="查看CPU信息（型号）"><a href="#查看CPU信息（型号）" class="headerlink" title="查看CPU信息（型号）"></a>查看CPU信息（型号）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure>

<h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<h4 id="如何查看Linux-内核"><a href="#如何查看Linux-内核" class="headerlink" title="如何查看Linux 内核"></a>如何查看Linux 内核</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>

<h4 id="查看机器型号（机器硬件型号）"><a href="#查看机器型号（机器硬件型号）" class="headerlink" title="查看机器型号（机器硬件型号）"></a>查看机器型号（机器硬件型号）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dmidecode | grep &quot;Product Name&quot;</span><br><span class="line">dmidecode</span><br></pre></td></tr></table></figure>

<h4 id="如何查看linux-系统版本"><a href="#如何查看linux-系统版本" class="headerlink" title="如何查看linux 系统版本"></a>如何查看linux 系统版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line">lsb_release -a</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>

<h4 id="如何查看linux系统和CPU型号，类型和大小"><a href="#如何查看linux系统和CPU型号，类型和大小" class="headerlink" title="如何查看linux系统和CPU型号，类型和大小"></a>如何查看linux系统和CPU型号，类型和大小</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br><span class="line"></span><br><span class="line">关于CPU的核心参数说明：</span><br><span class="line">· processor：指明第几个CPU处理器</span><br><span class="line">· cpu cores：指明每个处理器的核心数</span><br></pre></td></tr></table></figure>

<h4 id="如何查看linux-系统内存大小的信息，可以查看总内存，剩余内存，可使用内存等信息"><a href="#如何查看linux-系统内存大小的信息，可以查看总内存，剩余内存，可使用内存等信息" class="headerlink" title="如何查看linux 系统内存大小的信息，可以查看总内存，剩余内存，可使用内存等信息"></a>如何查看linux 系统内存大小的信息，可以查看总内存，剩余内存，可使用内存等信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<h4 id="使用taskset命令让进程运行在指定CPU上"><a href="#使用taskset命令让进程运行在指定CPU上" class="headerlink" title="使用taskset命令让进程运行在指定CPU上"></a>使用taskset命令让进程运行在指定CPU上</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令，指定进程运行在第一个CPU（CPU0）上。</span><br><span class="line">[root@VM_32_4_centos ~]# taskset -c 0 ./test.sh&amp;</span><br><span class="line"></span><br><span class="line">执行以下命令，获取进程状态（以下操作以进程test.sh为例，对应的pid为19155）</span><br><span class="line">[root@VM_32_4_centos ~]# ps aux|grep test.sh</span><br><span class="line">root     19155  0.0  0.0 113120  1204 pts/3    S+   15:26   0:00 /bin/bash ./test.sh</span><br><span class="line"></span><br><span class="line">执行以下命令，查看进程当前运行在哪个CPU上。</span><br><span class="line">[root@VM_32_4_centos ~]# taskset -p 19155</span><br><span class="line">pid 19155&#x27;s current affinity mask: 1</span><br></pre></td></tr></table></figure>

<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看防火墙开放端口</span><br><span class="line">[root@VM_32_4_centos ~]# firewall-cmd --list-ports</span><br><span class="line">5000/udp 80/tcp 5044/tcp 8080/tcp 9200/tcp 5043/tcp 9100/tcp 10050/tcp 5601/tcp 5000/tcp</span><br><span class="line"></span><br><span class="line">给防火墙添加3000端口</span><br><span class="line">[root@VM_32_4_centos ~]# firewall-cmd --add-port=3000/tcp --zone=public --permanent</span><br><span class="line">success</span><br><span class="line"></span><br><span class="line">端口生效</span><br><span class="line">[root@VM_32_4_centos ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h4 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h4><ol>
<li><p>使用<code>git checkout</code>撤销本地修改，仅限未<code>add/commit</code>的</p>
<p><code>git checkout .</code></p>
<p><code>git checkout [filename]</code></p>
<p><code>git checkout . &amp;&amp; git clean -xdf</code></p>
</li>
<li><p>使用<code>git reset</code>回退项目版本，可以回退掉已<code>add/commit</code>的</p>
<p><code>git reset --hard [commit-hashcode]</code></p>
</li>
<li><p>使用<code>git push origin master -f</code>推送到远端</p>
</li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>查看Linux下进程占用内存</title>
    <url>/linux-memory/</url>
    <content><![CDATA[<div class=".article-gallery"><p>近期计划针对 Linux 环境下DS（Dedicated Server）的性能展开测试，重点对比下面两种运行模式的表现：</p>
<ul>
<li>共享内存模式（基于Fork实现）</li>
<li>单进程多GameInstance模式</li>
</ul>
<p>在查看共享内存模式下进程占用的内存时，碰到一些疑问，这里整理记录下。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>下面是使用top查看内存占用的情况<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/lm-top.1hslrostgu.webp" title="top" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/lm-top.1hslrostgu.webp" alt="top"></a><br>发现父进程(st_seed_Camp)占用<strong>931m</strong>内存，同时各个子进程(st_Camp_2xxxx)占用<strong>771m</strong>内存。</p>
<p>上图还是Camp服务在启动后，没有玩家登入的情况下，内存占用的情况。很明显，771m不是子进程真正占用的情况。<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/lm-freem.45i221myz0.webp" title="freem" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/lm-freem.45i221myz0.webp" alt="freem"></a><br>要做性能测试，必须先能正确查看到各进程实际占用的内存才行。</p>
<h1 id="参数的实际含义"><a href="#参数的实际含义" class="headerlink" title="参数的实际含义"></a>参数的实际含义</h1><p>那top命令下看到的各值实际含义是什么呢？</p>
<h2 id="系统总体信息区"><a href="#系统总体信息区" class="headerlink" title="系统总体信息区"></a>系统总体信息区</h2><h4 id="第一行（系统状态）"><a href="#第一行（系统状态）" class="headerlink" title="第一行（系统状态）"></a>第一行（系统状态）</h4><p><code>top - 16:33:58 up 19 days,  1:41,  0 users,  load average: 0.02, 0.07, 0.08</code></p>
<ul>
<li><code>16:33:58</code> → 当前时间</li>
<li><code>up 19 days,  1:41</code> → 系统已运行时间</li>
<li><code>0 users</code> → 当前登录用户数量</li>
<li><code>load average</code> → 1分钟、5分钟、15分钟平均负载（接近或大于CPU核心数表示忙）</li>
</ul>
<h4 id="第二行（任务统计）"><a href="#第二行（任务统计）" class="headerlink" title="第二行（任务统计）"></a>第二行（任务统计）</h4><p><code>Tasks:  26 total,   1 running,  25 sleeping,   0 stopped,   0 zombie</code></p>
<ul>
<li>​<strong>total</strong>​：总进程数</li>
<li>​<strong>running</strong>​：正在运行（使用CPU）的进程数</li>
<li>​<strong>sleeping</strong>​：休眠中的进程</li>
<li>​<strong>stopped</strong>​：被停止（信号暂停）的进程</li>
<li>​<strong>zombie</strong>​：僵尸进程（已退出但父进程未回收）</li>
</ul>
<h4 id="第三行（CPU-使用情况）"><a href="#第三行（CPU-使用情况）" class="headerlink" title="第三行（CPU 使用情况）"></a>第三行（CPU 使用情况）</h4><p><code>%Cpu(s):  0.6 us,  0.6 sy,  0.0 ni, 98.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</code></p>
<p>👉 通常关注：</p>
<ul>
<li><strong>us</strong>​<strong>​ + sy ≈ 系统总 CPU 使用率</strong></li>
<li><strong>wa</strong> 高说明 I/O 瓶颈</li>
<li><strong>id</strong> 低说明 CPU 忙碌</li>
</ul>
<h4 id="第四、五行（内存统计）"><a href="#第四、五行（内存统计）" class="headerlink" title="第四、五行（内存统计）"></a>第四、五行（内存统计）</h4><p><code>MiB Mem :  15492.0 total,    414.3 free,   2578.1 used,  12499.6 buff/cache</code></p>
<p><code>MiB Swap:      0.0 total,      0.0 free,      0.0 used.  12502.4 avail Mem</code></p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>total</strong></td>
<td>内存总量</td>
</tr>
<tr>
<td><strong>free</strong></td>
<td>完全未分配的</td>
</tr>
<tr>
<td><strong>used</strong></td>
<td>已使用的（包含 cache）</td>
</tr>
<tr>
<td><strong>buff/cache</strong></td>
<td>系统缓存与文件缓冲区</td>
</tr>
<tr>
<td><strong>shared</strong></td>
<td>共享内存（tmpfs、shm）使用</td>
</tr>
<tr>
<td><strong>available</strong></td>
<td>实际可用内存（free + 可回收 cache），更准确</td>
</tr>
</tbody></table>
<p>如果 Swap 使用很多（used 很大），说明内存紧张。</p>
<p>⚠️ 常见误区：</p>
<blockquote>
<p>“free 很小是不是内存不够用了？”</p>
<p>❌ 错。Linux 会尽量利用空闲内存做缓存，提高性能。  真正可用内存是 ​<strong>available</strong>​。</p>
</blockquote>
<h2 id="进程信息区"><a href="#进程信息区" class="headerlink" title="进程信息区"></a>进程信息区</h2><p><code>PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</code></p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PID</strong></td>
<td>进程号（Process ID）</td>
</tr>
<tr>
<td><strong>USER</strong></td>
<td>启动该进程的用户</td>
</tr>
<tr>
<td><strong>PR</strong></td>
<td>优先级（Priority）数值越小优先级越高</td>
</tr>
<tr>
<td><strong>NI</strong></td>
<td>nice值（影响调度优先级，默认0）</td>
</tr>
<tr>
<td><strong>VIRT</strong></td>
<td>进程使用的虚拟内存总量（包含共享库、未实际分配的内存）</td>
</tr>
<tr>
<td><strong>RES</strong></td>
<td>常驻内存（Resident Set Size），即实际占用的物理内存，不含 swap</td>
</tr>
<tr>
<td><strong>SHR</strong></td>
<td>共享内存大小（共享库等）</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>进程状态：<code>R</code>=运行、<code>S</code>=睡眠、<code>D</code>=不可中断睡眠、<code>T</code>=停止、<code>Z</code>=僵尸</td>
</tr>
<tr>
<td><strong>%CPU</strong></td>
<td>CPU 占用百分比（多核系统可超过100）</td>
</tr>
<tr>
<td><strong>%MEM</strong></td>
<td>占物理内存百分比</td>
</tr>
<tr>
<td>​<strong>TIME</strong>​**+**</td>
<td>进程累计占用 CPU 的时间（user + sys）</td>
</tr>
<tr>
<td><strong>COMMAND</strong></td>
<td>可执行文件或命令名称</td>
</tr>
</tbody></table>
<h4 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h4><blockquote>
<p><strong>​RES 是进程当前驻留在物理内存（​</strong>​​<strong>RAM</strong>​​<strong>）中的总字节数</strong>​。 它表示该进程的页表中，有多少页真正加载在内存中（没有被 swap 出去）。</p>
</blockquote>
<p><strong>RES</strong> 实际上是这三类内存的总和：</p>
<table>
<thead>
<tr>
<th><strong>内存类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>私有匿名页（Private Anonymous）</strong></td>
<td>比如堆（malloc/new）、栈、临时分配内存</td>
</tr>
<tr>
<td><strong>私有文件映射页（Private File）</strong></td>
<td>比如只被该进程使用的 mmap 文件</td>
</tr>
<tr>
<td><strong>共享页（Shared Pages）</strong></td>
<td>比如共享库、fork 后 copy-on-write 未触发的页、shm/tmpfs</td>
</tr>
</tbody></table>
<p>即：</p>
<p><strong><code>RES = 私有内存 + 共享内存</code></strong></p>
<h1 id="查看进程私有内存"><a href="#查看进程私有内存" class="headerlink" title="查看进程私有内存"></a>查看进程私有内存</h1><p>使用下面命令，可以查看更详细的内存占用</p>
<p><code>cat /proc/&lt;pid&gt;/smaps_rollup</code></p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Rss</strong></td>
<td>Resident Set Size，进程实际驻留在物理内存中的总大小（包括共享内存）</td>
</tr>
<tr>
<td><strong>Pss</strong></td>
<td>Proportional Set Size，分摊共享页后的真实占用</td>
</tr>
<tr>
<td><strong>Shared_Clean</strong></td>
<td>被多个进程共享、且未被修改的页面（通常是映射的可执行文件、动态库（如<code>.so</code>文件）、或只读共享内存）</td>
</tr>
<tr>
<td><strong>Shared_Dirty</strong></td>
<td>被多个进程共享、且已修改的页面（通常是共享内存（<code>shm</code>）、<code>mmap</code>写映射文件、或 copy-on-write 前的父子共享页）</td>
</tr>
<tr>
<td><strong>Private_Clean</strong></td>
<td>当前进程独占、但未修改（clean）的页面</td>
</tr>
<tr>
<td><strong>Private_Dirty</strong></td>
<td>当前进程独占、且被修改过（dirty）的页面（堆、栈、写时复制 (COW) 页、mmap 写映射）</td>
</tr>
</tbody></table>
<ul>
<li>几个关键指标的关系</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Rss</span> = <span class="title class_">Private</span>_Clean + <span class="title class_">Private</span>_Dirty + <span class="title class_">Shared</span>_Clean + <span class="title class_">Shared</span>_Dirty</span><br><span class="line"><span class="title class_">Private</span> = <span class="title class_">Private</span>_Clean + <span class="title class_">Private</span>_Dirty</span><br><span class="line"><span class="title class_">Shared</span>  = <span class="title class_">Shared</span>_Clean + <span class="title class_">Shared</span>_Dirty</span><br></pre></td></tr></table></figure>

<p>所以：</p>
<ul>
<li>​<strong>USS</strong>​<strong>（独占内存） = Private = Private_Clean + Private_Dirty</strong></li>
<li><strong>PSS</strong>​<strong>​ = Private + (Shared / N)</strong> （N = 共享者数量）</li>
<li><strong>RSS = Private + Shared</strong></li>
</ul>
<h2 id="以上面进程为例实际计算下"><a href="#以上面进程为例实际计算下" class="headerlink" title="以上面进程为例实际计算下"></a>以上面进程为例实际计算下</h2><h3 id="PID-17（父）"><a href="#PID-17（父）" class="headerlink" title="PID 17（父）"></a>PID 17（父）</h3><p><a href="https://github.com/zhangga/picx-images-hosting/raw/master/lm-parent.9ddcp1w7po.webp" title="parent" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/lm-parent.9ddcp1w7po.webp" alt="parent"></a></p>
<ul>
<li><strong>RSS</strong> = 954,200 kB ≈ <strong>932.6 ​</strong>​<strong>MB</strong></li>
<li><strong>PSS</strong> = 249,097 kB ≈ <strong>243.4 ​</strong>​<strong>MB</strong>  ← 每个映射到的进程分摊后的“真实占用”</li>
<li><strong>​Private (​</strong>​​<strong>USS</strong>​**)** = Private_Clean + Private_Dirty = 88,256 + 125,528 = <strong>213,784 kB ≈ 208.8 ​</strong>​<strong>MB</strong> ← 父进程独占的内存</li>
<li><strong>Shared total</strong> = Shared_Clean + Shared_Dirty = 70,124 + 670,292 = <strong>740,416 kB ≈ 722.9 MB</strong></li>
<li><strong>分摊的共享内存</strong> = 722.9 MB / 21（父进程+20个子进程） = <strong>34.4 MB</strong></li>
<li>​<strong>验证</strong>​：PSS(243.4) = Private(208.8) + 分摊的共享内存(34.4)</li>
</ul>
<h3 id="PID-20（子）"><a href="#PID-20（子）" class="headerlink" title="PID 20（子）"></a>PID 20（子）</h3><p><a href="https://github.com/zhangga/picx-images-hosting/raw/master/lm-child.8l0h7bfh3k.webp" title="child" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/lm-child.8l0h7bfh3k.webp" alt="child"></a></p>
<ul>
<li><strong>RSS</strong> = 790,216 kB ≈ <strong>771.8 ​</strong>​<strong>MB</strong></li>
<li><strong>PSS</strong> = 85,198 kB ≈ <strong>83.2 ​</strong>​<strong>MB</strong></li>
<li><strong>​Private (​</strong>​​<strong>USS</strong>​**)** = 0 + 49,952 = <strong>49,952 kB ≈ 48.8 ​</strong>​<strong>MB</strong></li>
<li><strong>Shared total</strong> = 69,976 + 670,288 = <strong>740,264 kB ≈ 722.8 MB</strong></li>
</ul>
<h3 id="非Fork下"><a href="#非Fork下" class="headerlink" title="非Fork下"></a>非Fork下</h3><p>Private的值占比会非常高（共享很少）<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/lm-nofork.175ryjadc1.webp" title="nonfork" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/lm-nofork.175ryjadc1.webp" alt="nonfork"></a></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>父进程 fork 子进程时，Linux 不会立即复制内存页，而是：</p>
<ul>
<li>父子共享同一份物理页；</li>
<li>这些页都标记为只读；</li>
<li>当任意一方写入时，触发 Copy-on-Write (​<strong>COW</strong>​)，内核才复制出新的页。</li>
</ul>
<p>因此刚 fork 完时：</p>
<ul>
<li>父子几乎完全共享；</li>
<li>Private 很小，Shared 很大；</li>
<li>RSS 大但 PSS 较小（因为共享页分摊了）。</li>
</ul>
<h1 id="COW-后的变化趋势"><a href="#COW-后的变化趋势" class="headerlink" title="COW 后的变化趋势"></a>COW 后的变化趋势</h1><p>随着运行时间增加、数据写入增多，各进程会对内存页发生 COW。来看几个指标的变化趋势：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>含义</th>
<th>COW 后变化趋势</th>
<th>原因解释</th>
</tr>
</thead>
<tbody><tr>
<td>Private_Dirty</td>
<td>私有的、已被修改的匿名页</td>
<td>🔺 上升</td>
<td>写操作导致复制页，新页标记为 dirty。</td>
</tr>
<tr>
<td>Shared_Clean / Shared_Dirty</td>
<td>可共享的页（未写入）</td>
<td>🔻 下降</td>
<td>原本共享的页被分裂成私有副本后不再共享。</td>
</tr>
<tr>
<td>RSS</td>
<td>实际驻留物理内存总量（Shared + Private）</td>
<td>🔺 上升</td>
<td>每个进程都多了自己独有的副本，物理占用上升。</td>
</tr>
<tr>
<td>USS (Private_Clean + Private_Dirty)</td>
<td>独占的页（别的进程不共享）</td>
<td>🔺 上升</td>
<td>表示每个进程独占的内存越来越多。</td>
</tr>
<tr>
<td>PSS</td>
<td>平均分摊的真实占用</td>
<td>🔺 上升缓慢</td>
<td>因为每个进程获得更多独占页（PSS≈USS+共享页/N），共享比例减少。</td>
</tr>
<tr>
<td>共享总量 (Shared_Clean + Shared_Dirty)</td>
<td>各进程共同映射的物理页</td>
<td>🔻 下降明显</td>
<td>页逐渐不再被多个进程共享。</td>
</tr>
<tr>
<td>总系统内存使用量</td>
<td>所有进程 RSS 的并集</td>
<td>🔺 显著上升</td>
<td>因为同一页被多次复制后，物理上变成多份。</td>
</tr>
</tbody></table>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>模型微调</title>
    <url>/llm-lora/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="训练大模型的三个阶段"><a href="#训练大模型的三个阶段" class="headerlink" title="训练大模型的三个阶段"></a>训练大模型的三个阶段</h2><ul>
<li>预训练：学说话</li>
<li>微调：学根据指令回答</li>
<li>偏好对齐：学会按照人类偏好回答</li>
</ul>
<h2 id="增量预训练"><a href="#增量预训练" class="headerlink" title="增量预训练"></a>增量预训练</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>更新知识</li>
<li>修改常识性错误</li>
<li>扩充领域知识</li>
<li>……</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>比如把知识从去年扩充到今年</li>
<li>比如训练一个小说家小说家</li>
<li>比如他对某个历史人物记忆有错误</li>
</ul>
<h2 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>回答特定领域问题</li>
<li>完成特定任务</li>
<li>个性化需求，比方当我让他用某种特殊方式回答某个特定问题</li>
<li>……</li>
</ul>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul>
<li>医疗客服</li>
<li>金融咨询</li>
<li>角色扮演</li>
</ul>
<h2 id="微调目标分类"><a href="#微调目标分类" class="headerlink" title="微调目标分类"></a>微调目标分类</h2><ul>
<li>指令微调 （总结、情感分析）</li>
<li>领域微调( 金融类问题回答、医疗类问题回答)</li>
<li>多任务微调</li>
<li>知识蒸馏（老师模型微调学生模型）</li>
<li>工具调用</li>
<li>……</li>
</ul>
<h2 id="微调的两个主要类型"><a href="#微调的两个主要类型" class="headerlink" title="微调的两个主要类型"></a>微调的两个主要类型</h2><ol>
<li>监督微调（Supervised Fine-tuning）：监督微调是指在进行微调时使用有标签的训练数据集。这些标签提供了模型在微调过程中的目标输出。在监督微调中，通常使用带有标签的任务特定数据集，例如分类任务的数据集，其中每个样本都有一个与之关联的标签。通过使用这些标签来指导模型的微调，可以使模型更好地适应特定任务。</li>
<li>无监督微调（Unsupervised Fine-tuning）：无监督微调是指在进行微调时使用无标签的训练数据集。这意味着在微调过程中，模型只能利用输入数据本身的信息，而没有明确的目标输出。这些方法通过学习数据的内在结构或生成数据来进行微调，以提取有用的特征或改进模型的表示能力。</li>
</ol>
<h2 id="微调方法"><a href="#微调方法" class="headerlink" title="微调方法"></a>微调方法</h2><ul>
<li>Lora微调</li>
<li>全参数微调</li>
<li>冻结部分参数微调</li>
</ul>
<h2 id="Lora微调"><a href="#Lora微调" class="headerlink" title="Lora微调"></a>Lora微调</h2><h3 id="什么是Lora"><a href="#什么是Lora" class="headerlink" title="什么是Lora"></a>什么是Lora</h3><p>Low Rank Adapter</p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2024-11/lora1-6ZPzRm.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2024-11/lora1-6ZPzRm.png" alt="img"></a></p>
<p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2024-11/lora2-AxMP25.png" title="lora2-AxMP25" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2024-11/lora2-AxMP25.png" alt="lora2-AxMP25"></a></p>
<h3 id="Lora微调的优势"><a href="#Lora微调的优势" class="headerlink" title="Lora微调的优势"></a>Lora微调的优势</h3><ol>
<li><strong>效率高</strong>：只需更新低秩适应层，而不是整个模型，更快、更高效地对大型语言模型进行微调。</li>
<li><strong>节省资源</strong>：降低微调过程的复杂性，节省计算资源、能源和时间。</li>
<li><strong><a href="https://ai-bot.cn/what-is-lora/">灵活性：适用于各种大规模语言模型，易于适应不同的任务或领域</a></strong></li>
</ol>
<h2 id="语言模型微调过程"><a href="#语言模型微调过程" class="headerlink" title="语言模型微调过程"></a>语言模型微调过程</h2><ol>
<li>确定训练目标</li>
<li>选择合适的基座模型 (Base、Instrcution、Chat、Code、MOE、Toolcall、VLM)，参数量</li>
<li>选择微调框架 推荐用 <a href="https://github.com/hiyouga/LLaMA-Factory">https://github.com/hiyouga/LLaMA-Factory</a></li>
<li>准备微调数据<ol>
<li>找合适的数据源（自有数据\爬虫\huggingface\github\wiki\kaggle\modelscope）</li>
<li>数据清洗（过滤、去重、脱敏）</li>
<li>数据处理<ul>
<li>数据增强</li>
<li>合成数据</li>
<li>数据格式（text，instrcution，conversation）</li>
</ul>
</li>
</ol>
</li>
<li>确定微调参数，开始微调</li>
<li>观察loss变化</li>
<li>模型评估</li>
<li>合并模型，将Lora参数和Base模型参数合并导出</li>
<li>模型量化（可选）</li>
</ol>
<h2 id="部署推理服务"><a href="#部署推理服务" class="headerlink" title="部署推理服务"></a>部署推理服务</h2><p>推理框架</p>
<ol>
<li>Transformers</li>
<li>vllm </li>
<li>Ollama</li>
<li>Xinference</li>
<li>onnx</li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装LLVM和CLANG</title>
    <url>/llvm-clang/</url>
    <content><![CDATA[<div class=".article-gallery"><p>在 CentOS 上安装 LLVM Clang 的过程如下:</p>
<ol>
<li>首先，确保系统已经更新并安装了必要的编译工具，如gcc和make，可以通过执行以下命令完成:</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install gcc <span class="built_in">make</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>下载LLVM和Clang的源码包。可以在LLVM官网下载最新版本的源码包，或者使用以下命令下载:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://releases.llvm.org/&lt;version&gt;/llvm-&lt;version&gt;.src.tar.xz</span><br><span class="line">wget http://releases.llvm.org/&lt;version&gt;/cfe-&lt;version&gt;.src.tar.xz</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>解压源码包并进入目录:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">tar xf llvm-<span class="tag">&lt;<span class="name">version</span>&gt;</span>.src.tar.xz</span><br><span class="line">tar xf cfe-<span class="tag">&lt;<span class="name">version</span>&gt;</span>.src.tar.xz</span><br><span class="line">mv cfe-<span class="tag">&lt;<span class="name">version</span>&gt;</span>.src llvm-<span class="tag">&lt;<span class="name">version</span>&gt;</span>.src/tools/clang</span><br><span class="line">cd llvm-<span class="tag">&lt;<span class="name">version</span>&gt;</span>.src</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>使用以下命令来配置、编译和安装LLVM和Clang:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> ../</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>编译完成后，可以使用 clang 和 llvm-config 命令来检查安装是否成功。</li>
</ol>
<p>注意: 上述的请替换成你要安装的版本号，如llvm-11.0.0</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>给lua函数添加调用时长限制</title>
    <url>/lua-settime/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>战斗验证服务会调用客户端同学写的lua函数，lua写出了死循环导致内存飙升最终OOM</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>用lua的debug.sethook方法加调用钩子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 设置一个时间限制钩子</span><br><span class="line"><span class="keyword">function</span> set_time_limit(seconds)</span><br><span class="line">    <span class="built_in">local</span> start = os.clock()</span><br><span class="line">    debug.sethook(<span class="keyword">function</span>()</span><br><span class="line">        <span class="keyword">if</span> os.clock() - start &gt;= seconds <span class="keyword">then</span></span><br><span class="line">            debug.sethook() -- 移除钩子</span><br><span class="line">            error(<span class="string">&quot;Time limit exceeded&quot;</span>) -- 终止执行</span><br><span class="line">        end</span><br><span class="line">    end, <span class="string">&quot;&quot;</span>, 1e7) -- 第三个参数是钩子的调用频率，这里是每执行大约1000万条指令检查一次</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用手册</title>
    <url>/mac-manual/</url>
    <content><![CDATA[<div class=".article-gallery"><h3 id="Mac新手使用指南"><a href="#Mac新手使用指南" class="headerlink" title="Mac新手使用指南"></a><a href="https://post.smzdm.com/p/679153/">Mac新手使用指南</a></h3><h1 id="MAC环境安装"><a href="#MAC环境安装" class="headerlink" title="MAC环境安装"></a>MAC环境安装</h1><ol>
<li><strong>iTerm2安装</strong></li>
</ol>
<p><a href="https://iterm2.com/">https://iterm2.com/</a></p>
<ol start="2">
<li><strong>brew安装</strong></li>
</ol>
<p><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></p>
<p>将以上命令粘贴至终端。参考：<a href="https://brew.sh/index_zh-cn">https://brew.sh/index_zh-cn</a></p>
<span id="more"></span>

<ol start="3">
<li><strong>golang环境安装</strong></li>
</ol>
<p>安装golang最新版。</p>
<p><code>brew install go</code></p>
<p>查看版本：</p>
<p><code>go version</code></p>
<p>配置golang环境变量：</p>
<p>打开 ~/.bash_profile 文件，没有的话新建，在最后输入</p>
<p><code>export GOPATH=Go 开发包的默认安装目录如：/usr/local/go</code></p>
<p><code>export GOBIN=$GOPATH/bin</code></p>
<p><code>export PATH=$PATH:$GOBIN</code></p>
<p><code>source  ~/.bash_profile</code> 文件，使之生效</p>
<p>zsh的配置文件为：~/.zshrc</p>
<p>多版本共存和切换：</p>
<p><a href="https://www.jianshu.com/p/363e4d39e694">https://www.jianshu.com/p/363e4d39e694</a></p>
<ol start="4">
<li><strong>goland安装</strong></li>
</ol>
<p>官网下载最新版：<a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a></p>
<p>按照下面文档中<strong>在线安装方式</strong>，安装goland无限试用插件：</p>
<p><a href="https://cloud.tencent.com/developer/article/1822218">https://cloud.tencent.com/developer/article/1822218</a></p>
<ol start="5">
<li><strong>GitLab sshkey</strong></li>
</ol>
<p>安装git：</p>
<p><code>brew install git</code></p>
<p>安装步骤生成ssh key：</p>
<p><a href="https://www.jianshu.com/p/253ca7c2e80c">https://www.jianshu.com/p/253ca7c2e80c</a></p>
<p>将ssh key添加到gitlab中：</p>
<p>如下图所示：</p>
<p><a href="https://i.loli.net/2021/11/02/gJaKmOF4U6WVLhA.png" title="gJaKmOF4U6WVLhA" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2021/11/02/gJaKmOF4U6WVLhA.png" alt="gJaKmOF4U6WVLhA"></a></p>
<ol start="6">
<li><strong>Docker安装</strong></li>
</ol>
<p><code>brew install --cask --appdir=/Applications docker</code></p>
<ol start="7">
<li><strong>svn安装</strong></li>
</ol>
<p>svn client命令行安装：</p>
<p><code>brew install svn</code></p>
<p>mac也可选择Cornerstone。</p>
<ol start="8">
<li><strong>MongoDB安装</strong></li>
</ol>
<p><code>brew tap mongodb/brew</code></p>
<p><code>brew install mongodb-community@4.4</code></p>
<p>配置mongo bin的PATH</p>
<p>在~/.bash_profile中追加PATH</p>
<p><code>export MONGO_BIN=/usr/local/opt/mongodb-community@4.4/bin</code></p>
<p><code>export PATH=$PATH:$MONGO_BIN:.</code></p>
<ol start="9">
<li><strong>golua环境</strong></li>
</ol>
<ul>
<li><strong>首先安装lua环境：</strong></li>
</ul>
<p><a href="http://www.lua.org/download.html">官网</a>下载最新版 lua-5.4.3.tar.gz</p>
<p>解压下载的压缩包，运行终端，进入解压后的文件夹</p>
<p>执行命令 <code>make macosx</code></p>
<p>执行命令 <code>make test</code></p>
<p>结果显示如下：</p>
<p>![image(1)-QKzyA4](<a href="https://cdn.jsdelivr.net/gh/zhangga/gitment-comments@master/uPic/2021-11/image">https://cdn.jsdelivr.net/gh/zhangga/gitment-comments@master/uPic/2021-11/image</a> (1)-QKzyA4.png)</p>
<p>执行命令 <code>sudo make install</code>，并输入密码，开始执行安装</p>
<p>安装完成后使用<code>lua -v</code> 查看版本</p>
<ul>
<li><strong>golua环境</strong></li>
</ul>
<ol>
<li><strong>添加文件/usr/local/lib/pkgconfig/lua5.4.pc</strong></li>
</ol>
<p>内容如下：</p>
<p>prefix=/usr/local<br>exec_prefix=${prefix}<br>libdir=${exec_prefix}/lib<br>includedir=${prefix}/include</p>
<p>Name: liblua<br>Description: Lua5.4.3<br>Version: 5.4.3<br>Requires:<br>Libs: -L${libdir} -llua<br>Cflags: -I${includedir} -I${includedir}/lua</p>
<ol>
<li><p><strong>终端执行：</strong><code>brew install pkg-config</code></p>
</li>
<li><p><strong>终端执行：</strong><code>go get github.com/zhao02game/golua/lua</code></p>
</li>
<li><p><strong>其他安装</strong></p>
</li>
</ol>
<p><code>brew install coreutils ag etcd redis zsh</code></p>
<ol start="11">
<li><strong>终端定制</strong></li>
</ol>
<p><a href="https://segmentfault.com/a/1190000014992947">https://segmentfault.com/a/1190000014992947</a></p>
<ol start="12">
<li><p>翻译软件</p>
<p>欧陆词典</p>
</li>
<li><p>图床软件</p>
<p><a href="https://github.com/gee1k/uPic">https://github.com/gee1k/uPic</a></p>
<p>使用GitHub做为图床，设置</p>
<p><a href="https://cdn.jsdelivr.net/gh/zhangga/gitment-comments@master/uPic/2021-11/20211102183650-TrCWY6.jpg" title="20211102183650-TrCWY6" class="gallery-item" style="box-shadow: none;"> <img src="https://cdn.jsdelivr.net/gh/zhangga/gitment-comments@master/uPic/2021-11/20211102183650-TrCWY6.jpg" alt="20211102183650-TrCWY6"></a></p>
</li>
<li><p>使用vscode查看csv的差异，vscode安装Edit csv 和 SVN插件。</p>
<p>Edit csv设置：</p>
<p><a href="https://cdn.jsdelivr.net/gh/zhangga/gitment-comments@master/uPic/2021-11/20211102184046-NvJ5ti.jpg" title="20211102184046-NvJ5ti" class="gallery-item" style="box-shadow: none;"> <img src="https://cdn.jsdelivr.net/gh/zhangga/gitment-comments@master/uPic/2021-11/20211102184046-NvJ5ti.jpg" alt="20211102184046-NvJ5ti"></a></p>
</li>
<li></li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB索引详解</title>
    <url>/mongodb-index/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="索引基础知识"><a href="#索引基础知识" class="headerlink" title="索引基础知识"></a>索引基础知识</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引最常用的比喻就是书籍的目录，查询索引就像查询一本书的目录。本质上目录是将书中一小部分内容信息（比如题目）和内容的位置信息（页码）共同构成，而由于信息量小（只有题目），所以我们可以很快找到我们想要的信息片段，再根据页码找到相应的内容。同样索引也是只保留某个域的一部分信息（建立了索引的field的信息），以及对应的文档的位置信息。 假设我们有如下文档（每行的数据在MongoDB中是存在于一个Document当中）</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">id</th>
<th align="left">部门</th>
<th align="left">city</th>
<th align="left">score</th>
</tr>
</thead>
<tbody><tr>
<td align="left">张三</td>
<td align="left">2</td>
<td align="left">xxx</td>
<td align="left">Beijing</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">李四</td>
<td align="left">1</td>
<td align="left">xxx</td>
<td align="left">Shanghai</td>
<td align="left">70</td>
</tr>
<tr>
<td align="left">王五</td>
<td align="left">3</td>
<td align="left">xxx</td>
<td align="left">guangzhou</td>
<td align="left">60</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>假如我们想找id为2的document(即张三的记录)，如果没有索引，我们就需要扫描整个数据表，然后找出所有为2的document。当数据表中有大量documents的时候，这个时间就会非常长（从磁盘上查找数据还涉及大量的IO操作)。建立索引后会有什么变化呢？MongoDB会将id数据拿出来建立索引数据，如下</p>
<table>
<thead>
<tr>
<th align="left">索引值</th>
<th align="left">位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">pos2</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">pos1</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">pos3</td>
</tr>
</tbody></table>
<p>这样我们就可以通过扫描这个小表找到document对应的位置。</p>
<p>查找过程示意图如下：<a href="https://upload-images.jianshu.io/upload_images/3959253-7e2a31d0b5301c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="图片来源MongoDB官网" class="gallery-item" style="box-shadow: none;"> <img src="https://upload-images.jianshu.io/upload_images/3959253-7e2a31d0b5301c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来源MongoDB官网"></a></p>
<p>为什么这样速度会快呢？这主要有几方面的因素</p>
<ol>
<li>索引数据通过B+树来存储，从而使得搜索的时间复杂度为O(log<sub>d</sub><sup>N</sup>)级别的(d是B+树的度, 通常d的值比较大，比如大于100)，比原先O(N)的复杂度大幅下降。这个差距是惊人的，以一个实际例子来看，假设d=100，N=1亿，那么O(log<sub>d</sub><sup>N</sup>) = 8, 而O(N)是1亿。是的，这就是算法的威力。</li>
<li>索引本身是在高速缓存当中，相比磁盘IO操作会有大幅的性能提升。（需要注意的是，有的时候数据量非常大的时候，索引数据也会非常大，当大到超出内存容量的时候，会导致部分索引数据存储在磁盘上，这会导致磁盘IO的开销大幅增加，从而影响性能，所以务必要保证有足够的内存能容下所有的索引数据）</li>
</ol>
<p>当然，事物总有其两面性，在提升查询速度的同时，由于要建立索引，所以写入操作时就需要额外的添加索引的操作，这必然会影响写入的性能，所以当有大量写操作而读操作比较少的时候，且对读操作性能不需要考虑的时候，就不适合建立索引。当然，目前大多数互联网应用都是读操作远大于写操作，因此建立索引很多时候是非常划算和必要的操作。</p>
<p>关于索引原理的详细解释可以参考文章<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a>，虽然讲得是MySQL但是原理相似。</p>
<h2 id="MongoDB有哪些类型的索引"><a href="#MongoDB有哪些类型的索引" class="headerlink" title="MongoDB有哪些类型的索引"></a>MongoDB有哪些类型的索引</h2><h3 id="单字段索引-（Single-Field-Index）"><a href="#单字段索引-（Single-Field-Index）" class="headerlink" title="单字段索引 （Single Field Index）"></a>单字段索引 （Single Field Index）</h3><p>这个是最简单最常用的索引类型，比如我们上边的例子，为id建立一个单独的索引就是此种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # 为id field建立索引，1表示升序，-1表示降序，没有差别</span><br><span class="line">db.employee.createIndex(&#123;&#x27;id&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure>



<p>需要注意的是通常MongoDB会自动为我们的文档插入’_id’ field，且已经按照升序进行索引，如果我们插入的文档中包含有’_id’ field，则MongoDB就不会自动创建’_id’ field，但是需要我们自己来保证唯一性从而唯一标识一个文档</p>
<h3 id="复合索引-Compound-Index"><a href="#复合索引-Compound-Index" class="headerlink" title="复合索引 (Compound Index)"></a>复合索引 (Compound Index)</h3><p>符合索引的原理如下图所示：<a href="https://upload-images.jianshu.io/upload_images/3959253-6b00f39c08c49406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="复合索引示意图" class="gallery-item" style="box-shadow: none;"> <img src="https://upload-images.jianshu.io/upload_images/3959253-6b00f39c08c49406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复合索引示意图"></a>上图查询索引的时候会先查询userid，再查询score，然后就可以找到对应的文档。 对于复合索引需要注意以下几点：</p>
<h4 id="索引field的先后顺序很关键，影响有两方面："><a href="#索引field的先后顺序很关键，影响有两方面：" class="headerlink" title="索引field的先后顺序很关键，影响有两方面："></a>索引field的先后顺序很关键，影响有两方面：</h4><ol>
<li><p>MongoDB在复合索引中是根据prefix排序查询，就是说排在前面的可以单独使用。我们创建一个如下的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex(&#123;&#x27;id&#x27;: 1, &#x27;city&#x27;: 1, &#x27;score&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们如下的查询可以利用索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;&#x27;id&#x27;: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;&#x27;id&#x27;: xxx, &#x27;city&#x27;: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;&#x27;id&#x27;: xxx, &#x27;city&#x27;:xxx, &#x27;score&#x27;: xxxx&#125;)</span><br></pre></td></tr></table></figure>



<p>但是如下的查询无法利用该索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;&#x27;city&#x27;: xxx&#125;)</span><br><span class="line">db.collection.find(&#123;&#x27;city&#x27;:xxx, &#x27;score&#x27;: xxxx&#125;)</span><br></pre></td></tr></table></figure>



<p>还有一种特殊的情况，就是如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;&#x27;id&#x27;: xxx, &#x27;score&#x27;: xxxx&#125;)</span><br></pre></td></tr></table></figure>



<p>这个查询也可以利用索引的前缀’id’来查询，但是却不能针对score进行查询，你可以说是部分利用了索引，因此其效率可能不如如下索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex(&#123;&#x27;id&#x27;: 1, &#x27;score&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure>



<p>2.过滤出的document越少的field越应该放在前面，比如此例中id如果是唯一的，那么就应该放在最前面，因为这样通过id就可以锁定唯一一个文档。而如果通过city或者score过滤完成后还是会有大量文档，这就会影响最终的性能。</p>
<h4 id="索引的排序顺序不同"><a href="#索引的排序顺序不同" class="headerlink" title="索引的排序顺序不同"></a>索引的排序顺序不同</h4><p>复合索引最末尾的field，其排序顺序不同对于MongoDB的查询排序操作是有影响的。 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.events.createIndex( &#123; username: 1, date: -1 &#125; )</span><br></pre></td></tr></table></figure>



<p>这种情况下， 如下的query可以利用索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: 1, date: -1 &#125; )</span><br></pre></td></tr></table></figure>



<p>但是如下query则无法利用index进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: 1, date: 1 &#125; )</span><br></pre></td></tr></table></figure>



<h3 id="多key索引-（Multikey-Index）"><a href="#多key索引-（Multikey-Index）" class="headerlink" title="多key索引 （Multikey Index）"></a>多key索引 （Multikey Index）</h3><p>这个主要是针对数据类型为数组的类型，如下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 19, habbit: [&quot;football, runnning&quot;]&#125;</span><br><span class="line">db.person.createIndex( &#123;habbit: 1&#125; )  // 自动创建多key索引</span><br><span class="line">db.person.find( &#123;habbit: &quot;football&quot;&#125; )</span><br></pre></td></tr></table></figure>



<h3 id="其它类型索引"><a href="#其它类型索引" class="headerlink" title="其它类型索引"></a>其它类型索引</h3><p>另外，MongoDB中还有其它如哈希索引，地理位置索引以及文本索引，主要用于一些特定场景，具体可以参考官网，在此不再详解</p>
<h3 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h3><p>索引主要有以下几个属性:</p>
<ul>
<li><p>unique：这个非常常用，用于限制索引的field是否具有唯一性属性，即保证该field的值唯一</p>
</li>
<li><p>partial：很有用，在索引的时候只针对符合特定条件的文档来建立索引，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.restaurants.createIndex(</span><br><span class="line">   &#123; cuisine: 1, name: 1 &#125;,</span><br><span class="line">   &#123; partialFilterExpression: &#123; rating: &#123; $gt: 5 &#125; &#125; &#125; //只有当rating大于5时才会建立索引</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样做的好处是，我们可以只为部分数据建立索引，从而可以减少索引数据的量，除节省空间外，其检索性能也会因为较少的数据量而得到提升。</p>
<ul>
<li>sparse：可以认为是partial索引的一种特殊情况，由于MongoDB3.2之后已经支持partial属性，所以建议直接使用partial属性。</li>
<li>TTL。 可以用于设定文档有效期，有效期到自动删除对应的文档。</li>
</ul>
<h1 id="通过explain结果来分析性能"><a href="#通过explain结果来分析性能" class="headerlink" title="通过explain结果来分析性能"></a>通过explain结果来分析性能</h1><p>我们往往会通过打点数据来分析业务的性能瓶颈，这时，我们会发现很多瓶颈都是出现在数据库相关的操作上，这时由于数据库的查询和存取都涉及大量的IO操作，而且有时由于使用不当，会导致IO操作的大幅度增长，从而导致了产生性能问题。而MongoDB提供了一个explain工具来用于分析数据库的操作。直接拿官网的示例来做说明：</p>
<p>假设我们在inventory collection中有如下文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : 1, &quot;item&quot; : &quot;f1&quot;, type: &quot;food&quot;, quantity: 500 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;f2&quot;, type: &quot;food&quot;, quantity: 100 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;p1&quot;, type: &quot;paper&quot;, quantity: 200 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;p2&quot;, type: &quot;paper&quot;, quantity: 150 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;f3&quot;, type: &quot;food&quot;, quantity: 300 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 6, &quot;item&quot; : &quot;t1&quot;, type: &quot;toys&quot;, quantity: 500 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 7, &quot;item&quot; : &quot;a1&quot;, type: &quot;apparel&quot;, quantity: 250 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 8, &quot;item&quot; : &quot;a2&quot;, type: &quot;apparel&quot;, quantity: 400 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 9, &quot;item&quot; : &quot;t2&quot;, type: &quot;toys&quot;, quantity: 50 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 10, &quot;item&quot; : &quot;f4&quot;, type: &quot;food&quot;, quantity: 75 &#125;</span><br></pre></td></tr></table></figure>



<p>假设此时没有建立索引，做如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; quantity: &#123; $gte: 100, $lte: 200 &#125; &#125; )</span><br></pre></td></tr></table></figure>



<p>返回结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;f2&quot;, &quot;type&quot; : &quot;food&quot;, &quot;quantity&quot; : 100 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 3, &quot;item&quot; : &quot;p1&quot;, &quot;type&quot; : &quot;paper&quot;, &quot;quantity&quot; : 200 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 4, &quot;item&quot; : &quot;p2&quot;, &quot;type&quot; : &quot;paper&quot;, &quot;quantity&quot; : 150 &#125;</span><br></pre></td></tr></table></figure>



<p>这是我们可以通过explain来分析整个查询的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># explain 有三种模式： &quot;queryPlanner&quot;, &quot;executionStats&quot;, and &quot;allPlansExecution&quot;.</span><br><span class="line"># 其中最常用的就是第二种&quot;executionStats&quot;，它会返回具体执行的时候的统计数据</span><br><span class="line">db.inventory.find(</span><br><span class="line">   &#123; quantity: &#123; $gte: 100, $lte: 200 &#125; &#125;</span><br><span class="line">).explain(&quot;executionStats&quot;)</span><br></pre></td></tr></table></figure>



<p>explain的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;queryPlanner&quot; : &#123;</span><br><span class="line">         &quot;plannerVersion&quot; : 1,</span><br><span class="line">         ...</span><br><span class="line">         &quot;winningPlan&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;executionStats&quot; : &#123;</span><br><span class="line">      &quot;executionSuccess&quot; : true,</span><br><span class="line">      &quot;nReturned&quot; : 3,  # 查询返回的document数量</span><br><span class="line">      &quot;executionTimeMillis&quot; : 0, # 执行查询所用的时间</span><br><span class="line">      &quot;totalKeysExamined&quot; : 0, # 总共查询了多少个key，由于没有使用索引，因此这里为0</span><br><span class="line">      &quot;totalDocsExamined&quot; : 10, # 总共在磁盘查询了多少个document，由于是全表扫描，我们总共有10个documents，因此，这里为10</span><br><span class="line">      &quot;executionStages&quot; : &#123;</span><br><span class="line">         &quot;stage&quot; : &quot;COLLSCAN&quot;,  # 注意这里，&quot;COLLSCAN&quot;意味着全表扫描</span><br><span class="line">         ...</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的结果中有一个”stage”字段，上例中stage为”COLLSCAN”，而MongoDB总共有如下几种stage：</p>
<ul>
<li>COLLSCAN – Collection scan</li>
<li>IXSCAN – Scan of data in index keys</li>
<li>FETCH – Retrieving documents</li>
<li>SHARD_MERGE – Merging results from shards</li>
<li>SORT – Explicit sort rather than using index order</li>
</ul>
<p>现在我们来创建一个索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.createIndex( &#123; quantity: 1 &#125; )</span><br></pre></td></tr></table></figure>



<p>再来看下explain的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.find(</span><br><span class="line">   &#123; quantity: &#123; $gte: 100, $lte: 200 &#125; &#125;</span><br><span class="line">).explain(&quot;executionStats&quot;)</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;queryPlanner&quot; : &#123;</span><br><span class="line">         &quot;plannerVersion&quot; : 1,</span><br><span class="line">         ...</span><br><span class="line">         &quot;winningPlan&quot; : &#123;</span><br><span class="line">               &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">               &quot;inputStage&quot; : &#123;</span><br><span class="line">                  &quot;stage&quot; : &quot;IXSCAN&quot;,  # 这里&quot;IXSCAN&quot;意味着索引扫描</span><br><span class="line">                  &quot;keyPattern&quot; : &#123;</span><br><span class="line">                     &quot;quantity&quot; : 1</span><br><span class="line">                  &#125;,</span><br><span class="line">                  ...</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;executionStats&quot; : &#123;</span><br><span class="line">         &quot;executionSuccess&quot; : true,</span><br><span class="line">         &quot;nReturned&quot; : 3,</span><br><span class="line">         &quot;executionTimeMillis&quot; : 0,</span><br><span class="line">         &quot;totalKeysExamined&quot; : 3,  # 这里nReturned、totalKeysExamined和totalDocsExamined相等说明索引没有问题，因为我们通过索引快速查找到了三个文档，且从磁盘上也是去取这三个文档，并返回三个文档。</span><br><span class="line">         &quot;totalDocsExamined&quot; : 3,</span><br><span class="line">         &quot;executionStages&quot; : &#123;</span><br><span class="line">            ...</span><br><span class="line">         &#125;,</span><br><span class="line">         ...</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再来看下如何通过explain来比较compound index的性能，之前我们在介绍复合索引的时候已经说过field的顺序会影响查询的效率。有时这种顺序并不太好确定（比如field的值都不是unique的），那么怎么判断哪种顺序的复合索引的效率高呢，这就像需要explain结合hint来进行分析。 比如我们要做如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123;</span><br><span class="line">   quantity: &#123;</span><br><span class="line">      $gte: 100, $lte: 300</span><br><span class="line">   &#125;,</span><br><span class="line">   type: &quot;food&quot;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>



<p>会返回如下文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : 2, &quot;item&quot; : &quot;f2&quot;, &quot;type&quot; : &quot;food&quot;, &quot;quantity&quot; : 100 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 5, &quot;item&quot; : &quot;f3&quot;, &quot;type&quot; : &quot;food&quot;, &quot;quantity&quot; : 300 &#125;</span><br></pre></td></tr></table></figure>



<p>现在我们要比较如下两种复合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.createIndex( &#123; quantity: 1, type: 1 &#125; )</span><br><span class="line">db.inventory.createIndex( &#123; type: 1, quantity: 1 &#125; )</span><br></pre></td></tr></table></figure>



<p>分析索引 { quantity: 1, type: 1 }的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 结合hint和explain来进行分析</span><br><span class="line">db.inventory.find(</span><br><span class="line">   &#123; quantity: &#123; $gte: 100, $lte: 300 &#125;, type: &quot;food&quot; &#125;</span><br><span class="line">).hint(&#123; quantity: 1, type: 1 &#125;).explain(&quot;executionStats&quot;) # 这里使用hint会强制数据库使用索引 &#123; quantity: 1, type: 1 &#125;</span><br></pre></td></tr></table></figure>



<p>explain结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;queryPlanner&quot; : &#123;</span><br><span class="line">      ...</span><br><span class="line">      &quot;winningPlan&quot; : &#123;</span><br><span class="line">         &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">         &quot;inputStage&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">            &quot;keyPattern&quot; : &#123;</span><br><span class="line">               &quot;quantity&quot; : 1,</span><br><span class="line">               &quot;type&quot; : 1</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;executionStats&quot; : &#123;</span><br><span class="line">      &quot;executionSuccess&quot; : true,</span><br><span class="line">      &quot;nReturned&quot; : 2,</span><br><span class="line">      &quot;executionTimeMillis&quot; : 0,</span><br><span class="line">      &quot;totalKeysExamined&quot; : 5,  # 这里是5与totalDocsExamined、nReturned都不相等</span><br><span class="line">      &quot;totalDocsExamined&quot; : 2,</span><br><span class="line">      &quot;executionStages&quot; : &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再来看下索引 { type: 1, quantity: 1 } 的分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.inventory.find(</span><br><span class="line">   &#123; quantity: &#123; $gte: 100, $lte: 300 &#125;, type: &quot;food&quot; &#125;</span><br><span class="line">).hint(&#123; type: 1, quantity: 1 &#125;).explain(&quot;executionStats&quot;)</span><br></pre></td></tr></table></figure>



<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;queryPlanner&quot; : &#123;</span><br><span class="line">      ...</span><br><span class="line">      &quot;winningPlan&quot; : &#123;</span><br><span class="line">         &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">         &quot;inputStage&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">            &quot;keyPattern&quot; : &#123;</span><br><span class="line">               &quot;type&quot; : 1,</span><br><span class="line">               &quot;quantity&quot; : 1</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;executionStats&quot; : &#123;</span><br><span class="line">      &quot;executionSuccess&quot; : true,</span><br><span class="line">      &quot;nReturned&quot; : 2,</span><br><span class="line">      &quot;executionTimeMillis&quot; : 0,</span><br><span class="line">      &quot;totalKeysExamined&quot; : 2, # 这里是2，与totalDocsExamined、nReturned相同</span><br><span class="line">      &quot;totalDocsExamined&quot; : 2,</span><br><span class="line">      &quot;executionStages&quot; : &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看出后一种索引的totalKeysExamined返回是2，相比前一种索引的5，显然更有效率。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://docs.mongodb.com/manual/indexes/">MongoDB Index</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></li>
<li><a href="http://www.mongoing.com/archives/2797">MongoDB索引原理</a></li>
<li><a href="https://docs.mongodb.com/manual/tutorial/analyze-query-plan/">Analyze Query Performance</a></li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA+MAVEN+GIT项目管理</title>
    <url>/mvn-git/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h2><p>下载地址：<a href="http://maven.apache.org/download.cgi#">http://maven.apache.org/download.cgi#</a></p>
<p>解压到D盘Maven文件夹下：</p>
<p>在Maven文件夹下新建一个Repository文件夹，用作仓库。</p>
<p>修改D:\Maven\apache-maven-3.6.0\conf下settings.xml文件：</p>
<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;localRepository&gt;D:\Maven\Repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在mirrors下添加阿里云远程镜像，速度贼快：</p>
<p>&lt;!– 阿里云仓库 –&gt;<br><mirror><br><id>alimaven</id><br><mirrorOf>central</mirrorOf><br><name>aliyun maven</name><br><url><a href="http://maven.aliyun.com/nexus/content/repositories/central/">http://maven.aliyun.com/nexus/content/repositories/central/</a></url><br></mirror></p>
<mirror>
<id>alimaven</id>
<name>aliyun maven</name>
<url>http://maven.aliyun.com/nexus/content/groups/public/</url>
<mirrorOf>central</mirrorOf>
</mirror>

<p>在profiles下添加，修改jdk为11：</p>
<profile>
<id>jdk-11</id>
<activation>
<activeByDefault>true</activeByDefault>
<jdk>11</jdk>
</activation>
<properties>
<maven.compiler.source>11</maven.compiler.source>
<maven.compiler.target>11</maven.compiler.target>
<maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>
</properties>
</profile>

<p>添加环境变量：<br>M2_HOME<br>D:\Maven\apache-maven-3.6.0<br>Path<br>%M2_HOME%\bin;</p>
<h2 id="idea建立maven"><a href="#idea建立maven" class="headerlink" title="idea建立maven"></a>idea建立maven</h2><p>在settings里面：</p>
<p><a href="https://img-blog.csdn.net/20170818231853882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV5YW9xaWFveWFvZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title="IDEA+MAVEN+GIT项目管理 - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://img-blog.csdn.net/20170818231853882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV5YW9xaWFveWFvZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="IDEA+MAVEN+GIT项目管理 - 第1张  | 张嘎"></a></p>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>git下载地址 ：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a><br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p>
<p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href="mailto:&#101;&#109;&#x61;&#105;&#x6c;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;">&#101;&#109;&#x61;&#105;&#x6c;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;</a>”</p>
<p>具体过程请参见：<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000">廖雪峰Git安装</a></p>
<h2 id="git-clone远程项目"><a href="#git-clone远程项目" class="headerlink" title="git clone远程项目"></a>git clone远程项目</h2><p>在“Git Bash”命令行里输入：ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#x6f;&#117;&#114;&#x2e;&#x65;&#109;&#x61;&#x69;&#x6c;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#x79;&#x6f;&#117;&#114;&#x2e;&#x65;&#109;&#x61;&#x69;&#x6c;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a>” -b 4096</p>
<p>会在本地用户目录下的.ssh文件夹下生成id_rsa和id_rsa.pub文件，</p>
<p>将id_rsa.pub公钥文件加入到远程git/Setttings/SSH Keys里面。</p>
<p>右键菜单“Git GUI”</p>
<h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p>码云是目前国内比较好的代码托管平台。<br>码云官方教程如下：<br><a href="http://git.mydoc.io/?t=153739">码云教程</a><br>安装好插件后可以将之前建立的项目托管到码云上。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>杂乱</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus搭建开发组的私有仓库</title>
    <url>/nexus/</url>
    <content><![CDATA[<div class=".article-gallery"><p><strong>目录</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label0">一、私有仓库的价值</a></li>
<li>二、准备工作<ul>
<li>2.1、安装Java编译环境<ul>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0">2.1.1、安装</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0">2.1.2、验证</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0">2.1.3、设置环境变量</a></li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_1">2.2、虚拟机访问互联网</a></li>
</ul>
</li>
<li>三、安装Nexus<ul>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_0">3.1、下载nexus</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_1">3.2、部署</a></li>
<li>3.3、系统服务<ul>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2">3.3.1、编辑系统服务文件</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2">3.3.2、设置为自启动服务</a></li>
</ul>
</li>
</ul>
</li>
<li>四、设置Nexus<ul>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_0">4.1、浏览器登录</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_1">4.2、进入管理界面</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_2">4.3、增加新的代理源</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_3">4.3、设置私用仓库可重复发布</a></li>
</ul>
</li>
<li>五、安装maven并设置私用仓库<ul>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_0">5.1、下载安装</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_1">5.2、设置环境变量</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_2">5.3、测试</a></li>
<li><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_3">5.4、配置</a></li>
</ul>
</li>
</ul>
<p><strong>正文</strong><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop">回到顶部</a></p>
<span id="more"></span>

<p><a href="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-1024x495.png?resize=640,309" title="Nexus搭建开发组的私有仓库 - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-1024x495.png?resize=640,309" alt="Nexus搭建开发组的私有仓库 - 第1张  | 张嘎"></a></p>
<h1 id="一、私有仓库的价值"><a href="#一、私有仓库的价值" class="headerlink" title="一、私有仓库的价值"></a>一、私有仓库的价值</h1><p>　　开发Java应用系统，用到Maven、sbt和 Gradle等构建工具，在构建过程中一般需要从互联网下载依赖库，构建私有仓库就是为了在开发组或者部门内共用，从而节省整体的下载成本和构建成本。下面先以Maven为例说明。</p>
<p>　　Maven是一个强大的构建工具，一般用于Java项目。Maven项目基于对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。</p>
<p>Maven的Java项目一般需要下载第三方组件，下载后构成本地仓库，为了减少网络对构建项目的影响，一般会构建私服仓库，代理第三方库。Nexus就是构建私服仓库的优秀软件。</p>
<p><a href="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220431849-1095286350.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220431849-1095286350.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第2张  | 张嘎"></a></p>
<p>图 1 三层仓库架构<a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop">回到顶部</a></p>
<h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><h2 id="2-1、安装Java编译环境"><a href="#2-1、安装Java编译环境" class="headerlink" title="2.1、安装Java编译环境"></a>2.1、安装Java编译环境</h2><p>Java编译环境包括核心的JDK和编译工具，因为Java的编译工具有很多种，而开源项目作者的随意性很高，常用的工具有maven，gradle,sbt，ant等等，本文关注Maven。</p>
<p>因为Oracle不再维护Java1.7，所以采用Java 1.8作为编译核心.</p>
<h3 id="2-1-1、安装"><a href="#2-1-1、安装" class="headerlink" title="2.1.1、安装"></a>2.1.1、安装</h3><p>操作系统采用Centos7.4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel java-1.8.0-openjdk java-1.8.0-openjdk-headless -y</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、验证"><a href="#2-1-2、验证" class="headerlink" title="2.1.2、验证"></a>2.1.2、验证</h3><p>查看jdk版本号</p>
<p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第3张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第3张  | 张嘎"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true</span><br><span class="line">openjdk version &quot;1.8.0_131&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_131-b12)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第4张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第4张  | 张嘎"></a></p>
<h3 id="2-1-3、设置环境变量"><a href="#2-1-3、设置环境变量" class="headerlink" title="2.1.3、设置环境变量"></a>2.1.3、设置环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$JRE_HOME/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>即刻生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="2-2、虚拟机访问互联网"><a href="#2-2、虚拟机访问互联网" class="headerlink" title="2.2、虚拟机访问互联网"></a>2.2、虚拟机访问互联网</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens32</span><br></pre></td></tr></table></figure>

<p>注：环境不同网卡名会不同</p>
<p>增加天津联通的DNS（注：作者在天津，请按个人本地的运行商做相应修改）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS1=202.99.96.68</span><br><span class="line">DNS2=202.99.104.68</span><br></pre></td></tr></table></figure>

<p>在实际测试中感觉天津电信的DNS更加靠谱，访问一些特殊网站返回的IP能够顺利访问，大家根据实践选择吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS1=219.150.32.132</span><br><span class="line">DNS2=219.146.0.130</span><br></pre></td></tr></table></figure>

<p>重新启动网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.163.com</span><br><span class="line">PING 163.xdwscache.ourglb0.com (42.81.9.47) 56(84) bytes of data.</span><br><span class="line">64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=1 ttl=128 time=9.66 ms</span><br><span class="line">64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=2 ttl=128 time=10.4 ms…</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop">回到顶部</a></p>
<h1 id="三、安装Nexus"><a href="#三、安装Nexus" class="headerlink" title="三、安装Nexus"></a>三、安装Nexus</h1><h2 id="3-1、下载nexus"><a href="#3-1、下载nexus" class="headerlink" title="3.1、下载nexus"></a>3.1、下载nexus</h2><p>从官方网站现在最新3.X版</p>
<p><a href="https://www.sonatype.com/download-oss-sonatype">https://www.sonatype.com/download-oss-sonatype</a></p>
<p>下载（2018年3月）最新版nexus-3.9.0-01-unix.tar.gz （）</p>
<h2 id="3-2、部署"><a href="#3-2、部署" class="headerlink" title="3.2、部署"></a>3.2、部署</h2><p>先规划存储私有仓库的目录，作者本机的/opt目录空间较多，所以以/opt为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /opt/scm</span><br><span class="line">tar -xf ~/download/nexus-3.9.0-01-unix.tar.gz -C .</span><br></pre></td></tr></table></figure>

<p>生成两个目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nexus-3.9.0-01</span><br><span class="line">sonatype-work</span><br></pre></td></tr></table></figure>

<h2 id="3-3、系统服务"><a href="#3-3、系统服务" class="headerlink" title="3.3、系统服务"></a>3.3、系统服务</h2><h3 id="3-3-1、编辑系统服务文件"><a href="#3-3-1、编辑系统服务文件" class="headerlink" title="3.3.1、编辑系统服务文件"></a>3.3.1、编辑系统服务文件</h3><p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第5张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第5张  | 张嘎"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/nexus.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=nexus service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]Type=forking</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">ExecStart=/opt/scm/nexus-3.9.0-01/bin/nexus start</span><br><span class="line">ExecStop=/opt/scm/nexus-3.9.0-01/bin/nexus stop</span><br><span class="line">User=ansible</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第6张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第6张  | 张嘎"></a></p>
<h3 id="3-3-2、设置为自启动服务"><a href="#3-3-2、设置为自启动服务" class="headerlink" title="3.3.2、设置为自启动服务"></a>3.3.2、设置为自启动服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl  daemon-reload</span><br><span class="line">sudo systemctl start nexus.service</span><br><span class="line">sudo systemctl status nexus.service</span><br><span class="line">sudo systemctl enable nexus.service</span><br></pre></td></tr></table></figure>

<p>启动报错：1./etc/systemd/system/nexus.service文件的user不对<br>2.修改/opt/scm/nexus/bin/nexus 启动的JAVA_HOME 如：INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/java/jdk1.8/</p>
<p><a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop">回到顶部</a></p>
<h1 id="四、设置Nexus"><a href="#四、设置Nexus" class="headerlink" title="四、设置Nexus"></a>四、设置Nexus</h1><h2 id="4-1、浏览器登录"><a href="#4-1、浏览器登录" class="headerlink" title="4.1、浏览器登录"></a>4.1、浏览器登录</h2><p><a href="http://192.168.154.11:8081/">http://192.168.154.11:8081/</a></p>
<p><a href="https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220256240-534211558.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第7张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220256240-534211558.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第7张  | 张嘎"></a></p>
<p>用户名的密码为：admin admin123</p>
<h2 id="4-2、进入管理界面"><a href="#4-2、进入管理界面" class="headerlink" title="4.2、进入管理界面"></a>4.2、进入管理界面</h2><p><a href="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220317318-1530787694.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第8张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220317318-1530787694.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第8张  | 张嘎"></a></p>
<h2 id="4-3、增加新的代理源"><a href="#4-3、增加新的代理源" class="headerlink" title="4.3、增加新的代理源"></a>4.3、增加新的代理源</h2><p><a href="https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220331802-1557956595.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第9张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220331802-1557956595.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第9张  | 张嘎"></a></p>
<p>设置名称和URL</p>
<p><a href="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220342224-1667350164.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第10张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220342224-1667350164.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第10张  | 张嘎"></a></p>
<p>Cache统一设置为200天 288000</p>
<p><a href="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220350271-1209294422.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第11张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220350271-1209294422.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第11张  | 张嘎"></a></p>
<p> 逐个增加常用代理</p>
<p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第12张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第12张  | 张嘎"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. aliyun</span><br><span class="line">http://maven.aliyun.com/nexus/content/groups/public</span><br><span class="line">2. apache_snapshot</span><br><span class="line">https://repository.apache.org/content/repositories/snapshots/</span><br><span class="line">3. apache_release</span><br><span class="line">https://repository.apache.org/content/repositories/releases/</span><br><span class="line">4. atlassian</span><br><span class="line">https://maven.atlassian.com/content/repositories/atlassian-public/</span><br><span class="line">5. central.maven.org</span><br><span class="line">http://central.maven.org/maven2/</span><br><span class="line">6. datanucleus</span><br><span class="line">http://www.datanucleus.org/downloads/maven2</span><br><span class="line">7. maven-central （安装后自带，仅需设置Cache有效期即可）</span><br><span class="line">https://repo1.maven.org/maven2/</span><br><span class="line">8. nexus.axiomalaska.com</span><br><span class="line">http://nexus.axiomalaska.com/nexus/content/repositories/public</span><br><span class="line">9. oss.sonatype.org</span><br><span class="line">https://oss.sonatype.org/content/repositories/snapshots</span><br><span class="line">10.pentaho</span><br><span class="line">https://public.nexus.pentaho.org/content/groups/omni/</span><br></pre></td></tr></table></figure>

<p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第13张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第13张  | 张嘎"></a></p>
<p>再次强调，在</p>
<p>How long (in minutes) to cache metadata before rechecking the remote repository.处</p>
<p>统一设置为</p>
<p>288000 即200天，当然可以设置为更长的时间</p>
<p>设置maven-public</p>
<p>将这些代理加入Group</p>
<p><a href="https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220400959-1653481781.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第14张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220400959-1653481781.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第14张  | 张嘎"></a></p>
<h2 id="4-3、设置私用仓库可重复发布"><a href="#4-3、设置私用仓库可重复发布" class="headerlink" title="4.3、设置私用仓库可重复发布"></a>4.3、设置私用仓库可重复发布</h2><p>　　Nexus安装后自带maven-releases，maven-snapshots两个仓库，用于将生成的jar包发布在这两个仓库中，在实际开发中需要将maven-releases设置为可以重复发布。</p>
<p>　　maven-releases</p>
<p><a href="https://i0.wp.com/images2018.cnblogs.com/blog/1082089/201803/1082089-20180317135112096-935379506.png?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第15张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/images2018.cnblogs.com/blog/1082089/201803/1082089-20180317135112096-935379506.png?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第15张  | 张嘎"></a></p>
<p>　　注：maven-snapshots缺省是可以重新部署的。<a href="https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop">回到顶部</a></p>
<h1 id="五、安装maven并设置私用仓库"><a href="#五、安装maven并设置私用仓库" class="headerlink" title="五、安装maven并设置私用仓库"></a>五、安装maven并设置私用仓库</h1><h2 id="5-1、下载安装"><a href="#5-1、下载安装" class="headerlink" title="5.1、下载安装"></a>5.1、下载安装</h2><p>从maven官网下载3.5.0 <a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd tools</span><br><span class="line">tar -xf ../download/apache-maven-3.5.0-bin.tar.gz –C .</span><br></pre></td></tr></table></figure>

<h2 id="5-2、设置环境变量"><a href="#5-2、设置环境变量" class="headerlink" title="5.2、设置环境变量"></a>5.2、设置环境变量</h2><p>vi ~/.bashrc</p>
<p>增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/ansible/tools/apache-maven-3.5.0/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>即刻生效</p>
<p>source ~/.bashrc</p>
<h2 id="5-3、测试"><a href="#5-3、测试" class="headerlink" title="5.3、测试"></a>5.3、测试</h2><p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第16张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第16张  | 张嘎"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br><span class="line"></span><br><span class="line">Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true</span><br><span class="line">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class="line">Maven home: /home/ansible/tools/apache-maven-3.5.0</span><br><span class="line">Java version: 1.8.0_102, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;3.10.0-514.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure>

<h2 id="5-4、配置"><a href="#5-4、配置" class="headerlink" title="5.4、配置"></a>5.4、配置</h2><p>vi ~/tools/apache-maven-3.5.0/conf/settings.xml（本地服务器可以使用localhost，开发组其他服务器则修改为对应Nexus服务器的域名或者IP地址）</p>
<p><a href="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" title="Nexus搭建开发组的私有仓库 - 第17张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1" alt="Nexus搭建开发组的私有仓库 - 第17张  | 张嘎"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;pluginGroups&gt;  </span><br><span class="line">     &lt;pluginGroup&gt;org.sonatype.plugins&lt;/pluginGroup&gt;  </span><br><span class="line">  &lt;/pluginGroups&gt; </span><br><span class="line">  &lt;mirrors&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;</span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">  &lt;/mirrors&gt;</span><br><span class="line">  &lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">      &lt;!--Enable snapshots for the built in central repo to direct --&gt;</span><br><span class="line">      &lt;!--all requests to nexus via the mirror --&gt;</span><br><span class="line">      &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">          &lt;id&gt;central&lt;/id&gt;</span><br><span class="line">          &lt;url&gt;http://central&lt;/url&gt;</span><br><span class="line">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class="line">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">      &lt;/repositories&gt;</span><br><span class="line">     &lt;pluginRepositories&gt;</span><br><span class="line">        &lt;pluginRepository&gt;</span><br><span class="line">          &lt;id&gt;central&lt;/id&gt;</span><br><span class="line">          &lt;url&gt;http://central&lt;/url&gt;</span><br><span class="line">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class="line">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class="line">        &lt;/pluginRepository&gt;</span><br><span class="line">      &lt;/pluginRepositories&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">  &lt;activeProfiles&gt;</span><br><span class="line">    &lt;!--make the profile active all the time --&gt;</span><br><span class="line">    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;</span><br><span class="line">  &lt;/activeProfiles&gt;</span><br><span class="line">  &lt;servers&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">      &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">      &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">  &lt;/servers&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>杂乱</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus+grafana搭建监控服务</title>
    <url>/prometheus/</url>
    <content><![CDATA[<div class=".article-gallery"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前使用过InfluxDB+Grafana的方案，主动push监控数据，现在使用Prometheus pull数据的方案，相比前一种方案，现在这种在部署上更加方便。<strong>推荐</strong>。</p>
<h1 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h1><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>可以参考另外一篇文章: <a href="http://kwaibook.com/influxdb-grafana/">InfluxDB和Grafana搭建监控服务</a></p>
<h4 id="Linux服务器安装"><a href="#Linux服务器安装" class="headerlink" title="Linux服务器安装"></a>Linux服务器安装</h4><ol>
<li><p><a href="https://grafana.com/grafana/download">官网</a>选择对应的版本下载并安装。</p>
</li>
<li><p>启动grafana</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@cxm ~]#systemctl daemon-reload</span><br><span class="line">[root@cxm ~]#systemctl start grafana-server</span><br><span class="line">[root@cxm ~]#systemctl stop grafana-server</span><br><span class="line">[root@cxm ~]#systemctl restart grafana-server</span><br><span class="line">[root@cxm ~]#systemctl status grafana-server</span><br><span class="line">[root@cxm ~]#systemctl enable grafana-server</span><br></pre></td></tr></table></figure></li>
<li><p>开放3000端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@cxm ~]#firewall-cmd --list-ports</span><br><span class="line">[root@cxm ~]#firewall-cmd --add-port=3000/tcp --zone=public --permanent</span><br><span class="line">[root@cxm ~]#firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>或者直接关闭防火墙</p>
</li>
</ol>
<h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><h4 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h4><ol>
<li>创建prometheus用户，将相关的都放在该用户下，参考<a href="https://cloud.tencent.com/developer/article/1445255">文章</a></li>
<li><a href="https://prometheus.io/download/">官网</a>下载</li>
<li>按照<a href="https://cloud.tencent.com/developer/article/1445255">文章</a>中的步骤以systemctl方式启动，注意新建的data文件夹需要是prometheus用户权限的</li>
</ol>
<h4 id="安装node-exporter"><a href="#安装node-exporter" class="headerlink" title="安装node_exporter"></a>安装node_exporter</h4><ul>
<li><p>用来上报机器性能数据，在prometheus的官网有。</p>
</li>
<li><p>按照<a href="https://cloud.tencent.com/developer/article/1445255">文章</a>中的方式以systemctl 启动。</p>
</li>
</ul>
<p>详细参考文章：</p>
<p><a href="https://mp.weixin.qq.com/s/ZXlBPHGcWeYh2hjBzacc3A">https://mp.weixin.qq.com/s/ZXlBPHGcWeYh2hjBzacc3A</a></p>
<p><a href="https://blog.csdn.net/shenyuanhaojie/article/details/121775976">https://blog.csdn.net/shenyuanhaojie/article/details/121775976</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/redis-mode/</url>
    <content><![CDATA[<div class=".article-gallery"><p>1.单线程：Redis是单线程来处理命令的，所以一条命令从客户端到达服务器不会立刻被执行，所有命令都会进入一个队列中，然后逐个执行。</p>
<p>2.Redis使用I/O多路复用技术来解决I/O的问题。</p>
<span id="more"></span>

<p>3.性能：纯内存访问、非阻塞IO，Redis使用epoll作为I/O多路复用技术的实现。单线程避免了线程切换和竞态产生的消耗。</p>
<p>4.单线程的问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞。致命的！</p>
<p>5.setnx可以作为分布式锁的一种实现方案。<a href="http://redis.io/topics/distlock">http://redis.io/topics/distlock</a></p>
<p>6.批量操作解决网络性能的瓶颈，Redis支持每秒数万的读写操作，网络可能会成为性能的瓶颈。</p>
<p>7.Redis支持简单的事务，multi开始  exec执行  discard舍弃。Redis不支持回滚功能，事务中可能第一条执行成功，第二条执行失败，第一条也会生效。</p>
<p>8.watch命令，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。</p>
<p>9.线上环境：redis-cli 超时的检测，timeout设置为大于0，客户端做空闲检测，jedis-pool的common-pool。</p>
<p>10.client pause 命令应用：让主、从保持一致。可控的将客户端连接从一个节点切换到另一个节点。线上暂停成本非常高。</p>
<p>11.rename-command命令重命名指令。</p>
<p>12.fork操作跟内存量成正比，线上建议单个Redis实例内存控制在10GB以内。</p>
<p>13.Redis是CPU密集型服务，不要和其他CPU密集型服务部署在一起。</p>
<p>14.主从：写高并发时，可以开启从的AOF，关闭主的持久化，要注意主库自动重启后没有数据，避免从库同步清空，血崩。</p>
<p>15.主从：读高并发时，可以让客户端从从库读取。</p>
<p>16.主从：写并发高的主库不适宜有多个从库。可以使用树状结构。</p>
<p>17.Redis执行fork操作产生的子进程，使用写时复制技术（copy-on-write），减少内存的占用。</p>
<p>18.尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。</p>
<p>19.控制数据类型的编码来实现时间和空间的平衡。</p>
<p>20.键值对很多时，可以分组映射到多个hash结构中，来降低键的数量。如100W个键分组映射到1000个hash中，每个1000个field、value。</p>
<p>21.集群故障转移时不影响其他主节点，配置cluster-require-full-coverage no。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>沙盒游戏3D场景建模</title>
    <url>/sandbox-scene/</url>
    <content><![CDATA[<div class=".article-gallery"><p>在一次聚餐之后，晚上睡觉前突然灵感爆棚想到的实现方案。</p>
<p>下面是在项目内部分享的PPT，具体代码实现在github：<a href="https://github.com/zhangga/JAVAZSet">https://github.com/zhangga/JAVAZSet</a></p>
<p><a href="https://imgtu.com/i/hNUOo9"><a href="https://z3.ax1x.com/2021/08/30/hNUOo9.md.png" title="hNUOo9.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/30/hNUOo9.md.png" alt="hNUOo9.md.png"></a></a></p>
<span id="more"></span>

<p><a href="https://imgtu.com/i/hNULdJ"><a href="https://z3.ax1x.com/2021/08/30/hNULdJ.md.png" title="hNULdJ.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/30/hNULdJ.md.png" alt="hNULdJ.md.png"></a></a></p>
<p><a href="https://imgtu.com/i/hNUjiR"><a href="https://z3.ax1x.com/2021/08/30/hNUjiR.md.png" title="hNUjiR.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/30/hNUjiR.md.png" alt="hNUjiR.md.png"></a></a></p>
<h2 id="实际碰到的一点问题："><a href="#实际碰到的一点问题：" class="headerlink" title="实际碰到的一点问题："></a>实际碰到的一点问题：</h2><p>1.把9张1024*1024的navmesh合一张的时候，原生的recast是用32位分配空间，其中14位分配给tile，所以tile有上限的考虑。</p>
<p>现在把recast改为用64位表示，需要宏定义。在DetourNavMesh.h中定义 #define DT_POLYREF64 1</p>
<p>这样tile就有28位了，不太存在超过上限的可能了。</p>
<p>发现问题。改完之后的dll在加载新地图的时候，内存直接飙升。</p>
<p>打印输出，定位到问题发生在，dtLoadNavMesh时读取到的tile的内存size值不正常，导致内存申请异常。</p>
<p>至此问题已经定位，navmesh文件格式和读取的格式不一致，数据错位，读取异常。</p>
<p>进一步跟踪，发现是C++ struct内存对齐不同导致的。客户端生成默认是8，服务器读取是按4，结果服务器少读4字节。</p>
<p>在DetourInit.h文件中有如下代码：#pragma pack(push,4) 控制，前后端修改一致即可。</p>
<p>ppt在GitHub上。<a href="https://github.com/zhangga/JAVAZSet">JavaZSet</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常见面试题</title>
    <url>/redis-pre/</url>
    <content><![CDATA[<div class=".article-gallery"><p>和Redis结缘还是2011年刚开始实习，做的第一款游戏《部落战争》，<br>就是使用的Redis作为持久层和缓存。 当时对Redis的认识还比较浅，但是Redis的好多特性已经开始慢慢了解。</p>
<p>这里推荐一下大神的Redis公众号。付磊。快手同事，《Redis开发与运维》一书的作者，强烈推荐这本书，偏向实战，另外一本很有名的书《Redis设计与实现》更注重原理。两本书都非常值得好好读下。</p>
<span id="more"></span>

<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4-576x1024.jpg?resize=640,1138" title="Redis常见面试题 - 第1张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4-576x1024.jpg?resize=640,1138" alt="Redis常见面试题 - 第1张  | 张嘎"></a></p>
<p><a href="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-576x1024.jpg?resize=576,1024" title="Redis常见面试题 - 第2张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-576x1024.jpg?resize=576,1024" alt="Redis常见面试题 - 第2张  | 张嘎"></a></p>
<h4 id="Memcached相比于Redis的主要特点有如下："><a href="#Memcached相比于Redis的主要特点有如下：" class="headerlink" title="Memcached相比于Redis的主要特点有如下："></a>Memcached相比于Redis的主要特点有如下：</h4><p>\1. 超高OPS：例如千万级别以上（线上千万OPS以上的Redis也存在）<br>\2. 多线程：抗热点能力强。<br>\3. 支持大value：例如Memcached 5支持100MB以上的value</p>
<p>但Memcached相比于Redis维护成本会更高，而且对于很多基础设施支持也不好（双机房、键值分析、内存优化、服务端高可用）。</p>
<p>最近发现KCC上出现Memcached滥用的情况</p>
<p>为防止滥用，必须满足如下规则才会开通：</p>
<p>\1. OPS: 超过100万<br>\2. big value：10MB+<br>\3. 明显热点<br>\4. CAS需求</p>
<p><strong>一、Redis常见的数据结构和使用场景</strong></p>
<p>(一)String 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></p>
<p>(二)hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<p>(三)list 使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p>
<p>(四)set 因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p>
<p>(五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。另外，参照另一篇<a href="http://link.zhihu.com/?target=https://www.cnblogs.com/rjzheng/p/8972725.html">《分布式之延时任务方案解析》</a>，该文指出了sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p>
<p><strong>二、Redis的hash怎么实现的</strong><br>满足以下两条件时：<br>1、键和值的长度都小于64字节<br>2、键值对数量小于512个<br>使用ziplist编码。不满足时转化为hashtable编码，并且这个转化过程是不可逆的。<br>hashtable的实现方式和Java的hashmap类似，数组上散列，散列冲突的使用链表，不同的是redis采用渐进式的rehash策略。<br>何为<strong>渐进式rehash</strong>？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。维护两张哈希表，1个索引来指示当前的rehash进度。<br>rehash是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。<br><strong>Java HashMap</strong>的rehash，每次创建一个数组（哈希表），一次性将old表rehash过去。</p>
<p><strong>三、为什么不能用Redis做专门的持久化</strong><br>性价比：内存吃紧 ，海量数据在重启后加载耗时。RDB加载快。<br>权限控制。<br>数据完整：MySQL 在崩溃处理，数据恢复方面比reids好。<br>redis作为数据库查询功能太弱。数据KV弱于结构化。<br>数据隔离。</p>
<h1 id="Redis-Cluster-功能限制"><a href="#Redis-Cluster-功能限制" class="headerlink" title="Redis Cluster|功能限制"></a>Redis Cluster|功能限制</h1><p>1.Key批量操作支持有限。目前只支持同slot内的key执行批量操作（如mget,mset）。</p>
<p>2.Key事务操作支持有限。只支持多key在同一个节点上的事务操作，多个key分布在不同节点上时无法使用事务功能。</p>
<p>3.Key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash，list等映射到不同节点。</p>
<p>4.不支持多数据库空间，集群模式下只能使用db0空间。</p>
<p>5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>
<h1 id="Redis-Cluster高可用"><a href="#Redis-Cluster高可用" class="headerlink" title="Redis Cluster高可用"></a>Redis Cluster高可用</h1><p>提供了灵活的节点扩容和收缩方案，在不影响集群对外服务的情况下进行。<br>自动故障转移保证集群可以正常对外提供服务。主观下线，客观下线，投票选举策略。选出从节点替换主节点，保证集群高可用。</p>
<p><strong>下面是两篇引用的文章。<a href="https://zhuanlan.zhihu.com/p/59168140">https://zhuanlan.zhihu.com/p/59168140</a></strong></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章?"></a>为什么写这篇文章?</h2><p>博主的<a href="http://link.zhihu.com/?target=http://www.cnblogs.com/rjzheng/p/8994962.html">《分布式之消息队列复习精讲》</a>得到了大家的好评，内心诚惶诚恐，想着再出一篇关于复习精讲的文章。但是还是要说明一下，复习精讲的文章偏面试准备，真正在开发过程中，还是脚踏实地，一步一个脚印，不要投机取巧。 考虑到绝大部分写业务的程序员，在实际开发中使用redis的时候，只会setvalue和getvalue两个操作，对redis整体缺乏一个认知。又恰逢博主某个同事下周要去培训redis，所以博主斗胆以redis为题材，对redis常见问题做一个总结，希望能够弥补大家的知识盲点。</p>
<h2 id="复习要点"><a href="#复习要点" class="headerlink" title="复习要点?"></a>复习要点?</h2><p>本文围绕以下几点进行阐述</p>
<ul>
<li>1、为什么使用redis</li>
<li>2、使用redis有什么缺点</li>
<li>3、单线程的redis为什么这么快</li>
<li>4、redis的数据类型，以及每种数据类型的使用场景</li>
<li>5、redis的过期策略以及内存淘汰机制</li>
<li>6、redis和数据库双写一致性问题</li>
<li>7、如何应对缓存穿透和缓存雪崩问题</li>
<li>8、如何解决redis的并发竞争问题</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h2><p><strong>分析</strong>:博主觉得在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p>
<p><strong>回答</strong>:如下所示，分为两点</p>
<p><strong>（一）性能</strong> 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。</p>
<p><a href="https://i0.wp.com/pic4.zhimg.com/80/v2-8200a2192b95b1596dc8d02c71b9abcf_hd.jpg?w=640&ssl=1" title="Redis常见面试题 - 第3张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/pic4.zhimg.com/80/v2-8200a2192b95b1596dc8d02c71b9abcf_hd.jpg?w=640&ssl=1" alt="Redis常见面试题 - 第3张  | 张嘎"></a></p>
<p><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。” 那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？ 根据《摩诃僧祗律》记载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure>

<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>
<p><strong>（二）并发</strong> 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>
<p><a href="https://i2.wp.com/pic3.zhimg.com/80/v2-ee0f4577491f13d82e185e7ef6aa8eae_hd.jpg?w=640&ssl=1" title="Redis常见面试题 - 第4张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/pic3.zhimg.com/80/v2-ee0f4577491f13d82e185e7ef6aa8eae_hd.jpg?w=640&ssl=1" alt="Redis常见面试题 - 第4张  | 张嘎"></a></p>
<h2 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h2><p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>
<p><strong>回答</strong>:主要是四个问题</p>
<ul>
<li>(一)缓存和数据库双写一致性问题</li>
<li>(二)缓存雪崩问题</li>
<li>(三)缓存击穿问题</li>
<li>(四)缓存的并发竞争问题</li>
</ul>
<p>这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>
<h2 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h2><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</p>
<p><strong>回答</strong>:主要是以下三点 (一)纯内存操作 (二)单线程操作，避免了频繁的上下文切换 (三)采用了非阻塞<strong>I/O多路复用机制</strong></p>
<p><strong>题外话：</strong>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。</p>
<p><strong>经营方式一</strong> 客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题 – 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递 – 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了 – 快递员之间的协调很花时间</p>
<p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</p>
<p><strong>经营方式二</strong> 小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p><strong>对比</strong> 上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。</p>
<p>在上述比喻中:</p>
<ul>
<li>每个快递员——————&gt;每个线程</li>
<li>每个快递——————–&gt;每个socket(I/O流)</li>
<li>快递的送达地点————–&gt;socket的不同状态</li>
<li>客户送快递请求————–&gt;来自客户端的请求</li>
<li>小曲的经营方式————–&gt;服务端运行的代码</li>
<li>一辆车———————-&gt;CPU的核数</li>
</ul>
<p>于是我们有如下结论</p>
<ol>
<li>经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。</li>
<li>经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</li>
</ol>
<p>下面类比到真实的redis线程模型，如图所示</p>
<p><a href="https://i0.wp.com/pic1.zhimg.com/80/v2-fa81e4bb9560b8ac6470bfa322f36a98_hd.jpg?w=640&ssl=1" title="Redis常见面试题 - 第5张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/pic1.zhimg.com/80/v2-fa81e4bb9560b8ac6470bfa322f36a98_hd.jpg?w=640&ssl=1" alt="Redis常见面试题 - 第5张  | 张嘎"></a></p>
<p>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>
<h2 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h2><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>
<p><strong>回答</strong>: redis采用的是定期删除+惰性删除策略。</p>
<p><strong>为什么不用定时删除策略?</strong> 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<p><strong>定期删除+惰性删除是如何工作的呢?</strong></p>
<p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p><strong>采用定期删除+惰性删除就没其他问题了么?</strong></p>
<p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。 在redis.conf中有一行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p>
<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong></p>
<p>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong></p>
<p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong></p>
<p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong></p>
<p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong> 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong> ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<h2 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h2><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p><strong>回答</strong>:<a href="http://link.zhihu.com/?target=https://www.cnblogs.com/rjzheng/p/9041659.html">《分布式之数据库和缓存双写一致性方案解析》</a>给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<h2 id="7、如何应对缓存穿透和缓存雪崩问题"><a href="#7、如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透和缓存雪崩问题"></a>7、如何应对缓存穿透和缓存雪崩问题</h2><p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>
<p><strong>回答</strong>:如下所示</p>
<p><strong>缓存穿透</strong>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p><strong>解决方案</strong>: (一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 (二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。 (三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<p><strong>缓存雪崩</strong>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p><strong>解决方案</strong>: (一)给缓存的失效时间，加上一个随机值，避免集体失效。 (二)使用互斥锁，但是该方案吞吐量明显下降了。 (三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 – I 从缓存A读数据库，有则直接返回 – II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 – III 更新线程同时更新缓存A和缓存B。</p>
<h2 id="8、如何解决redis的并发竞争key问题"><a href="#8、如何解决redis的并发竞争key问题" class="headerlink" title="8、如何解决redis的并发竞争key问题"></a>8、如何解决redis的并发竞争key问题</h2><p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p>
<p>**回答:**如下所示</p>
<p>(1)如果对这个key操作，<strong>不要求顺序</strong> 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</p>
<p>(2)如果对这个key操作，<strong>要求顺序</strong> 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>

<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
<h1 id="【原创】分布式之数据库和缓存双写一致性方案解析"><a href="#【原创】分布式之数据库和缓存双写一致性方案解析" class="headerlink" title="【原创】分布式之数据库和缓存双写一致性方案解析"></a><a href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></h1><h2 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h2><h3 id="为什么写这篇文章？"><a href="#为什么写这篇文章？" class="headerlink" title="为什么写这篇文章？"></a>为什么写这篇文章？</h3><p><a href="https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_getkeyflow.png?w=640&ssl=1" title="Redis常见面试题 - 第6张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_getkeyflow.png?w=640&ssl=1" alt="Redis常见面试题 - 第6张  | 张嘎"></a></p>
<p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>
<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。</p>
<h3 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h3><p>本文由以下三个部分组成<br>1、讲解缓存更新策略<br>2、对每种策略进行缺点分析<br>3、针对缺点给出改进方案</p>
<h2 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h2><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p>
<ol>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ol>
<p>应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。</p>
<h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h3 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong><br>伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">        db.updateData(data);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是<br>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除请求B写入对缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong><br>具体解决方案，且看博主对第(3)种更新策略的解析。</p>
<h3 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p><a href="https://i2.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png?w=640&ssl=1" title="Redis常见面试题 - 第7张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i2.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png?w=640&ssl=1" alt="Redis常见面试题 - 第7张  | 张嘎"></a></p>
<p><a href="https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png?w=640&ssl=1" title="Redis常见面试题 - 第8张  | 张嘎" class="gallery-item" style="box-shadow: none;"> <img src="https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png?w=640&ssl=1" alt="Redis常见面试题 - 第8张  | 张嘎"></a></p>
<p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。<br><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br><strong>然而，发生这种情况的概率又有多少呢？</strong><br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？<br><strong>如何解决上述并发问题？</strong><br>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。<br><strong>如何解决？</strong><br>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一</strong>：<br>如下图所示</p>
<p>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功<br>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。<br><strong>方案二</strong>：</p>
<p>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p>
<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1、<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect">主从DB与cache一致性</a><br>2、<a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏服务器网络库</title>
    <url>/servernet/</url>
    <content><![CDATA[<div class=".article-gallery"><p>最近在开发golang的游戏服网络库，基础开发已经完成，准备做性能测试，在思考测试用例的时候，参考了下主要网络库的测试场景，在这里做一下汇总。</p>
<h2 id="游戏网络库"><a href="#游戏网络库" class="headerlink" title="游戏网络库"></a>游戏网络库</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>通过封装TCP/UDP网络连接，向上层业务提供 <strong>可靠、易用</strong> 的网络库。</p>
<p>获取网络层的控制权，先于业务做一些探索并最终赋能业务。</p>
<span id="more"></span>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>易用性</li>
</ol>
<ul>
<li>遵循golang net的接口规范，保证通用性。</li>
<li>弱网环境下保证消息顺序、可靠，不需要业务层做额外工作。</li>
<li>可以发送可靠消息，TCP消息，UDP消息。</li>
<li>方便开启/关闭TCP/UDP以及双通道通信。</li>
</ul>
<ol start="2">
<li>可靠性</li>
</ol>
<ul>
<li>对网络连接进一步封装成逻辑连接(session)，将短时间内的断线重连作为同一个连接，对业务层透明。</li>
<li>保证任何情况下消息的可靠，在TCP/UDP上封装KCP，保证UDP的可靠，以及断线重连下同一个逻辑连接(不同的TCP连接)消息的可靠性。</li>
<li>支持上行/下行分别走不同的通道。</li>
<li>针对游戏大包下发的场景(如登录游戏，进入场景/副本等)，优先使用TCP发包。</li>
<li>根据网络时延自动选择TCP或UDP。</li>
<li>网络连接自动选择就近IP，登录到就近部署区域。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>针对游戏服务器特性在设计网络库的时候需要特别关注的一些地方：</p>
<ol>
<li>游戏业务重。在handler中处理一条消息业务的时候一般都涉及到I/O操作，如果同步执行的话，CPU主要消耗会在等待I/O操作上。此时handler必须要异步处理，这就涉及到上下文切换、I/O协作等需要考虑的代价。</li>
<li>过多长链接的问题。在使用golang net网路库设计框架时，一般都是新启一个协程goroutine去处理一个连接的read事件，在大量连接的情况下需要考虑协程的上下文切换开销，以及空闲连接占用的问题。</li>
<li>网络库在处理消息合包/拆包的情况下，对消息buffer的拷贝次数。常用的方案是RingBuffer和<a href="https://www.infoq.cn/article/fea7chf9moohbxbtyres">Nocopy Buffer</a>，参考netty和netpoll。</li>
<li>必须收到完整的数据包才可以继续处理，不能收到一半就开始处理。</li>
<li>水平触发、边缘触发，对编程模型的影响。</li>
</ol>
<h2 id="网络库性能调研"><a href="#网络库性能调研" class="headerlink" title="网络库性能调研"></a>网络库性能调研</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>现在的网络库基于golang/net实现，golang/net本身已经是一个简洁高效的网络库。</p>
<p>但在海量连接的业务场景下，特别是我们这种大网关的背景下，每个连接一组goroutine(一个接收消息的，一个发送消息的)，此时大量goroutine存在的情况下可能出现的问题：</p>
<ol>
<li><p>资源占有：消耗的资源就会呈线性趋势暴涨，首先给go runtime scheduler造成极大的压力和侵占系统资源，然后资源占用又反过来影响runtime的调度，导致性能下降。</p>
</li>
<li><p>网络抖动：在系统抖动时，大量网络请求断开并重连，伴随着的是大量协程的创建，退出的协程依旧在allg结构中，造成gc的扫描。</p>
</li>
<li><p>减少内存拷贝：新的网络库中解析过一次协议了，直接将buffer交给上层，减少copy。借鉴netpoll的设计，无锁且zero copy。</p>
</li>
<li><p>buffer扩容时copy原数组的问题，只能扩容无法缩容，占有大量内存。linkedbuffer。</p>
</li>
</ol>
<h3 id="常见开源库"><a href="#常见开源库" class="headerlink" title="常见开源库"></a>常见开源库</h3><h3 id="gnet"><a href="#gnet" class="headerlink" title="gnet"></a><a href="https://github.com/panjf2000/gnet">gnet</a></h3><p><a href="https://strikefreedom.top/go-netpoll-io-multiplexing-reactor">gnet介绍</a></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>海量连接，高频创建销毁。</p>
</li>
<li><p>高性能，低损耗。</p>
</li>
<li><p>支持TCP、UDP。</p>
</li>
<li><p>Multi-Reactors、Multi-Reactors+Goruntine Pool两种网络模型。</p>
</li>
</ul>
<h4 id="可借鉴优化"><a href="#可借鉴优化" class="headerlink" title="可借鉴优化"></a>可借鉴优化</h4><ul>
<li><p>🔲内置 goroutine 池，由开源库 <a href="https://github.com/panjf2000/ants">ants</a> 提供支持</p>
</li>
<li><p>🔲内置 bytes 内存池，由开源库 <a href="https://github.com/valyala/bytebufferpool">bytebufferpool</a> 提供支持</p>
</li>
<li><p>🔲高效、可重用而且自动伸缩的环形内存 buffer</p>
</li>
<li><p>🔲支持异步写操作</p>
</li>
</ul>
<h3 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a><a href="https://github.com/cloudwego/netpoll">netpoll</a></h3><p><a href="https://blog.csdn.net/ByteDanceTech/article/details/106066621?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-6-106066621.pc_agg_new_rank&utm_term=netpoll%E5%92%8Cgnet&spm=1000.2123.3001.4430">netpoll介绍</a></p>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>适合重业务的RPC。</p>
</li>
<li><p>高效连接池，管理连接状态。</p>
</li>
<li><p>协程池，控制goroutine。</p>
</li>
<li><p>内存管理。</p>
</li>
<li><p>NoCopy Buffer。</p>
</li>
</ul>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>不支持UDP。</li>
</ul>
<h4 id="可借鉴优化-1"><a href="#可借鉴优化-1" class="headerlink" title="可借鉴优化"></a>可借鉴优化</h4><ul>
<li><p>🔲丰富的测试场景</p>
</li>
<li><p>🔲<a href="https://github.com/cloudwego/netpoll/blob/main/nocopy_linkbuffer.go">LinkBuffer</a> 提供可以流式读写的 nocopy API</p>
</li>
<li><p>🔲<a href="https://github.com/bytedance/gopkg/tree/develop/util/gopool">gopool</a> 提供高性能的 goroutine 池</p>
</li>
<li><p>🔲<a href="https://github.com/bytedance/gopkg/tree/develop/lang/mcache">mcache</a> 提供高效的内存复用</p>
</li>
<li><p>🔲IsActive 支持检查连接是否存活</p>
</li>
</ul>
</div>]]></content>
      <categories>
        <category>服务器技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器性能优化</title>
    <url>/srv-optimize/</url>
    <content><![CDATA[<div class=".article-gallery"><p><em>在一些高QPS的场景下，服务器可能面临的挑战和问题总结。</em></p>
<ol>
<li>服务器一定要有流控功能和降级预案，一些接口可以提供有损服务，最差情况只要保证核心业务不出问题。</li>
<li>梳理出各个关键接口在不可用时的表现，和处理方案，已经可能面临的问题，落实到文档，一步步攻坚。</li>
<li>核心业务和接口预估最高QPS，根据QPS指标做好全链路压测。</li>
<li>做好性能监控和报警，实时查看大盘数据。</li>
<li>最常出现性能瓶颈的地方：<ul>
<li>登录，特别是注册新用户。流控限制服务的承载上限，一定不能超过当前服务的承载。流控触发后，前端进行友好的过渡，根据不同的游戏类型进行特定场景的处理，比如进行一局单机游戏。</li>
<li>针对一些更极端的场景，可预见的某个时间段，会有大量的用户登录和创建，前端不验证流控前，直接预先将登录进行打散。针对大量创建用户引起的数据库性能瓶颈问题，可以预先生成一大批新用户数据，放入缓存。</li>
<li>注意玩家退出或掉线的逻辑，是否有一些数据回写，判断是否会成为瓶颈。</li>
</ul>
</li>
<li>数据库可能出现问题的地方：<ul>
<li>Mongo 提前关闭autosplit，movechunk，retryWrites。</li>
<li>数据库连接要预热。</li>
</ul>
</li>
<li>前端要注意的一些点：<ul>
<li>提供1到2个备用的资源CDN。</li>
<li>服务器提供两个一级域名和几个二级域名让客户端随机选取使用。</li>
<li>考虑前端SDK一些接口遇到性能瓶颈的情况，特别是登录验证，做好预案和降级处理。</li>
</ul>
</li>
<li>日志在这种级别下也可能出现性能瓶颈，看下日志库还有没有可优化的地方，在最高峰可以允许短暂的将info级别日志关闭，流量下来之后尽快动态打开。</li>
<li>提前做好上线前的各种预案和上线流程，以及异常情况下的降级处理流程，责任到人，文档化，有迹可循，不慌乱。</li>
<li>检查最后是否还有遗漏的地方，特别是准备老用户或者压测未覆盖的场景，以及全服广播之类的。</li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>setroubleshootd引起的CPU高负载问题</title>
    <url>/setroubleshootd/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="记一次setroubleshootd进程引起的CPU高负载问题"><a href="#记一次setroubleshootd进程引起的CPU高负载问题" class="headerlink" title="记一次setroubleshootd进程引起的CPU高负载问题"></a>记一次setroubleshootd进程引起的CPU高负载问题</h2><p><a href="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2022-08/20220804145148-hCCDzh.jpg" title="20220804145148-hCCDzh" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/zhangga/gitment-comments/master/uPic/2022-08/20220804145148-hCCDzh.jpg" alt="20220804145148-hCCDzh"></a></p>
<p>上图可以看到CPU和内存在机器上都不正常</p>
<p><code>$ top</code>查看具体进程为<code>setroubleshootd</code></p>
<p>继续通过指令查看：<code>tail -f  /var/log/audit/audit.log</code></p>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type=SYSCALL msg=audit(1659596208.000:3732435): arch=c000003e syscall=4 success=no exit=-13 a0=7fd01c268280 a1=7fd01c267fc0 a2=7fd01c267fc0 a3=0 items=0 ppid=1 pid=75904 auid=4294967295 uid=986 gid=980 euid=986 suid=986 fsuid=986 egid=980 sgid=980 fsgid=980 tty=(none) ses=4294967295 comm=&quot;ftdc&quot; exe=&quot;/usr/bin/mongod&quot; subj=system_u:system_r:mongod_t:s0 key=(null)</span><br><span class="line">type=PROCTITLE msg=audit(1659596208.000:3732435): proctitle=2F7573722F62696E2F6D6F6E676F64002D66002F6574632F6D6F6E676F642E636F6E66</span><br><span class="line">type=AVC msg=audit(1659596208.000:3732436): avc:  denied  &#123; getattr &#125; for  pid=75904 comm=&quot;ftdc&quot; path=&quot;/sys/fs/fuse/connections&quot; dev=&quot;fusectl&quot; ino=1 scontext=system_u:system_r:mongod_t:s0 tcontext=system_u:object_r:fusefs_t:s0 tclass=dir permissive=0</span><br></pre></td></tr></table></figure>

<p>可以看到pid，并且是mongodb引起的。</p>
<p>继续查看mongodb的日志：<code>tail -f /var/log/messages</code></p>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**************************#012#012If you believe that mongod should be allowed getattr access on the cgroup directory by default.#012Then you should report this as a bug.#012You can generate a local policy module to allow this access.#012Do#012allow this access for now by executing:#012# ausearch -c &#x27;ftdc&#x27; --raw | audit2allow -M my-ftdc#012# semodule -i my-ftdc.pp#012</span><br><span class="line">Aug  3 23:58:48 localhost setroubleshoot: failed to retrieve rpm info for /sys/fs/cgroup</span><br><span class="line">Aug  3 23:58:48 localhost setroubleshoot: SELinux is preventing /usr/bin/mongod from search access on the directory /sys/fs/cgroup. For complete SELinux messages run: sealert -l 8df77a62-a31a-4213-8d52-f65ae3ffce6f</span><br><span class="line">Aug  3 23:58:48 localhost python: SELinux is preventing /usr/bin/mongod from search access on the directory /sys/fs/cgroup.#012#012*****  Plugin catchall (100. confidence) suggests   </span><br></pre></td></tr></table></figure>

<p>上面日志中可以看到原因是：<code>/usr/bin/mongod from search access on the directory /sys/fs/cgroup</code></p>
<p>并且提示了可以执行命令：<code>sealert -l 8df77a62-a31a-4213-8d52-f65ae3ffce6f</code> 查看完整信息。</p>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vmcommon fs]# sealert -l 8df77a62-a31a-4213-8d52-f65ae3ffce6f</span><br><span class="line"></span><br><span class="line">(setroubleshoot:123729): Gtk-WARNING **: 15:02:31.126: Locale not supported by C library.</span><br><span class="line">	Using the fallback &#x27;C&#x27; locale.</span><br><span class="line">SELinux is preventing /usr/bin/mongod from search access on the directory /sys/fs/cgroup.</span><br><span class="line"></span><br><span class="line">*****  Plugin catchall (100. confidence) suggests   **************************</span><br><span class="line"></span><br><span class="line">If you believe that mongod should be allowed search access on the cgroup directory by default.</span><br><span class="line">Then you should report this as a bug.</span><br><span class="line">You can generate a local policy module to allow this access.</span><br><span class="line">Do</span><br><span class="line">allow this access for now by executing:</span><br><span class="line"># ausearch -c &#x27;mongod&#x27; --raw | audit2allow -M my-mongod</span><br><span class="line"># semodule -i my-mongod.pp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Additional Information:</span><br><span class="line">Source Context                system_u:system_r:mongod_t:s0</span><br><span class="line">Target Context                system_u:object_r:cgroup_t:s0</span><br><span class="line">Target Objects                /sys/fs/cgroup [ dir ]</span><br><span class="line">Source                        mongod</span><br><span class="line">Source Path                   /usr/bin/mongod</span><br><span class="line">Port                          &lt;Unknown&gt;</span><br><span class="line">Host                          localhost.localdomain</span><br><span class="line">Source RPM Packages           mongodb-org-server-6.0.0-1.el7.x86_64</span><br><span class="line">Target RPM Packages</span><br><span class="line">Policy RPM                    selinux-policy-3.13.1-268.el7.noarch</span><br><span class="line">Selinux Enabled               True</span><br><span class="line">Policy Type                   targeted</span><br><span class="line">Enforcing Mode                Enforcing</span><br><span class="line">Host Name                     vmcommon</span><br><span class="line">Platform                      Linux vmcommon 3.10.0-1160.el7.x86_64 #1 SMP Mon</span><br><span class="line">                              Oct 19 16:18:59 UTC 2020 x86_64 x86_64</span><br><span class="line">Alert Count                   184449</span><br><span class="line">First Seen                    2022-08-02 11:11:38 CST</span><br><span class="line">Last Seen                     2022-08-04 14:52:59 CST</span><br><span class="line">Local ID                      8df77a62-a31a-4213-8d52-f65ae3ffce6f</span><br><span class="line"></span><br><span class="line">Raw Audit Messages</span><br><span class="line">type=AVC msg=audit(1659595979.0:3727845): avc:  denied  &#123; search &#125; for  pid=75904 comm=&quot;ftdc&quot; name=&quot;/&quot; dev=&quot;tmpfs&quot; ino=1164 scontext=system_u:system_r:mongod_t:s0 tcontext=system_u:object_r:cgroup_t:s0 tclass=dir permissive=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type=SYSCALL msg=audit(1659595979.0:3727845): arch=x86_64 syscall=statfs success=no exit=EACCES a0=5567cc31f9a0 a1=7fd01c267f40 a2=7fd01c2681a0 a3=0 items=0 ppid=1 pid=75904 auid=4294967295 uid=986 gid=980 euid=986 suid=986 fsuid=986 egid=980 sgid=980 fsgid=980 tty=(none) ses=4294967295 comm=ftdc exe=/usr/bin/mongod subj=system_u:system_r:mongod_t:s0 key=(null)</span><br><span class="line"></span><br><span class="line">Hash: mongod,mongod_t,cgroup_t,dir,search</span><br></pre></td></tr></table></figure>

<ul>
<li>具体原因是因为安装的MongoDB 6版本需要的SELinux的问题，具体可以查看官网文档：</li>
</ul>
<p><a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-red-hat/#configure-selinux">configure-selinux</a></p>
<h3 id="还有一种情况需要注意"><a href="#还有一种情况需要注意" class="headerlink" title="还有一种情况需要注意"></a>还有一种情况需要注意</h3><p>之前mongodb启动进程的文件<code>/tmp/mongodb-27017.sock</code>权限不是用户mongod的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ll /tmp/</span><br><span class="line">total 824</span><br><span class="line">drwxr-xr-x. 2 root  root      18 Aug  1 21:33 hsperfdata_root</span><br><span class="line">-rwx------. 1 root  root     836 Aug  1 21:36 ks-script-0MAoJL</span><br><span class="line">-rwx------. 1 root  root    1237 Aug  1 21:36 ks-script-EGB51o</span><br><span class="line">srwx------. 1 root  root       0 Aug  4 15:44 mongodb-27017.sock</span><br></pre></td></tr></table></figure>

<p>需要把<code>/tmp/mongodb-27017.sock</code>这个文件删除后再尝试启动mongo</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN/Git 差异比对插件</title>
    <url>/svn-git-diff/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>系统环境：Windows10、Office套件。公司电脑已默认安装。</p>
<p>必备软件：<a href="https://osdn.net/projects/tortoisesvn/storage/1.14.1/Application/TortoiseSVN-1.14.1.29085-x64-svn-1.14.1.msi/">TortoiseSVN</a>或<a href="https://tortoisegit.org/download/">TortoiseGit</a>。大部分人应该已安装。</p>
<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p><strong>方法一</strong>、</p>
<p>下载bat文件到本地，鼠标右键点击，以管理员身份运行即可。</p>
<p>diff-xlsx-ssc.bat</p>
<p>👇👇👇👇👇</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">CHCP 65001</span><br><span class="line"></span><br><span class="line">:: 系统环境变量</span><br><span class="line"><span class="built_in">set</span> ENV_PATH=%PATH%</span><br><span class="line">@<span class="built_in">echo</span> ====current environment：</span><br><span class="line">@<span class="built_in">echo</span> %ENV_PATH%</span><br><span class="line"></span><br><span class="line">:: 启用命令扩展</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> svnStr=SVN</span><br><span class="line"><span class="built_in">set</span> gitStr=Git</span><br><span class="line">:: 调用这个方法，传入字符串ENV_PATH和要查找的字符串svnStr。lens是它的返回值</span><br><span class="line">call :getSubIndex ENV_PATH svnStr lensSvn</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%lensSvn%&quot;</span>==<span class="string">&quot;&quot;</span> (</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;没有找到SVN&quot;</span></span><br><span class="line">	goto :notSetSVN</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;找到TortoiseSVN环境变量&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:: 替换svn的js文件</span><br><span class="line">call :getLastIndex ENV_PATH lensSvn svnPath</span><br><span class="line"><span class="built_in">set</span> svnDiffPath=<span class="string">&quot;%svnPath%\Diff-Scripts\diff-xls.js&quot;</span></span><br><span class="line"><span class="built_in">echo</span> %svnDiffPath%</span><br><span class="line">call :writeJSFile svnDiffPath</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;成功设置SVN&quot;</span></span><br><span class="line"></span><br><span class="line">:notSetSVN</span><br><span class="line"></span><br><span class="line">call :getSubIndex ENV_PATH gitStr lensGit</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%lensGit%&quot;</span>==<span class="string">&quot;&quot;</span> (</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;没有找到Git&quot;</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;找到TortoiseGit环境变量&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:: 替换git的js文件</span><br><span class="line">call :getLastIndex ENV_PATH lensGit gitPath</span><br><span class="line"><span class="built_in">set</span> gitDiffPath=<span class="string">&quot;%gitPath%\Diff-Scripts\diff-xls.js&quot;</span></span><br><span class="line"><span class="built_in">echo</span> %gitDiffPath%</span><br><span class="line">call :writeJSFile gitDiffPath</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;成功设置Git&quot;</span></span><br><span class="line"></span><br><span class="line">:notSetGit</span><br><span class="line"></span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> /b</span><br><span class="line">:getLastIndex</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> /A len+=%2</span><br><span class="line"><span class="built_in">set</span> value=</span><br><span class="line">:strLen_LoopIndex</span><br><span class="line">	<span class="built_in">set</span> /A num=len-1</span><br><span class="line">	<span class="keyword">if</span> not <span class="string">&quot;!%1:~%num%,1!&quot;</span>==<span class="string">&quot;&quot;</span> (</span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;!%1:~%num%,1!&quot;</span>==<span class="string">&quot;;&quot;</span> (</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;%value%&quot;</span></span><br><span class="line">			endlocal &amp; <span class="built_in">set</span> %3=%value%</span><br><span class="line">		) <span class="keyword">else</span> (</span><br><span class="line">			<span class="built_in">set</span> /A len=len-1</span><br><span class="line">			<span class="built_in">set</span> value=!%1:~%num%,1!%value%</span><br><span class="line">			goto :strLen_LoopIndex</span><br><span class="line">		)</span><br><span class="line">	) <span class="keyword">else</span> (</span><br><span class="line">		endlocal &amp; <span class="built_in">set</span> %3=%value%</span><br><span class="line">	)</span><br><span class="line"><span class="built_in">exit</span> /b</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> /b</span><br><span class="line">:getSubIndex</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">:strLen_Loop</span><br><span class="line">    <span class="built_in">set</span> /A len+=1</span><br><span class="line">    <span class="built_in">set</span> /A len1+=0</span><br><span class="line">    <span class="built_in">set</span> /A num=len-1</span><br><span class="line">    ::判断传入第二个参数要查找的字符是否已经遍历到了结尾，如果结尾了就说明匹配到了</span><br><span class="line">    <span class="keyword">if</span> not <span class="string">&quot;!%2:~%len1%!&quot;</span>==<span class="string">&quot;&quot;</span> (</span><br><span class="line">    ::判断第一个传入的字符串是否已经遍历到了结尾</span><br><span class="line">    <span class="keyword">if</span> not <span class="string">&quot;!%1:~%num%!&quot;</span>==<span class="string">&quot;&quot;</span> (</span><br><span class="line">        <span class="keyword">if</span> not <span class="string">&quot;!%2:~%len1%!&quot;</span>==<span class="string">&quot;&quot;</span> (</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;!%1:~%num%,1!&quot;</span>==<span class="string">&quot;!%2:~%len1%,1!&quot;</span> (</span><br><span class="line">				<span class="built_in">set</span> /A len1=len1+1</span><br><span class="line">            ) <span class="keyword">else</span> (</span><br><span class="line">                <span class="built_in">set</span> /A len1=0</span><br><span class="line">            )</span><br><span class="line">            goto :strLen_Loop</span><br><span class="line">        ) <span class="keyword">else</span> (</span><br><span class="line">			endlocal &amp; <span class="built_in">set</span> %3=%num%</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">    ) <span class="keyword">else</span> (</span><br><span class="line">        endlocal &amp; <span class="built_in">set</span> %3=%num%</span><br><span class="line">    )</span><br><span class="line"><span class="built_in">exit</span> /b</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> /b</span><br><span class="line">:writeJSFile</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">more +109 %~dp0\diff-xlsx-ssc.bat &gt; !%1!</span><br><span class="line"><span class="built_in">exit</span> /b</span><br><span class="line"></span><br><span class="line">:: js比对脚本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var objArgs = WScript.Arguments;</span><br><span class="line"><span class="keyword">if</span> (objArgs.length &lt; 2)</span><br><span class="line">&#123;</span><br><span class="line">    Abort(<span class="string">&quot;Usage: [CScript | WScript] diff-xls.js base.xls new.xls&quot;</span>, <span class="string">&quot;Invalid arguments&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sBaseDoc = objArgs(0);</span><br><span class="line">var sNewDoc = objArgs(1);</span><br><span class="line"></span><br><span class="line">var objScript = new ActiveXObject(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (objScript.GetBaseName(sBaseDoc) === objScript.GetBaseName(sNewDoc))</span><br><span class="line">&#123;</span><br><span class="line">    Abort(<span class="string">&quot;File &#x27;&quot;</span> + sBaseDoc + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + sNewDoc + <span class="string">&quot;&#x27; is same file name.\nCannot compare the documents.&quot;</span>, <span class="string">&quot;Same file name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!objScript.FileExists(sBaseDoc))</span><br><span class="line">&#123;</span><br><span class="line">    Abort(<span class="string">&quot;File &#x27;&quot;</span> + sBaseDoc + <span class="string">&quot;&#x27; does not exist.\nCannot compare the documents.&quot;</span>, <span class="string">&quot;File not found&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!objScript.FileExists(sNewDoc))</span><br><span class="line">&#123;</span><br><span class="line">    Abort(<span class="string">&quot;File &#x27;&quot;</span> + sNewDoc + <span class="string">&quot;&#x27; does not exist.\nCannot compare the documents.&quot;</span>, <span class="string">&quot;File not found&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sBaseDoc = objScript.GetAbsolutePathName(sBaseDoc);</span><br><span class="line">sNewDoc = objScript.GetAbsolutePathName(sNewDoc);</span><br><span class="line">var sTempFolder = objScript.GetSpecialFolder(2)</span><br><span class="line">var sTempFile = <span class="string">&quot;D:\\temp.txt&quot;</span></span><br><span class="line">objScript = null;</span><br><span class="line"></span><br><span class="line">var fs = new ActiveXObject(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>);</span><br><span class="line">var f = fs.CreateTextFile(sTempFile, 2, <span class="literal">true</span>)</span><br><span class="line">f.WriteLine(sBaseDoc)</span><br><span class="line">f.WriteLine(sNewDoc)</span><br><span class="line">f.close()</span><br><span class="line">fs = null</span><br><span class="line">f = null</span><br><span class="line"></span><br><span class="line">WScript</span><br><span class="line">var objShell = new ActiveXObject(<span class="string">&quot;WScript.Shell&quot;</span>);</span><br><span class="line">objShell.run(<span class="string">&#x27;&quot;C:\\Program Files\\Microsoft Office\\root\\Client\\AppVLP.exe&quot; &quot;C:\\Program Files (x86)\\Microsoft Office\\Office16\\DCF\\SPREADSHEETCOMPARE.EXE&quot; &quot;D:\\temp.txt&quot;&#x27;</span>, 0, <span class="literal">true</span>)</span><br><span class="line">objShell = null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>、</p>
<ol>
<li><p>下载文件保存到本地磁盘D目录下：</p>
<p>diff-xlsx-ssc.vbs</p>
</li>
</ol>
<p>👇👇👇👇👇</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">Option</span> <span class="keyword">Explicit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> objArgs</span><br><span class="line"><span class="keyword">Set</span> objArgs = WScript.Arguments</span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> num</span><br><span class="line">num = objArgs.Count</span><br><span class="line"><span class="keyword">If</span> num &lt; <span class="number">2</span> <span class="keyword">Then</span></span><br><span class="line">    MsgBox <span class="string">&quot;Usage: [CScript | WScript] diff-xlsx.vbs base.xlsx new.xlsx&quot;</span>, vbExclamation, <span class="string">&quot;Invalid arguments&quot;</span></span><br><span class="line">    WScript.Quit <span class="number">1</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> sBaseFile, sNewFile</span><br><span class="line">sBaseFile = objArgs(<span class="number">0</span>)</span><br><span class="line">sNewFile = objArgs(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">Set</span> objArgs = <span class="literal">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> objFileSystem</span><br><span class="line"><span class="keyword">Set</span> objFileSystem = <span class="built_in">CreateObject</span>(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>)</span><br><span class="line"><span class="keyword">If</span> objFileSystem.FileExists(sBaseFile) = <span class="literal">False</span> <span class="keyword">Then</span></span><br><span class="line">    MsgBox <span class="string">&quot;File &quot;</span> + sBaseFile + <span class="string">&quot; does not exist.  Cannot compare the files.&quot;</span>, vbExclamation, <span class="string">&quot;File not found&quot;</span></span><br><span class="line">    WScript.Quit <span class="number">1</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"><span class="keyword">If</span> objFileSystem.FileExists(sNewFile) = <span class="literal">False</span> <span class="keyword">Then</span></span><br><span class="line">    MsgBox <span class="string">&quot;File &quot;</span> + sNewFile + <span class="string">&quot; does not exist.  Cannot compare the files.&quot;</span>, vbExclamation, <span class="string">&quot;File not found&quot;</span></span><br><span class="line">    WScript.Quit <span class="number">1</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;Compare file size</span></span><br><span class="line"><span class="keyword">Dim</span> fBaseFile, fNewFile, sTempFolder, sTempFile</span><br><span class="line"><span class="keyword">Set</span> fBaseFile = objFileSystem.GetFile(sBaseFile)</span><br><span class="line"><span class="keyword">Set</span> fNewFile = objFileSystem.GetFile(sNewFile)</span><br><span class="line">sTempFolder = objFileSystem.GetSpecialFolder(<span class="number">2</span>)</span><br><span class="line">sTempFile = sTempFolder + <span class="string">&quot;\temp.txt&quot;</span></span><br><span class="line"><span class="keyword">Set</span> objFileSystem = <span class="literal">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;Create temp.txt for save path of 2 xlsx files</span></span><br><span class="line"><span class="keyword">Dim</span> fs, f</span><br><span class="line"><span class="keyword">Set</span> fs = WScript.<span class="built_in">CreateObject</span>(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>)</span><br><span class="line"><span class="keyword">Set</span> f = fs.CreateTextFile(sTempFile, <span class="number">2</span>, <span class="literal">True</span>)</span><br><span class="line">f.WriteLine sBaseFile</span><br><span class="line">f.WriteLine sNewFile</span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">Set</span> fs = <span class="literal">Nothing</span></span><br><span class="line"><span class="keyword">Set</span> f = <span class="literal">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#x27;Compare files using SPREADSHEETCOMPARE.exe</span></span><br><span class="line"><span class="keyword">Dim</span> WshShell, result</span><br><span class="line"><span class="keyword">Set</span> WshShell = WScript.<span class="built_in">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line"><span class="comment">&#x27;Old office version 2016?</span></span><br><span class="line"><span class="comment">&#x27;result = WshShell.Run(&quot;&quot;&quot;C:\Program Files (x86)\Microsoft Office\Office16\DCF\SPREADSHEETCOMPARE.exe&quot;&quot; &quot; &amp; sTempFile, 0, True)</span></span><br><span class="line"><span class="comment">&#x27;Office 365</span></span><br><span class="line"><span class="comment">&#x27;Could be this result = WshShell.Run(&quot;&quot;&quot;C:\Program Files\Microsoft Office\root\vfs\ProgramFilesX86\Microsoft Office\Office16\DCF\SPREADSHEETCOMPARE.EXE&quot;&quot; &quot; &amp; sTempFile, 0, True)</span></span><br><span class="line">result = WshShell.Run(<span class="string">&quot;&quot;&quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft Office Tools\Spreadsheet Compare&quot;&quot; &quot;</span> &amp; sTempFile, <span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">Set</span> WshShell = <span class="literal">Nothing</span></span><br><span class="line"></span><br><span class="line">WScript.Quit</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>找个空白地方鼠标右键 -&gt; TortoiseSVN -&gt; Settings -&gt; Diff Viewer -&gt; Advanced</p>
<p><a href="https://imgtu.com/i/5YUreU"><a href="https://z3.ax1x.com/2021/10/17/5YUreU.md.png" title="5YUreU.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5YUreU.md.png" alt="5YUreU.md.png"></a></a></p>
</li>
<li><p>修改.xlsx 的值为 <code>wscript.exe &quot;D:\diff-xlsx-ssc.vbs&quot; %base %mine //E:vbscript</code></p>
<p><a href="https://imgtu.com/i/5YUBLT"><a href="https://z3.ax1x.com/2021/10/17/5YUBLT.png" title="5YUBLT.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5YUBLT.png" alt="5YUBLT.png"></a></a></p>
</li>
</ol>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>和SVN/Git工具比对文件的操作一样：</p>
<blockquote>
<p>鼠标右键点击文件 -&gt; TortoiseSVN -&gt; Show log</p>
<p>选择要比对差异的版本</p>
<p>右键点击要查看的excel文件 -&gt; Show changes</p>
</blockquote>
<p>比对结果如下图：</p>
<p><a href="https://imgtu.com/i/5YadtH"><a href="https://z3.ax1x.com/2021/10/17/5YadtH.png" title="5YadtH.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/17/5YadtH.png" alt="5YadtH.png"></a></a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/UDP</title>
    <url>/tcp/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="TCP常见面试题"><a href="#TCP常见面试题" class="headerlink" title="TCP常见面试题"></a>TCP常见面试题</h2><p><a href="https://zhuanlan.zhihu.com/p/388704023">TCP</a></p>
<h4 id="TCP协议问题"><a href="#TCP协议问题" class="headerlink" title="TCP协议问题"></a>TCP协议问题</h4><ul>
<li>连接<ul>
<li>三次握手<ul>
<li>费时：4G网络(3*100ms)</li>
<li>费力：3个数据包</li>
<li>优化：<a href="https://zh.wikipedia.org/zh/TCP%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80">TCP Fast Open</a></li>
</ul>
</li>
<li>半连接(初始化连接SYN超时)<ul>
<li>耗费网络资源：5次重发SYN-ACK包</li>
<li>耗费服务器资源：63秒后断开连接(TIME_WAIT = 2*MSL)</li>
<li>易被攻击：<a href="https://www.jianshu.com/p/6eae45826754">SYN flood拒绝服务攻击</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>断开</p>
<ul>
<li>TIME_WAIT状态<ul>
<li>2*MSL：sudo sysctl -a | grep time_wait</li>
<li>服务器：TIME_WAIT连接，占用机器的内存资源</li>
<li>客户端：TIME_WAIT连接，占用TCP协议的端口</li>
</ul>
</li>
<li>优化<ul>
<li>连接本机服务，首选UNIX域套接字，<a href="https://jaminzhang.github.io/network/the-difference-between-unix-domain-socket-and-tcp-ip-socket/">提高通信效率</a>，也避免浪费TCP端口</li>
<li>加快回收：sudo sysctl -w net.ipv4.tcp_tw_recycle = 1</li>
<li>连接复用：sudo sysctl -w net.ipv4.tcp_tw_reuse = 1</li>
</ul>
</li>
</ul>
</li>
<li><p>传输</p>
<ul>
<li>保序机制：流式交付，前序包阻塞</li>
<li>确认机制：<ul>
<li>延迟确认：滑动窗口停等，降低吞吐率</li>
<li>快速确认：消耗带宽</li>
<li>优化：快速确认和延迟确认两种模式自动切换</li>
</ul>
</li>
<li>超时重传：<ul>
<li>默认：必须等待RTO(Retransmission TimeOut )超时，不能快速响应当前网络状况</li>
<li>每次RTO超时导致重传后，RTO值翻倍，一直尝试tcp_retries2次重传</li>
<li>优化：<a href="https://zhuanlan.zhihu.com/p/25596865">快速重传</a>（收到3个重复的ACK即开始重传）</li>
</ul>
</li>
<li>重传数量：<ul>
<li>默认：发送方重传收到的ACK之后所有已发送的数据包，浪费带宽</li>
<li>优化：<a href="https://zhuanlan.zhihu.com/p/25596865">选择确认</a>（只重传SACK中缺少的数据包）</li>
</ul>
</li>
</ul>
</li>
<li><p>流量控制：</p>
<ul>
<li><p>糊涂窗口综合症</p>
<p>：接收方每次只处理小包，或者发送方一直发送小包</p>
<ul>
<li>优化：<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">David D Clark算法（接收端）；Nagle算法（发送端）</a>（默认打开）</li>
</ul>
</li>
<li><p>Nagle算法 + 延迟确认</p>
<p>：Http Server中Write-Write-Read模式下的40ms延迟</p>
<ul>
<li>优化：设置TCP_NODELAY选项，禁用Nagle算法</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞控制（Reno算法）：</p>
<ul>
<li>概念：<ul>
<li>RTT（Round Trip Time）：往返时间（从数据包发出到收到ACK的时间）</li>
<li>RTO（Retransmission Time）：重传时间（根据RTT动态调整，作为重传定时器的超时时间，收到ACK后重置连接的重传定时器）</li>
</ul>
</li>
<li>慢启动（指数增长）<ul>
<li>每个RTT内，cwnd随收到的ACK线性自增；每个RTT后，cwnd翻倍增长</li>
<li>丢包，或者cwnd超过慢启动门限ssthresh：进入拥塞避免阶段</li>
</ul>
</li>
<li>拥塞避免（退半避让，线性增长）<ul>
<li>丢包<ul>
<li>RTO超时：ssthresh降为cwnd/2，cwnd降为1，重新进入慢启动过程</li>
<li>3个重复ACK：进入快速重传阶段</li>
</ul>
</li>
<li>cwnd超过ssthresh：<ul>
<li>每个RTT内，cwnd随收到的ACK增长1/cwnd个MSS；每个RTT后，cwnd增长1个MSS</li>
</ul>
</li>
</ul>
</li>
<li>快速重传<ul>
<li>ssthresh降为cwnd/2，cwnd降为ssthresh，进入快速恢复阶段</li>
</ul>
</li>
<li>快速恢复<ul>
<li>cwnd设置为ssthresh+3，重传重复ACK指定的数据包</li>
<li>收到重复ACK：cwnd自增</li>
<li>收到新的非重复ACK：cwnd置为快速重传阶段的初始ssthresh，进入拥塞避免阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-协议调优"><a href="#TCP-协议调优" class="headerlink" title="TCP 协议调优"></a>TCP 协议调优</h4><ul>
<li><p>setsockopt</p>
<ul>
<li>SOL_SOCKET</li>
</ul>
</li>
<li><p>```<br>SO_KEEPALIVE：TCP心跳（生效与否还取决于tcp_keepalive_xxx）</p>
<p>SO_LINGER：设置close行为（FIN or RST，TIME_WAIT or not）</p>
<p>SO_RCVBUF：设置接收缓存，覆盖tcp_rmem</p>
<p>SO_SNDBUF：设置发送缓存，覆盖tcp_wmem</p>
<p>SO_REUSERADDR：设置地址重用</p>
<pre><code>1. 多块网卡多个地址，通配符bind

2. 重用处于TIME_WAIT状态的socket地址
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  IPPROTO_TCP</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  TCP_NODELAY：禁用Nagle算法，减少发送延时</span><br><span class="line">  </span><br><span class="line">  TCP_DEFER_ACCEPT：减少一次握手（仅限于Linux系统之间）</span><br></pre></td></tr></table></figure>

<p>握手</p>
<ul>
<li><p>```<br>net.ipv4.tcp_syn_retries：客户端请求连接syn重试次数</p>
<p>net.ipv4.tcp_synack_retries：服务器回复syn+ack重试次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  半连接队列</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  半连接队列溢出：</span><br><span class="line">  </span><br><span class="line">  netstat -s | grep LISTEN</span><br><span class="line">  </span><br><span class="line">  4375 SYNs to LISTEN sockets dropped</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  半连接队列调优：</span><br><span class="line">  </span><br><span class="line">  net.ipv4.tcp_max_syn_backlog：SYN队列长度</span><br><span class="line">  </span><br><span class="line">  net.ipv4.tcp_syncookies：SYN队列溢出时向对方发送syncookies，防范SYNFlood攻击</span><br></pre></td></tr></table></figure>

<p>全连接队列</p>
</li>
</ul>
</li>
<li><p>```<br>全连接队列溢出：</p>
<p>netstat -s | grep listen</p>
<p>22438 times the listen queue of a socket overflowed</p>
<p>全连接队列调优：</p>
<p>net.core.somaxcon：同listen()的backlog共同决定accept队列长度:min(backlog,somaxconn) </p>
<p>net.ipv4.tcp_abort_on_overflow：accept队列溢出的处理方式</p>
<pre><code>默认关闭：服务器accept队列溢出后，直接丢弃客户端的ACK。待RTO超时后，重发SYN+ACK给客户端（不超过net.ipv4.tcp_synack_retries次）。

打开该选项：服务器accept队列溢出后，直接发送RST给客户端（connection reset by peer）。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  缓存</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  net.ipv4.tcp_wmem：发送缓存</span><br><span class="line">  </span><br><span class="line">  net.ipv4.tcp_rmem：接收缓存</span><br><span class="line">  </span><br><span class="line">  net.ipv4.tcp_moderate_rcvbuf：接收缓存自动伸缩</span><br></pre></td></tr></table></figure>

<p>心跳</p>
</li>
<li><p>```<br>net.ipv4.tcp_keepalive_time：正常心跳间隔</p>
<p>net.ipv4.tcp_keepalive_intvl：失败重试间隔</p>
<p>net.ipv4.tcp_keepalive_probes：失败重试次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  TIME_WAIT</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  net.ipv4.tcp_max_tw_buckets：处于TIME_WAIT状态的socket数上限</span><br><span class="line">  </span><br><span class="line">  net.ipv4.tcp_tw_recycle：是否尽快回收TIME_WAIT状态的socket</span><br><span class="line">  </span><br><span class="line">  net.ipv4.tcp_tw_reuse：是否尽量重用TIME_WAIT状态的socket</span><br><span class="line">  </span><br><span class="line">  net.netfilter.nf_conntrack_tcp_timeout_time_wait：socket处于TIME_WAIT状态的时间</span><br></pre></td></tr></table></figure>

<p>其他</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout：连接主动断开方等待对端FIN包的最大时间</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_sack：选择ACK开关</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_timestamps：TCP时间戳开关（在TCP包头增加12个字节，能够识别超时重发包，计算RTT更精确）</span><br></pre></td></tr></table></figure>

<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>速度快<ul>
<li>跨运营商网络的情况下，UDP有可能比TCP块120倍</li>
</ul>
</li>
<li>穿越强<ul>
<li><a href="https://zh.wikipedia.org/wiki/UDP%E6%89%93%E6%B4%9E">UDP 打洞</a></li>
</ul>
</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>传输不可靠<ul>
<li>应用层要设计<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82">ARQ协议</a>，应对丢包</li>
</ul>
</li>
<li>需要考虑数据包大小<ul>
<li>应用层要规划数据包大小，避免IP层分片影响传输效率</li>
<li>应用层MTU多大合适？<ul>
<li>UDP包数据段：2^16-1-8-20=65507</li>
<li>局域网（Ethernet）：1500-8-20=1472</li>
<li>广域网（Internet）：576-8-20=548</li>
<li>游戏常用，便于记忆：500</li>
</ul>
</li>
</ul>
</li>
<li>简单模型低效，高性能编程复杂</li>
</ul>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>UE DS服管理</title>
    <url>/ue_ds_manager/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="场景服管理"><a href="#场景服管理" class="headerlink" title="场景服管理"></a>场景服管理</h1><h2 id="场景服v1-0"><a href="#场景服v1-0" class="headerlink" title="场景服v1.0"></a>场景服v1.0</h2><p>场景服最初的流程如下：</p>
<ul>
<li>ds除了战场外，还会根据启动参数，跑ping</li>
<li>一个Pod下多个战场进程，父进程fork固定数量的子进程</li>
<li>战场进程将自己注册到etcd中，key: $namespace/$service_type/$ip:$port/$version，通过租约和进程退出时删除key来保证key的时效</li>
<li>场景服watch etcd中注册的key，来感知当前战场</li>
<li>战场分配时通过抢占stateKey: $namespace/$service_type/$ip:$port/$version/state</li>
<li>抢占到state后，表示战场被分配，场景服和战场服建立连接，剩下的就是业务上的内容：初始化战场、玩家数据，战场结算等<br>优势：<br>流程简单<br>局限：</li>
<li>etcd注册的key太多</li>
<li>战场和场景服的连接过多</li>
<li>缺少战场管理，只有简单的注册和分配。无法实现自动扩缩容</li>
</ul>
<p>注意：</p>
<h2 id="加入Agones"><a href="#加入Agones" class="headerlink" title="加入Agones"></a>加入Agones</h2><h2 id="场景服v2-0"><a href="#场景服v2-0" class="headerlink" title="场景服v2.0"></a>场景服v2.0</h2></div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>DS共享内存和多GameInstance性能对比</title>
    <url>/ue-multiworld-fork/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h1><p>DS服目前使用共享内存（Fork）方案，一核可以跑25个，压测数据如下：<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-1.9kgkm6ldpf.webp" title="insight-1" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-1.9kgkm6ldpf.webp" alt="insight-1"></a><br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-2.8z6wzvvqoh.webp" title="insight-2" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-2.8z6wzvvqoh.webp" alt="insight-2"></a><br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-3.13m62jc2gh.webp" title="insight-3" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-3.13m62jc2gh.webp" alt="insight-3"></a><br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-4.3ns0f6e9ym.webp" title="insight-4" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-4.3ns0f6e9ym.webp" alt="insight-4"></a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>CPU总核</td>
<td>16c * 4</td>
</tr>
<tr>
<td>内存总量</td>
<td>64g * 4</td>
</tr>
<tr>
<td>机器人数量</td>
<td>4800</td>
</tr>
<tr>
<td>营地数量</td>
<td>1600</td>
</tr>
<tr>
<td>CPU最大占用</td>
<td>&lt;60%</td>
</tr>
<tr>
<td>内存最大占用</td>
<td>&lt;75%</td>
</tr>
</tbody></table>
<h1 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h1><p>当前DS服使用 <strong>16c*64g ​</strong>的机型，核心目标是降低内存占用，最终适配1:2的标配机型。</p>
<h1 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h1><p>鉴于多 GameInstance 与共享内存两种方案各有优劣，需通过实际跑测获取 CPU 占用、内存开销、稳定性等核心性能数据，基于准确对比结果确定最终技术方案。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>共享内存（Fork）</th>
<th>单进程多GameInstance</th>
</tr>
</thead>
<tbody><tr>
<td>内存共享方式</td>
<td>物理内存页级共享（COW）</td>
<td>资源只加载一份</td>
</tr>
<tr>
<td>内存开销</td>
<td>有COW的额外内存页开销</td>
<td>无额外开销，资源内存共享，逻辑数据全部分离</td>
</tr>
<tr>
<td>资源加载</td>
<td>父进程预加载，子进程共享</td>
<td>进程内加载一次，所有实例复用</td>
</tr>
<tr>
<td>隔离级别</td>
<td>进程级隔离（崩溃不扩散，tick间相互没影响）</td>
<td>实例级隔离（崩溃影响所有实例，tick卡顿影响其他实例）</td>
</tr>
<tr>
<td>游戏测试</td>
<td>无额外负担</td>
<td>多个Instance被分配到同一个进程下，可能和分配到不同进程下，表现不一致（数据没隔离的bug）</td>
</tr>
<tr>
<td>实例分配</td>
<td>无额外负担</td>
<td>更加复杂的分配和释放实例的策略</td>
</tr>
</tbody></table>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>DS版本：`LinuxServer_Trunk-Testxxxx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:                         x86_64</span><br><span class="line">CPU(s):                               32</span><br><span class="line">Model name:                           Intel(R) Xeon(R) Gold 6462C</span><br><span class="line">Thread(s) per core:                   2</span><br><span class="line">Core(s) per socket:                   16</span><br><span class="line">Socket(s):                            1</span><br><span class="line">CPU MHz:                              3899.634</span><br><span class="line">CPU max MHz:                          3900.0000</span><br><span class="line">CPU min MHz:                          800.0000</span><br><span class="line">L1d cache:                            768 KiB</span><br><span class="line">L1i cache:                            512 KiB</span><br><span class="line">L2 cache:                             32 MiB</span><br><span class="line">L3 cache:                             60 MiB</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            60Gi        16Gi       3.0Gi        17Gi        41Gi        26Gi</span><br><span class="line">Swap:             0B          0B          0B</span><br></pre></td></tr></table></figure>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>45个玩家分成15支队伍，进入15个DS服，在其中不停地移动和更换装备（这个用例的操作频率是要远高于线上玩家正常操作的）。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>启动15个子进程，每个进程为一个营地实例</p>
<ul>
<li>父进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">game     2415317 2415299  1 14:27 ?        00:00:03 /data00/ds/Latest/MyProject/Binaries/Linux/MyProjectServer-Linux-Test -SvcType=xx -DsaPid=2415299 -DsaSock=<span class="string">&quot;/data00/dsagent/2415299.sock&quot;</span> -UdpHost=10.10.10.10 -NumMultiWorld=1 -Map=<span class="string">&quot;/Game/Project/Maps/MyMap&quot;</span> -NumForks=15 -WaitAndForkCmdLinePath=/data00/ds/CmdLines -BiPath=<span class="string">&quot;/data00/ds/logs/bi&quot;</span> -ABSLOG=<span class="string">&quot;/data00/ds/logs/MyProject_MyMap.log&quot;</span> -core -nothreading -longtimeouts -unattended</span><br></pre></td></tr></table></figure>

<ul>
<li>子进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">game@n253-012-090:/data00/ds/logs$ <span class="built_in">cat</span> /data00/ds/CmdLines/1</span><br><span class="line"></span><br><span class="line">-SvcType=xx -DsaPid=2415299 -DsaSock=<span class="string">&quot;/data00/dsagent/2415299.sock&quot;</span> -Port=30001 -UdpHost=10.10.10.10 -ABSLOG=<span class="string">&quot;/data00/ds/logs/MyProject_30001.log&quot;</span> -BiPath=<span class="string">&quot;/data00/ds/logs/bi&quot;</span> -core -nothreading -longtimeouts -unattended -NODEFAULTLOG</span><br></pre></td></tr></table></figure>

<h4 id="多GameInstance"><a href="#多GameInstance" class="headerlink" title="多GameInstance"></a>多GameInstance</h4><p>启动一个进程，单进程下15个GameInstance实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">game     2430225 2430210 11 16:26 ?        00:01:25 /data00/ds/Latest/MyProject/Binaries/Linux/MyProjectServer-Linux-Test -SvcType=xx -DsaPid=2430210 -DsaSock=<span class="string">&quot;/data00/dsagent/2430210.sock&quot;</span> -UdpHost=10.10.10.10 -Port=30001 -NumMultiWorld=15 -Map=<span class="string">&quot;/Game/Project/Maps/MyMap&quot;</span> -BiPath=<span class="string">&quot;/data00/ds/logs/bi&quot;</span> -ABSLOG=<span class="string">&quot;/data00/ds/logs/MyProject_30001.log&quot;</span> -nofork -core -nothreading -longtimeouts -unattended</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h4 id="Fork-vs-多Instance"><a href="#Fork-vs-多Instance" class="headerlink" title="Fork vs 多Instance"></a>Fork vs 多Instance</h4><p><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-mem.6ikokz1cro.webp" title="memo" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-mem.6ikokz1cro.webp" alt="memo"></a></p>
<h4 id="Fork下父子"><a href="#Fork下父子" class="headerlink" title="Fork下父子"></a>Fork下父子</h4><p><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-parent.102k4tuw06.webp" title="parent" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-parent.102k4tuw06.webp" alt="parent"></a><br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/mf-child.3d56m196us.webp" title="child" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/mf-child.3d56m196us.webp" alt="child"></a></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><strong>多GameInstance方案在内存上有明显的优势。</strong></p>
<ol>
<li>场景启动后，玩家还没进入场景的时候，两者内存占用差不多</li>
<li>Fork模式下，玩家进入场景后内存明显增加（COW），5分钟后趋于稳定，内存增长了117%（1557m）</li>
<li>多GameInstance模式下，玩家进入场景后内存就稳定了，内存增长了15%（189m）</li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5单进程多GameInstance方案</title>
    <url>/ue-multiworld/</url>
    <content><![CDATA[<div class=".article-gallery"><h1 id="如何开启多实例"><a href="#如何开启多实例" class="headerlink" title="如何开启多实例"></a>如何开启多实例</h1><p>使用<code>-NumMultiWorld=num</code>来开启指定数量(num)的GameInstance实例</p>
<h1 id="修改思路"><a href="#修改思路" class="headerlink" title="修改思路"></a>修改思路</h1><p>为了降低和官方引擎的差异，通过引入新的<code>UMultiWorldGameEngine</code>继承自<code>UGameEngine</code>重写必要的方法，来实现单进程多实例的方案。</p>
<p>参照PIE复制World的方案，将同一份资源加载出多个UPackage，每一个UPackage对应一个World。在对象的命名上参考PIE模式，增加前缀UEMW_$id$_以作区分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2025.06.17-16.31.25:853][  0]LogGlobalStatus: UEngine::LoadMap Load map complete /Game/Project/Maps/MyMap/UEMW_1_MyMap</span><br></pre></td></tr></table></figure>

<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><h3 id="引擎部分"><a href="#引擎部分" class="headerlink" title="引擎部分"></a>引擎部分</h3><ul>
<li><code>UEngine::LoadMap()</code>时增加<code>MW_URLTrueMapName</code>选项参数来指定真正的地图资源，比如上面log中的<code>/Game/Project/Maps/MyMap/MyMap</code>。原有的URL.Map通过增加<code>UEMW_$id$_</code>前缀来实现同一份资源加载出不同的WorldPackage。</li>
</ul>
<p>UnrealEngine.cpp<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/ue-multiworld-1.8ok36kfpzv.webp" title="code1" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/ue-multiworld-1.8ok36kfpzv.webp" alt="code1"></a><br>World.cpp<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/ue-multiworld-2.8s3p4aamxp.webp" title="code2" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/ue-multiworld-2.8s3p4aamxp.webp" alt="code2"></a></p>
<ul>
<li>对 <em>streaming levels ​</em>进行重命名（这里趟过坑）。参考PIE对World的完整处理流程<code>UEngine::CreatePIEWorldByLoadingFromPackage()</code></li>
</ul>
<p>UnrealEngine.cpp<br><a href="https://github.com/zhangga/picx-images-hosting/raw/master/ue-multiworld-3.5j4l7qadwz.webp" title="code3" class="gallery-item" style="box-shadow: none;"> <img src="https://github.com/zhangga/picx-images-hosting/raw/master/ue-multiworld-3.5j4l7qadwz.webp" alt="code3"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This method refers to the above CreatePIEWorldByLoadingFromPackage().</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RenameForMultiWorld</span><span class="params">(UWorld* InWorld, <span class="type">const</span> FString&amp; SourceWorldPackage, <span class="type">const</span> FString&amp; InMWPrefix)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">check</span>(InWorld);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Rename streaming levels to MultiWorld. refers to StreamingLevel::RenameForPIE</span></span><br><span class="line">		<span class="keyword">for</span> (ULevelStreaming* StreamingLevel : InWorld-&gt;<span class="built_in">GetStreamingLevels</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Apply the MultiWorld prefix so this level references</span></span><br><span class="line">			<span class="keyword">if</span> (!StreamingLevel-&gt;<span class="built_in">GetWorldAsset</span>().<span class="built_in">IsNull</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				FName NonPrefixedName = <span class="built_in">FName</span>(<span class="built_in">StripMWPrefixFromPackageName</span>(StreamingLevel-&gt;<span class="built_in">GetWorldAssetPackageName</span>(), InMWPrefix));</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Store original name</span></span><br><span class="line">				<span class="keyword">if</span> (StreamingLevel-&gt;PackageNameToLoad == NAME_None)</span><br><span class="line">				&#123;</span><br><span class="line">					StreamingLevel-&gt;PackageNameToLoad = NonPrefixedName;</span><br><span class="line">				&#125;</span><br><span class="line">				FName CurrWorldStreamingPackageName = <span class="built_in">FName</span>(<span class="built_in">ConvertToMWPackageName</span>(StreamingLevel-&gt;<span class="built_in">GetWorldAssetPackageName</span>(), InMWPrefix));</span><br><span class="line">				FSoftObjectPath::<span class="built_in">AddPIEPackageName</span>(CurrWorldStreamingPackageName);</span><br><span class="line">				StreamingLevel-&gt;<span class="built_in">SetWorldAssetByPackageName</span>(CurrWorldStreamingPackageName);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Rename LOD levels if any</span></span><br><span class="line">			<span class="keyword">if</span> (StreamingLevel-&gt;LODPackageNames.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				StreamingLevel-&gt;LODPackageNamesToLoad.<span class="built_in">Reset</span>(StreamingLevel-&gt;LODPackageNames.<span class="built_in">Num</span>());</span><br><span class="line">				<span class="keyword">for</span> (FName&amp; LODPackageName : StreamingLevel-&gt;LODPackageNames)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// Store LOD level original package name</span></span><br><span class="line">					StreamingLevel-&gt;LODPackageNamesToLoad.<span class="built_in">Add</span>(LODPackageName);</span><br><span class="line">					<span class="comment">// Apply MultiWorld prefix to package name</span></span><br><span class="line">					<span class="type">const</span> FName NonPrefixedLODPackageName = LODPackageName;</span><br><span class="line">					LODPackageName = <span class="built_in">FName</span>(<span class="built_in">ConvertToMWPackageName</span>(LODPackageName.<span class="built_in">ToString</span>(), InMWPrefix));</span><br><span class="line">					FSoftObjectPath::<span class="built_in">AddPIEPackageName</span>(LODPackageName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="项目部分"><a href="#项目部分" class="headerlink" title="项目部分"></a>项目部分</h3><p>主要部分</p>
<p>UMultiWorldGameEngine.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_MWGAMEENGINE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiWorldGameEngine::Init</span><span class="params">(<span class="keyword">class</span> IEngineLoop* InEngineLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Init</span>(InEngineLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;-NumMultiWorld=&quot;</span>), NumMultiWorld))</span><br><span class="line">    &#123;</span><br><span class="line">       NumMultiWorld = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Single game instance.</span></span><br><span class="line">​    ​<span class="keyword">if</span> (NumMultiWorld &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// The base GameEngine-&gt;GameInstance is the only one.</span></span><br><span class="line">       MultiGameInstances.<span class="built_in">Add</span>(GameInstance);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In MultiWorld mode, the base GameEngine-&gt;GameInstance is not included in the TArray&lt;MultiGameInstances&gt; container.</span></span><br><span class="line">​    ​<span class="comment">// The base GameEngine-&gt;GameInstance must always be preserved.</span></span><br><span class="line">​    ​<span class="comment">// Try to create $&#123;NumMultiWorld&#125; game instances.</span></span><br><span class="line">​    ​<span class="keyword">for</span> (uint16 i = <span class="number">0</span>; i &lt; NumMultiWorld; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">       uint16 InstanceID = i;</span><br><span class="line">       <span class="built_in">ensure</span>(MultiGameInstances.<span class="built_in">Num</span>() == InstanceID);</span><br><span class="line">       FSoftClassPath GameInstanceClassName = <span class="built_in">GetDefault</span>&lt;UGameMapsSettings&gt;()-&gt;GameInstanceClass;</span><br><span class="line">       UClass* GameInstanceClass = (GameInstanceClassName.<span class="built_in">IsValid</span>() ? <span class="built_in">LoadObject</span>&lt;UClass&gt;(<span class="literal">NULL</span>, *GameInstanceClassName.<span class="built_in">ToString</span>()) : UGameInstance::<span class="built_in">StaticClass</span>());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (GameInstanceClass == <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">UE_LOG</span>(LogEngine, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;UMultiWorldGameEngine: Unable to load GameInstance Class &#x27;%s&#x27;. Falling back to generic UGameInstance.&quot;</span>), *GameInstanceClassName.<span class="built_in">ToString</span>());</span><br><span class="line">          GameInstanceClass = UGameInstance::<span class="built_in">StaticClass</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       UGameInstance* OtherGameInstance = <span class="built_in">NewObject</span>&lt;UGameInstance&gt;(<span class="keyword">this</span>, GameInstanceClass);</span><br><span class="line">       MultiGameInstances.<span class="built_in">Add</span>(OtherGameInstance);</span><br><span class="line">       OtherGameInstance-&gt;<span class="built_in">InitializeStandalone</span>();</span><br><span class="line">       <span class="built_in">UE_LOG</span>(LogEngine, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;UMultiWorldGameEngine: GameInstance %d Initialized.&quot;</span>), InstanceID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMultiWorldGameEngine::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Single game instance.</span></span><br><span class="line">​    ​<span class="keyword">if</span> (NumMultiWorld &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MultiWorld mode</span></span><br><span class="line">​    ​<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; MultiGameInstances.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">       MultiGameInstances[i]-&gt;<span class="built_in">StartGameInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMultiWorldGameEngine::LoadMap</span><span class="params">(FWorldContext&amp; WorldContext, FURL URL, <span class="keyword">class</span> UPendingNetGame* Pending, FString&amp; Error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Single game instance.</span></span><br><span class="line">​    ​<span class="keyword">if</span> (NumMultiWorld &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// normal UE behavior</span></span><br><span class="line">​       ​<span class="keyword">return</span> Super::<span class="built_in">LoadMap</span>(WorldContext, URL, Pending, Error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MultiWorld mode</span></span><br><span class="line">​    ​uint16 MWInstanceID = <span class="built_in">GetMWIDByGameInstance</span>(WorldContext.OwningGameInstance);</span><br><span class="line">    <span class="keyword">if</span> (MWInstanceID == INSTANCE_ID_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// set the base GameEngine-&gt;GameInstance port=1, ​dont​ start network.</span></span><br><span class="line">​       ​URL.Port = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// normal UE behavior</span></span><br><span class="line">​       ​<span class="keyword">return</span> Super::<span class="built_in">LoadMap</span>(WorldContext, URL, Pending, Error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to strip prefix from MWPackageName</span></span><br><span class="line">​    ​URL.Map = <span class="built_in">StripPrefixFromMWPackageName</span>(URL.Map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process URL before Browse</span></span><br><span class="line">​    ​FString MultiWorldPrefix = <span class="built_in">BuildMWPackagePrefix</span>(MWInstanceID);</span><br><span class="line">    FString MWPrefixOp = <span class="built_in">TEXT</span>(<span class="string">&quot;MW_Prefix=&quot;</span>) + MultiWorldPrefix;</span><br><span class="line">    URL.<span class="built_in">AddOption</span>(*MWPrefixOp);</span><br><span class="line">    FString MultiWorldMapName = <span class="built_in">ConvertToMWPackageName</span>(URL.Map, MWInstanceID);</span><br><span class="line">    FString URLTrueMapNameOp = <span class="built_in">TEXT</span>(<span class="string">&quot;MW_URLTrueMapName=&quot;</span>) + URL.Map;</span><br><span class="line">    URL.Map = MultiWorldMapName;</span><br><span class="line">    URL.<span class="built_in">AddOption</span>(*URLTrueMapNameOp);</span><br><span class="line">    <span class="keyword">if</span> (URL.Port == FURL::UrlConfig.DefaultPort)</span><br><span class="line">    &#123;</span><br><span class="line">       URL.Port += MWInstanceID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Super::<span class="built_in">LoadMap</span>(WorldContext, URL, Pending, Error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMultiWorldGameEngine::NetworkRemapPath</span><span class="params">(UNetConnection* Connection, FString&amp; Str, <span class="type">bool</span> bReading <span class="comment">/*= true*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Str = <span class="built_in">StripPrefixFromMWPackageName</span>(Str);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><ol>
<li>MyProjectServer.Target.cs</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// use MWGameEngine</span><br><span class="line">GlobalDefinitions.Add(&quot;USE_MWGAMEENGINE=1&quot;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DefaultEngine.ini</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[/Script/Engine.Engine]</span><br><span class="line">GameEngine=/Script/MyProject.MultiWorldGameEngine</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动参数</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-NumMultiWorld=$num</span><br></pre></td></tr></table></figure>

<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ol>
<li>原来GameInstance退出的时候就退出Engine，现在需要判断所有GameInstance退出后才能退出Engine。</li>
<li>原来游戏中是单例的数据结构，现在需要视情况跟着GameInstance走。</li>
</ol>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>在 CPU 资源占用较低的地图场景中，可通过单进程多开 GameInstance 的方式，直接复用进程内已加载的资源内存（如地图配置、静态模型）。相比共享内存（Fork）模式，该方案能进一步优化 CPU 与内存的资源配比，最终在承载相同数量场景实例的前提下，显著降低整体内存占用。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建WordPress个人站点</title>
    <url>/wordpress-build/</url>
    <content><![CDATA[<div class=".article-gallery"><p><a href="https://imgtu.com/i/hZViiq"><a href="https://z3.ax1x.com/2021/08/25/hZViiq.md.png" title="hZViiq.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/25/hZViiq.md.png" alt="hZViiq.md.png"></a></a></p>
<h2 id="LAMPP-WordPress搭建"><a href="#LAMPP-WordPress搭建" class="headerlink" title="LAMPP+WordPress搭建"></a>LAMPP+WordPress搭建</h2><h3 id="官网：https-wordpress-org"><a href="#官网：https-wordpress-org" class="headerlink" title="官网：https://wordpress.org/"></a>官网：<a href="https://wordpress.org/">https://wordpress.org/</a></h3><h3 id="中文网：https-cn-wordpress-org"><a href="#中文网：https-cn-wordpress-org" class="headerlink" title="中文网：https://cn.wordpress.org/"></a>中文网：<a href="https://cn.wordpress.org/">https://cn.wordpress.org/</a></h3><span id="more"></span>

<p>下载tar包，解压到lampp/htdocs文件夹下文件夹，修改成自己喜欢的名。<br>访问站点。如：<a href="http://47.95.10.167/%E7%AB%99%E7%82%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D">http://47.95.10.167/站点文件夹名</a><br>设置数据库（数据库需要先建库），设置admin等信息。（配置文件存储在站点文件夹/wp-config.php文件）<br>使用域名访问指定博客<br>重定向。在xampp目录下修改文件重定向，我的机器在/opt/lampp/htdocs/目录下。修改index.php如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	if (!empty($_SERVER[&#x27;HTTPS&#x27;]) &amp;&amp; (&#x27;on&#x27; == $_SERVER[&#x27;HTTPS&#x27;])) &#123;</span><br><span class="line">		$uri = &#x27;https://&#x27;;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		$uri = &#x27;http://&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">	$uri .= $_SERVER[&#x27;HTTP_HOST&#x27;];</span><br><span class="line">	header(&#x27;Location: &#x27;.$uri.&#x27;/blog/&#x27;);</span><br><span class="line">	exit;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress上传权限问题及主题</title>
    <url>/wordpress/</url>
    <content><![CDATA[<div class=".article-gallery"><p><a href="https://imgtu.com/i/htjgKI"><a href="https://z3.ax1x.com/2021/08/30/htjgKI.md.png" title="htjgKI.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/08/30/htjgKI.md.png" alt="htjgKI.md.png"></a></a></p>
<span id="more"></span>

<p>打开所有写权限</p>
<p>chmod 777 /usr/local/lampp/htdocs/zzq/</p>
<p>修改文件夹所属用户组。查看用户组指令：cat /etc/group   别人都是www:www  我是daemon</p>
<p>chown -R daemon:daemon zzq</p>
<p>还原文件夹权限</p>
<p>chmod 755 /usr/local/lampp/htdocs/zzq/</p>
<h2 id="主题网站"><a href="#主题网站" class="headerlink" title="主题网站"></a>主题网站</h2><p><a href="http://ztmao.com/">http://ztmao.com/</a></p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>工作流总结</title>
    <url>/work-flow/</url>
    <content><![CDATA[<div class=".article-gallery"><h2 id="研发流程"><a href="#研发流程" class="headerlink" title="研发流程"></a>研发流程</h2><h4 id="分支策略比较"><a href="#分支策略比较" class="headerlink" title="分支策略比较"></a>分支策略比较</h4><table>
<thead>
<tr>
<th>模式</th>
<th>并发收益</th>
<th>并发维护成本</th>
<th>验收集成效率</th>
<th>分支合入成本消耗</th>
</tr>
</thead>
<tbody><tr>
<td>单常驻分支<br />(e.g. master开发上线)</td>
<td>1</td>
<td>紧急发布要隐藏代码</td>
<td>通常验证1次</td>
<td>合并次数=1，功能合入主干</td>
</tr>
<tr>
<td>双常驻分支<br />(e.g. dev开发 master上线)</td>
<td>2</td>
<td>中等，hotfix不需要隐藏代码</td>
<td>验证2次</td>
<td>合并次数=3，功能合入双主干+双主干间集成</td>
</tr>
<tr>
<td>三个以上常驻分支<br />(e.g. 每种环境对应分支)</td>
<td>3</td>
<td>较少，多环境不需要隐藏代码</td>
<td>需要验证多次</td>
<td>合并次数=5，功能合入三主干+三主干间传递</td>
</tr>
<tr>
<td>总结</td>
<td>并发效率可以认为是线性增长的n</td>
<td>主干越多对代码侵入越小</td>
<td>当测试自动化测试和环境自动化测试够强后，该项成本平稳</td>
<td>合并工作和出错出冲突修复的概率线性增长 2*n-1</td>
</tr>
</tbody></table>
<h4 id="分支规范最佳实践"><a href="#分支规范最佳实践" class="headerlink" title="分支规范最佳实践"></a>分支规范最佳实践</h4><span id="more"></span>

<ul>
<li><p>使用特性分支开发</p>
<p>每个需求一个独立分支，使用需求的ID号作为分支名称，用于隔离并行开发造成的干扰。</p>
<p>好处：是一种工程实践， 使用它的人直到他所开发的特性“完成”后才合并回主干。</p>
</li>
<li><p>持续集成主干</p>
<p>所有需求在一个分支做每日集成，并辅助一些自动化测试手段，及时发现集成问题。</p>
<p>好处：是一种工程实践，用于确保你的软件一直是可以工作的，并且在几分钟内你就能够得到关于 “你的修改是否破坏了系统”的反馈。</p>
</li>
<li><p>专门拉取发布分支进行发布工作</p>
<p>在发布时，将集成好的主干拉出或同步到用于发布的分支上，屏蔽发布中的修改，支持做一些hotfix或临时patch合入。</p>
</li>
</ul>
<h4 id="分支策略解析"><a href="#分支策略解析" class="headerlink" title="分支策略解析"></a>分支策略解析</h4><ul>
<li><p>轻量模块采用“<strong>单常驻分支模式</strong>”</p>
<p>可用于新项目早期或者1-3人协作的项目开发适用，以master作为主分支（常驻分支），基于master拉出feature分支，开发完成后合并回master，基于master发布。</p>
<p>优劣：合入成本低，revert成本高，需要配合严格的准入流程。所有紧急正常的修改全在主干上，开发了一半的东西如果要上线的话，要巧妙的藏起来。对程序的结构提出了高要求，分分合合要方便，用好的话，需要功能开关配置。</p>
</li>
<li><p>重要模块采用<strong>“双常驻分支模式“</strong></p>
<p><em><strong>master分支：</strong></em>作为发布分支，紧急hotfix除外，不允许开发直接合并到master分支，发布完成后打tag，特定的版本的hotfix必须以tag为基线拉分支修复，完成后合并到master，hotfix确认完成增加hotfix版本tag。打tag时记得写release note。</p>
<p><em><strong>dev分支：</strong></em>日常开发基线分支，迭代中开发从dev分支拉出开发分支，<strong>完成并通过强制的code review后合并回dev分支</strong>，开发者有责任保持私有分支与dev分支同步并解决可能的合并冲突；特定版本的hotfix的开发者负责发布后将hotfix合并到dev分支，并解决合并的潜在冲突；dev分支到master分支的mr由团队内release engineer角色的人负责，合并时不需要进行code review直接合入，编译发布后打对应版本tag。</p>
<p><strong>基于主干的开发 trunk based development</strong> <strong>（TBD）</strong></p>
<p>主干用于CI持续集成，按照实际场景可以使用固定的master或dev分支，或者团队成员约定一个动态变化的dev_2019作为主干，所有人从主干拉出开发分支，从主干合入。</p>
<p>发布分支可以有一个或多个，用于周期性发布，如固定的release分支或者动态分支如release1.0，非必要不允许hotfix直接合入。</p>
<p><a href="https://imgtu.com/i/5ZrpdK"><a href="https://z3.ax1x.com/2021/10/11/5ZrpdK.jpg" title="5ZrpdK.jpg" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/10/11/5ZrpdK.jpg" alt="5ZrpdK.jpg"></a></a></p>
</li>
<li><p>多分支模式</p>
<p>客户端可能常见</p>
</li>
</ul>
<h3 id="日常开发流程"><a href="#日常开发流程" class="headerlink" title="日常开发流程"></a>日常开发流程</h3><ol>
<li><p>创建任务工单</p>
</li>
<li><p>从dev分支拉一个feature分支出来</p>
<p><code>git checkout -b WEBARCHBIZ-123456-DO-SOME-THING</code></p>
</li>
<li><p>写代码，写单测</p>
</li>
<li><p>确认代码格式规范，推荐使用ide的format调整功能</p>
</li>
<li><p>提交代码</p>
<p><code>git push origin WEBARCHBIZ-123456-DO-SOME-THING</code></p>
</li>
<li><p>发起merge request，在description中写清楚本次提交的内容，尽量保证每个mr只做一件事情，提交后提醒peer及时review</p>
</li>
<li><p>code review通过后，合入dev分支，会自动发布到沙盒，可以在沙盒环境测试和验证你的修改。</p>
</li>
<li><p>如果有重要的功能变更，在沙盒集成测试中补充相应的testcase</p>
</li>
</ol>
<h3 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h3><ol start="9">
<li>发起从dev分支到master分支的merge request，approve后方可合入master（日常迭代上线时间是周二和周四）。</li>
<li>合入master后，pipeline会自动发起，流程中会有一个人工checkbpoint的lark卡片通知，需要人工确认。</li>
<li>上线完成后在线上进行验证测试，确认功能无异常。</li>
<li>对用户有感的变更，在产品文档上填写release note。</li>
</ol>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA版ZSet性能测试</title>
    <url>/zset/</url>
    <content><![CDATA[<div class=".article-gallery"><p>自己实现的JAVA版ZSet的主要功能，源码在github：</p>
<p><a href="https://github.com/zhangga/JAVAZSet">https://github.com/zhangga/JAVAZSet</a></p>
<p><a href="https://imgtu.com/i/hBs35t"><a href="https://z3.ax1x.com/2021/09/01/hBs35t.md.png" title="hBs35t.md.png" class="gallery-item" style="box-shadow: none;"> <img src="https://z3.ax1x.com/2021/09/01/hBs35t.md.png" alt="hBs35t.md.png"></a></a></p>
<p>性能测试：</p>
<p>下面数据都是在本地windows下执行10次的评价值：JVM10G + i7-8700开着各种应用。Eclipse Run 预热几次稳定后。</p>
<h3 id="ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。"><a href="#ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。" class="headerlink" title="ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。"></a>ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。</h3><p>获取1000-3000分值的数据，执行1W次，</p>
<p>取样10次用时ms：6604+6490+6648+6602+7718+7626+6682+7498+6588+7358=69814/10=6981</p>
<h3 id="ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。"><a href="#ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。" class="headerlink" title="ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。"></a>ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。</h3><p>获取1000-3000分值的数据，执行1W次，</p>
<p>取样10次用时ms：7594+8279+8622+8476+7810+7397+7241+8579+8019+8554=80571/10=8057</p>
<h3 id="ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。"><a href="#ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。" class="headerlink" title="ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。"></a>ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。</h3><h2 id="获取高度方法性能测试："><a href="#获取高度方法性能测试：" class="headerlink" title="获取高度方法性能测试："></a>获取高度方法性能测试：</h2><p>1.使用ZSet获取附近的障碍物，判断是否在障碍物内，获取障碍物高度。</p>
<p>测试用例，在一处放置11个圆形障碍物，搜索2米范围内的障碍物，获取高度。100W次测试，用时在450ms-500ms之间。</p>
<p>2.使用一个正常地图（37号场景）的navmesh数据，recast的获取高度。100W次测试，用时在1000ms-1100ms之间。</p>
</div>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
