{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"source/images/vx.png","path":"images/vx.png","modified":0,"renderable":0},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/css/bb.css","path":"css/bb.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/contact.png","path":"medias/contact.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/minivaline/MiniValine.js","path":"libs/minivaline/MiniValine.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/prism/prism.css","path":"libs/prism/prism.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1623325894976},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":499162500000},{"_id":"public/2021/06/10/hello-world/index.html","hash":"504c1c2148b28119f30daf84f66ff507e2852221","modified":1623328907641},{"_id":"public/archives/index.html","hash":"7a39f4aae77b110bb568bbeec866d600b8a98f52","modified":1629866147266},{"_id":"public/archives/2021/index.html","hash":"47e8650d2b5fd2673393a1b80f44eede4ad0d6fe","modified":1629866147266},{"_id":"public/archives/2021/06/index.html","hash":"c843b6951ee7a3f692d6a492d0380b3bfdb58d35","modified":1629866147266},{"_id":"public/index.html","hash":"00c21cd475acbf19347b5620d7d15879161dca1b","modified":1629866147266},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1623328338574},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1623328338574},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1623328338574},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1623328338574},{"_id":"public/css/style.css","hash":"0a48aa2986cbe65028f82dcb87d1c8ffac6be2cd","modified":1623328338574},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1623328338574},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1623328338574},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1623328338574},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1623328338574},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1623328338574},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1623328338574},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1623328338574},{"_id":"source/_posts/hello.md","hash":"adf71de2a3e6c73ca63f4ed7507da5cefc754dbb","modified":1629899879268},{"_id":"public/2016/11/12/hello/index.html","hash":"3bb8dc8a8c67c69a6dc1d33591077d6859c82511","modified":1623328907641},{"_id":"public/archives/2016/index.html","hash":"41a5142c6c4f3d8d32609b920c52e64828d44a15","modified":1623328907641},{"_id":"public/archives/2016/11/index.html","hash":"3dad0aa64adaa295af070bea94082b914afc9cc6","modified":1623328907641},{"_id":"public/tags/demo/index.html","hash":"7d4205063ebf3f5328418540f12fd15cd9e5a677","modified":1623328907641},{"_id":"public/tags/hello/index.html","hash":"7a6e963460d1428ae1ad92b291efb2fe42d9bb9d","modified":1623328907641},{"_id":"source/.DS_Store","hash":"8ef8c1b807d01cd3d02b037d5e802f41edfbccca","modified":1623308158083},{"_id":"source/_posts/test.md","hash":"512e7e5c5e3d2d0a8f046d5dfa1ce3785ed385b8","modified":1623306830329},{"_id":"public/2021/06/10/test/index.html","hash":"edcef1d2a426fbcf32ae591bf05bdc49d1bdcda0","modified":1623310189681},{"_id":"source/CNAME","hash":"210c1d4e2d2050201f499460356be8877842311e","modified":1623307964925},{"_id":"source/README.md","hash":"a4486b519ef4255996353d5bb225cc173fc42c98","modified":1623308026501},{"_id":"public/README.html","hash":"8aef07fac9cb2ef57ecdaba1ea6aacb8a1c1ac51","modified":1623308061292},{"_id":"public/CNAME","hash":"210c1d4e2d2050201f499460356be8877842311e","modified":1623328338574},{"_id":"themes/cho/.gitattributes","hash":"ba3dfe345280bdcc5e817bb02cf49b8b8d8e1c4c","modified":1623309452069},{"_id":"themes/cho/404.jade","hash":"b74164cbeb16b81db115bb5c0eba8f112f5867ac","modified":1623309452070},{"_id":"themes/cho/LICENSE","hash":"f52e0d9d49874d95d723cc2c0a9eea6d84d8bdbe","modified":1623309452070},{"_id":"themes/cho/archive.jade","hash":"10a99c2742bd707f88ccab7c204dbb6b4621b52f","modified":1623309452070},{"_id":"themes/cho/base.jade","hash":"3555577dd55bbcab949740b101491c2c76df645e","modified":1623309452071},{"_id":"themes/cho/README.md","hash":"bb94675f9fa0430ee961d7df0b464c6b8196ab0e","modified":1623309452070},{"_id":"themes/cho/categories.jade","hash":"52c5bc5fa0bc4c14a2be259a4a1eea6fac387063","modified":1623309452071},{"_id":"themes/cho/index.jade","hash":"15c8709ef492f6bc2a70aaff9a6e4b5dcb32d742","modified":1623309452073},{"_id":"themes/cho/post.jade","hash":"ce9123f03047462756151e33aa2d4a2537016292","modified":1623309452074},{"_id":"themes/cho/pure-custom.css","hash":"2a9e41eb69f71c39a090cc864a99e85a055dd286","modified":1623309452074},{"_id":"themes/cho/tag+category.jade","hash":"06a5d41aa339880c76f49b6c20e5fb01ae85767e","modified":1623309452075},{"_id":"themes/cho/style.scss","hash":"0c5f6b5372c7e71ff98c1dff8f2b2a7d8e35a190","modified":1623309452074},{"_id":"themes/cho/img/post-cover-empty.svg","hash":"fa3e79f4ffae3a6a171b1cf9d0ea91044a43cfe2","modified":1623309452072},{"_id":"themes/cho/fonts/satisfy.woff","hash":"2b3a4847879c8e7dfd1e7548de2b0bb7546d16b6","modified":1623309452071},{"_id":"themes/cho/img/category-cover-empty.svg","hash":"99e4c050bd0687560fbd9c06a28ebab7323a32dd","modified":1623309452072},{"_id":"themes/cho/javascript/main.js","hash":"e4937b753542f90b596b653365b5ef2af77fc661","modified":1623309452073},{"_id":"themes/cho/img/post-mask.png","hash":"8ee175194cd7359e76ca514dc0b5228440ca4d3b","modified":1623309452072},{"_id":"themes/cho/javascript/autoload.js","hash":"231153df8720d832766148c70e9982109872cb76","modified":1623309452073},{"_id":"themes/even/.all-contributorsrc","hash":"5e55677518a2d881c8a27821381da925365a8efa","modified":1623309573927},{"_id":"themes/even/.eslintignore","hash":"de3f06c672357f312d670c9fd9cc58c2b1a0864c","modified":1623309573927},{"_id":"themes/even/.gitignore","hash":"32753aa9232f2d5dbf10b3fb8de8f1426f264ac1","modified":1623309573928},{"_id":"themes/even/.eslintrc","hash":"0fcde446104e73d7159f8574f28fe661acdb384e","modified":1623309573927},{"_id":"themes/even/LICENSE","hash":"187fc7598698ac70c7ab9dffaa08883fd8b91958","modified":1623309573928},{"_id":"themes/even/_config.yml.example","hash":"5e1dda1f4790a6c733c51164e2450ed86d0ec10c","modified":1623309573928},{"_id":"themes/even/README.md","hash":"18d6bbd43b5bdf8875a2328a3ef5834e92e9cd96","modified":1623309573928},{"_id":"themes/even/package.json","hash":"fbd41d067538a26bcb0386367935a5e91da48058","modified":1623309573936},{"_id":"themes/even/yarn.lock","hash":"ff5d63b50f76b4b6f36661c012ffca2af7ba9dff","modified":1623309573952},{"_id":"themes/even/languages/default.yml","hash":"42df6a0f6f21778f20779f6b0336df65a59c890d","modified":1623309573929},{"_id":"themes/even/languages/en.yml","hash":"42df6a0f6f21778f20779f6b0336df65a59c890d","modified":1623309573929},{"_id":"themes/even/languages/zh-CN.yml","hash":"f7da3fc6252df9d19abd1321b3c5a8c2ad13cca7","modified":1623309573929},{"_id":"themes/even/languages/zh-TW.yml","hash":"c275550aded8b4173f9965a627eedf1d727f3da3","modified":1623309573929},{"_id":"themes/even/layout/_layout.swig","hash":"00dc81c1d5751144a59de05db415c51954973230","modified":1623309573929},{"_id":"themes/even/layout/archive.swig","hash":"fde460d3c38ad132ef5effbdbaf66c48c8296c3b","modified":1623309573935},{"_id":"themes/even/layout/categories.swig","hash":"a14078a46bc45e1e02c1bc450dc894d693975707","modified":1623309573935},{"_id":"themes/even/layout/index.swig","hash":"4bc20e7616ace7cf12c17328cb84b8203b763b09","modified":1623309573935},{"_id":"themes/even/layout/page.swig","hash":"a6cf4e5bc3cb9a9ea6a6ed3b074cff6d69073f14","modified":1623309573935},{"_id":"themes/even/layout/post.swig","hash":"88f3f7538c75271133d00f3b1a0d0a40ec953c8d","modified":1623309573935},{"_id":"themes/even/layout/tags.swig","hash":"ce15107017d6e1663f2b0be92d7758622e17861f","modified":1623309573935},{"_id":"themes/even/source/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1623309573942},{"_id":"themes/even/.github/workflows/deploy.yml","hash":"c3451c1d908b860d071f670cde130ea4d0ba8e83","modified":1623309573928},{"_id":"themes/even/layout/_macro/archive.swig","hash":"641f02ccabc1cc59ecc73f2a40516088495e9ff9","modified":1623309573930},{"_id":"themes/even/source/robots.txt","hash":"eed1ebad39b24e7942fcaf8f27da7487eb9f956e","modified":1623309573951},{"_id":"themes/even/layout/_macro/post.swig","hash":"671faa8fc3374ce900f57487d9e53bc8a5f2f592","modified":1623309573930},{"_id":"themes/even/layout/_partial/comments.swig","hash":"f60c042be03c113377900f6fd46635f50c1a3c80","modified":1623309573931},{"_id":"themes/even/layout/_partial/footer.swig","hash":"418855b4ace54609431c52e091506e7a6180d433","modified":1623309573931},{"_id":"themes/even/layout/_partial/header.swig","hash":"2c3a0fba88605a98b56528437e1c2160942cdba4","modified":1623309573932},{"_id":"themes/even/layout/_partial/head.swig","hash":"b18d4f4b5ce4ea3c3ba5c3d4a1300f9fc3a5b15e","modified":1623309573931},{"_id":"themes/even/layout/_partial/pagination.swig","hash":"caab675c3c1df76d5c047d5c4dc42ffcb79caa9a","modified":1623309573932},{"_id":"themes/even/layout/_partial/slideout.swig","hash":"ecfaa8a922eef7d0c6eb05592d390ae36d6da9e3","modified":1623309573932},{"_id":"themes/even/layout/_script/analytics.swig","hash":"b1fe6eb7e42594383dba5e5a6a9ed655158e1f25","modified":1623309573934},{"_id":"themes/even/layout/_script/comments.swig","hash":"76b88bca6080243ee1054a98053b04db57d423d7","modified":1623309573934},{"_id":"themes/even/layout/_script/counter.swig","hash":"787d956687d4846286b11c68fb2a81a0d981d4b1","modified":1623309573934},{"_id":"themes/even/layout/_script/libs.swig","hash":"668e0939e5c22bcf5437afdd398a7fd16c0059a0","modified":1623309573934},{"_id":"themes/even/layout/_script/push.swig","hash":"2aacb350e2e4870f175ba4783c710c4c4006274c","modified":1623309573934},{"_id":"themes/even/layout/_script/theme.swig","hash":"ef8207e22d10ba11821749e1dc0041cf0104d7e3","modified":1623309573934},{"_id":"themes/even/source/css/_base.scss","hash":"ffd8c02b4e1dde0433458b0fef02f01a1fd0f1dd","modified":1623309573936},{"_id":"themes/even/source/css/_variables.scss","hash":"a32d1aa88bf6c81af01a0ad87d0cdc9beb17bfa1","modified":1623309573941},{"_id":"themes/even/source/css/style.scss","hash":"814c81baf2d6fe1acdaf5319c3fa796c260a2d3c","modified":1623309573941},{"_id":"themes/even/layout/_partial/_footer/social.swig","hash":"45159378a4abd916367a5a10cf39eabb0d460c70","modified":1623309573930},{"_id":"themes/even/layout/_partial/_head/meta.swig","hash":"067665118c38c2f579f801ff53bab0d32b28109c","modified":1623309573930},{"_id":"themes/even/layout/_partial/_post/copyright.swig","hash":"517533bf6cb5292a55be11036ef72d699acc33ef","modified":1623309573931},{"_id":"themes/even/layout/_partial/_post/reward.swig","hash":"2a026a5252082c5cc9fbbb5aedf29770d1d56e62","modified":1623309573931},{"_id":"themes/even/layout/_partial/_post/toc.swig","hash":"3eb2de1ad24607af9497663149730292227022cf","modified":1623309573931},{"_id":"themes/even/layout/_script/_analytics/baidu-analytics.swig","hash":"707864f34f7750a438817acef927f1e4075c5cf8","modified":1623309573932},{"_id":"themes/even/layout/_script/_analytics/google-analytics.swig","hash":"5143d9e510bfd98723a009780ba23aebade21b29","modified":1623309573932},{"_id":"themes/even/layout/_script/_comments/changyan.swig","hash":"a14f06c0ab2eff5c1039cbf199328a62fdc3def8","modified":1623309573933},{"_id":"themes/even/layout/_script/_comments/cusdis.swig","hash":"8bc1430e52c7ba6700430628df1fc7d8b7c6b0c3","modified":1623309573933},{"_id":"themes/even/layout/_script/_comments/disqus.swig","hash":"52009d5092377937af79ea9e391262d34df6d36f","modified":1623309573933},{"_id":"themes/even/layout/_script/_comments/gitalk.swig","hash":"869e4e4bca23ccd9be61fa671dd2b327b5b6e86c","modified":1623309573933},{"_id":"themes/even/layout/_script/_comments/livere.swig","hash":"dfc42123f637b775cf85967476cb8439d19dbe4c","modified":1623309573933},{"_id":"themes/even/layout/_script/_comments/utterances.swig","hash":"5772689ec4c0a772d0e51311535080544fcb2bdd","modified":1623309573933},{"_id":"themes/even/source/css/_common/_animation.scss","hash":"f32d2444f0ab4dcb8b811ae1bccae6073f21a988","modified":1623309573936},{"_id":"themes/even/source/css/_common/_normalize.scss","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1623309573936},{"_id":"themes/even/source/css/_common/_utils.scss","hash":"9ec5b1f6cf47260eba2729ff4931111b808644f0","modified":1623309573937},{"_id":"themes/even/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1623309573937},{"_id":"themes/even/source/css/_partial/_archive.scss","hash":"c0cd7dc3462f7726428a30f5852fcf5577df5961","modified":1623309573937},{"_id":"themes/even/source/css/_partial/_back-to-top.scss","hash":"de94a4546dad90f588e902c9641d94b31fd6625b","modified":1623309573937},{"_id":"themes/even/source/css/_partial/_categories.scss","hash":"96f47000d25ef4e0e948f8f43fa4e2983ff0d746","modified":1623309573938},{"_id":"themes/even/source/css/_partial/_footer.scss","hash":"76f3a72440be8aa1e93d8ddc5ea958777d1545ab","modified":1623309573938},{"_id":"themes/even/source/css/_partial/_header.scss","hash":"4a3e92feef33bed0021f1a65a801c24ee7d5946f","modified":1623309573938},{"_id":"themes/even/source/css/_partial/_iconfont.scss","hash":"6effdc886469ee76f3c66451ef4b04baaecd48ef","modified":1623309573939},{"_id":"themes/even/source/css/_partial/_mathjax.scss","hash":"4005390d40cfc457e4d07dbaf78b718e01b651f4","modified":1623309573939},{"_id":"themes/even/source/css/_partial/_mobile.scss","hash":"0d1c60bd92f8e5db01e7843934251152ec4d6d44","modified":1623309573939},{"_id":"themes/even/source/css/_partial/_pagination.scss","hash":"b24db39534e180ebcebba2e81d91d9f1d534eea1","modified":1623309573939},{"_id":"themes/even/source/css/_partial/_post.scss","hash":"655e8f56328a220b64d54c400990165a015fecd9","modified":1623309573940},{"_id":"themes/even/source/css/_partial/_slideout.scss","hash":"e4820a42698f647a824575b234835b9ce4ac4797","modified":1623309573941},{"_id":"themes/even/source/css/_partial/_tags.scss","hash":"fb4bf54b34291d5b72598a7ba4d3e370c8ad9383","modified":1623309573941},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1623309573942},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1623309573943},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1623309573943},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1623309573944},{"_id":"themes/even/source/js/src/even.js","hash":"e15f39b54da71226e8dca3fa2fa9be8dda1f5e75","modified":1623309573944},{"_id":"themes/even/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1623309573944},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1623309573944},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1623309573945},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1623309573945},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1623309573945},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1623309573945},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1623309573947},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1623309573948},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1623309573949},{"_id":"themes/even/source/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1623309573951},{"_id":"themes/even/source/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1623309573951},{"_id":"themes/even/source/css/_partial/_footer/_copyright.scss","hash":"afbc0f90c674e5cd5fd7509eb1296d60b999d4e1","modified":1623309573938},{"_id":"themes/even/source/css/_partial/_footer/_social.scss","hash":"bca6a1036951c2475278bfbd3a5ce51ff861e9a3","modified":1623309573938},{"_id":"themes/even/source/css/_partial/_header/_logo.scss","hash":"109073dde15146d835bf06faa2f256d1ac658315","modified":1623309573938},{"_id":"themes/even/source/css/_partial/_header/_menu.scss","hash":"454214ab2b5a0ca17d6872068c52bfd01ac02fdc","modified":1623309573939},{"_id":"themes/even/source/css/_partial/_post/_code.scss","hash":"4accdb9fdda9818c700ce309f28575de18e04228","modified":1623309573940},{"_id":"themes/even/source/css/_partial/_post/_content.scss","hash":"7cf29c7af82c31d82f09dedfca09ea2d863b92ff","modified":1623309573940},{"_id":"themes/even/source/css/_partial/_post/_copyright.scss","hash":"3a53f708b9dec34426460e3ad7cb29c335e1f7b8","modified":1623309573940},{"_id":"themes/even/source/css/_partial/_post/_footer.scss","hash":"9f2ab0ac20b2a8bfd315febd387c399f72f43d10","modified":1623309573940},{"_id":"themes/even/source/css/_partial/_post/_toc.scss","hash":"5806ce8d5c4e2d70e12e03ab48327bdebc68c67b","modified":1623309573941},{"_id":"themes/even/source/css/_partial/_post/_reward.scss","hash":"66ec9faa27ed879dc9a2ca59c73ed6bfd5e61dcd","modified":1623309573941},{"_id":"themes/even/source/css/_partial/_post/_header.scss","hash":"f655fc254804e59d1426471f41127f26d06432b6","modified":1623309573940},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1623309573946},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1623309573946},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1623309573946},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1623309573947},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1623309573947},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1623309573947},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1623309573943},{"_id":"themes/even/source/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1623309573950},{"_id":"public/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1623309698473},{"_id":"public/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1623309698473},{"_id":"public/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1623309698473},{"_id":"public/robots.txt","hash":"eed1ebad39b24e7942fcaf8f27da7487eb9f956e","modified":1623309698473},{"_id":"public/css/style.scss","hash":"814c81baf2d6fe1acdaf5319c3fa796c260a2d3c","modified":1623309698473},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1623309698473},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1623309698473},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1623309698473},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1623309698473},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1623309698473},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1623309698473},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1623309698473},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1623309698473},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1623309698473},{"_id":"public/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1623309698473},{"_id":"public/js/src/even.js","hash":"e15f39b54da71226e8dca3fa2fa9be8dda1f5e75","modified":1623309698473},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1623309698473},{"_id":"public/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1623309698473},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1623309698473},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1623309698473},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1623309698473},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1623309698473},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1623309698473},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1623309698473},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1623309698473},{"_id":"public/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1623309698473},{"_id":"public/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1623309698473},{"_id":"themes/even/_config.yml","hash":"5e1dda1f4790a6c733c51164e2450ed86d0ec10c","modified":1623310179546},{"_id":"source/_posts/.DS_Store","hash":"fe5eee8b49e8b0e76cf23a9a9cfbfd7274afeec5","modified":1623318443907},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573520},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573470},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573470},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573509},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573510},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573518},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573511},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1623321573519},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1623326016404},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1623326016405},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1623326016412},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1623326016412},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1623326016413},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1623326016411},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1623326016411},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1623326016407},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1623326016413},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1623326016414},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1623326016415},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1623326016417},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1623326016418},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1623329574194},{"_id":"themes/next/_config.yml","hash":"e96b6787275a66c143cf32b4976aa552a7b14063","modified":1629898204541},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1623326016409},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1623326016418},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1623326016419},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1623326016408},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1623326016420},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1623326016420},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1623326016421},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1623326016422},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1623326016421},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1623326016423},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1623326016423},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1623326016416},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1623321573458},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1623326016424},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1623326016426},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1623326016424},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1623326016425},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1623326016426},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1623326016427},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1623326016427},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1623326016473},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1623326016430},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1623326016474},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1623326016474},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1623326016475},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1623326016475},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1623326016477},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1623326016478},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1623326016662},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1623326016661},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1623326016428},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1623326016409},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1623326016476},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1623326016429},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1623326016430},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1623326016431},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1623326016433},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1623326016434},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1623326016435},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1623326016435},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1623326016479},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1623326016439},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1623326016438},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"20addd5c1f57fccb8b32cce913c7fabe07265bd8","modified":1629897228068},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1623326016440},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1623326016445},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1623326016446},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1623326016450},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1623326016465},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1623326016465},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1623326016466},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1623326016433},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1623326016466},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1623326016467},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1623326016432},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1623326016468},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1623326016480},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1623326016481},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1623326016436},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1623326016481},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1623326016482},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1623326016467},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1623326016483},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1623326016484},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1623326016662},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1623326016483},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1623326016556},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1623326016484},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1623326016485},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1623321573521},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1623321573521},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1623326016558},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1623326016561},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1623326016560},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1623326016562},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1623321573526},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1623321573526},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1623326016561},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1623326016562},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1623326016566},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1623321573527},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1623321573527},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1623326016567},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1623326016568},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1623321573528},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1623326016437},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1623326016437},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1623326016441},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1623326016442},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1623326016442},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1623326016443},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1623326016444},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1623326016444},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1623326016448},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1623326016564},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1623326016440},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1623326016563},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1623326016451},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1623326016447},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1623326016449},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1623326016452},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1623326016454},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1623326016453},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1623326016456},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1623326016454},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1623326016455},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1623326016455},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1623326016457},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1623326016457},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1623326016458},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1623326016460},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1623326016459},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1623326016458},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1623326016460},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1623326016462},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"7a3064a8533fbb0dbfca7032108ef26c99e43898","modified":1623329249506},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1623326016463},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1623326016463},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1623326016462},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1623326016470},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1623326016453},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1623326016473},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1623326016464},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1623326016534},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1623326016472},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1623326016533},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1623326016536},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1623326016536},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1623326016553},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1623326016553},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1623326016554},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1623326016570},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1623326016571},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1623326016572},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1623326016573},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1623326016471},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1623326016575},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1623326016555},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1623326016571},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1623326016574},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1623326016569},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1623326016577},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1623321573537},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1623321573541},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1623326016578},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1623326016592},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1623326016593},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1623326016593},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1623326016605},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1623326016576},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1623326016605},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1623326016606},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1623326016609},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1623326016610},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1623326016610},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1623326016611},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1623326016628},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1623326016630},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1623326016630},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1623326016631},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1623326016632},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1623326016606},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1623326016633},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1623326016633},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1623326016636},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1623321573567},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1623326016635},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1623321573567},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1623321573567},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1623321573567},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1623321573568},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1623321573568},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1623321573568},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1623321573568},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1623321573569},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1623326016611},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1623321573569},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1623321573569},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1623326016637},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1623321573569},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1623326016646},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1623326016647},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1623326016655},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1623326016656},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1623326016648},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1623326016649},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1623326016660},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1623326016659},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1623326016469},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1623326016470},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1623326016487},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1623326016487},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1623326016659},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1623326016488},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1623326016489},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1623326016500},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1623326016489},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1623326016515},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1623326016528},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1623326016529},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1623326016531},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1623326016530},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1623326016532},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1623326016532},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1623321573568},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1623326016539},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1623326016539},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1623326016540},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1623326016540},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1623326016541},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1623326016542},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1623326016545},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1623326016542},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1623326016546},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1623326016545},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1623326016549},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1623326016547},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1623326016549},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1623326016550},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1623326016551},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1623326016551},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1623326016552},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1623326016576},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1623326016531},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1623326016538},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1623321573542},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1623326016583},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1623326016547},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1623321573542},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1623321573543},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1623326016585},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1623326016586},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1623321573543},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1623321573543},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1623321573544},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1623326016602},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1623326016608},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1623321573549},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1623326016603},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1623326016613},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1623326016613},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1623326016614},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1623326016603},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1623326016655},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1623326016490},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1623326016492},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1623326016492},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1623326016491},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1623326016493},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1623326016494},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1623326016496},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1623326016495},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1623326016497},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1623326016497},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1623326016498},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1623326016499},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1623326016499},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1623326016501},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1623326016501},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1623326016502},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1623326016502},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1623326016503},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1623326016504},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1623326016494},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1623326016505},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1623326016505},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1623326016506},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1623326016506},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1623326016507},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1623326016508},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1623326016508},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1623326016516},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1623326016504},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1623326016517},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1623326016517},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1623326016518},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1623326016519},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1623326016520},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1623326016521},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1623326016521},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1623326016510},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1623326016654},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1623326016519},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1623326016510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1623326016511},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1623326016511},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1623326016512},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1623326016513},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1623326016513},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1623326016514},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1623326016514},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1623326016515},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1623326016522},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1623326016509},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1623326016523},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1623326016524},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1623326016525},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1623326016526},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1623326016526},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1623326016527},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1623326016527},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1623326016543},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1623326016544},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1623326016548},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1623321573533},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1623321573534},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1623326016524},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1623321573544},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1623326016599},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1623326016523},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1623321573534},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1623326016600},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1623321573535},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1623321573534},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1623326016601},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1623326016601},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1623326016599},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1623326016629},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1623326016584},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1623321573561},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1623321573562},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1623321573553},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1623321573555},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1623321573561},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1623326016658},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1623326016590},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1623326016622},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1623326016652},{"_id":"themes/next/.DS_Store","hash":"8a6ce871279a3401efad04ef9610c67bdd74b2ad","modified":1623340212324},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1623340226661},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1623328907641},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1623340226661},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1623340226661},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1623328907641},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1623340226661},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1623340226661},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1623340226661},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1623340226661},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1623328907641},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1623340226661},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1623328907641},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1623328907641},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1623340226661},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1623328907641},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1623328907641},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1623340226661},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1623340226661},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1623340226661},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1623328907641},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1623328907641},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1623328907641},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1623328907641},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1623328907641},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1623328907641},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1623340226661},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1623340226661},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1623328907641},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1623328907641},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1623328907641},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1623328907641},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1623328907641},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1623328907641},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1623328907641},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1623328907641},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1623328907641},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1623328907641},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1623328907641},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1623328907641},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1623328907641},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1623328907641},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1623328907641},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1623328907641},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1623328907641},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1623328907641},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1623328907641},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1623328907641},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1623328907641},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1623328907641},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1623328907641},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1623328907641},{"_id":"public/lib/fastclick/README.html","hash":"c88ed76304392b9e77b266fcbbc05f443c5df133","modified":1623328907641},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1623328907641},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1623328907641},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1623328907641},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"bc6cf8951a99074bdc6ec9172f03fb7c0e412729","modified":1623328907641},{"_id":"public/lib/jquery_lazyload/README.html","hash":"96a5c2cc00de5b338ae972c1e8de879d2d919608","modified":1623328907641},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1623328907641},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1623328907641},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1623328907641},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1623328907641},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1623328907641},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1623328907641},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1623328907641},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1623328907641},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1623328907641},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1623328907641},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1623328907641},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1623328907641},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1623328907641},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1623328907641},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1623328907641},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1623328907641},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1623328907641},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1623328907641},{"_id":"public/css/main.css","hash":"42820a29056b4132e6708248e4732e13e855fe09","modified":1623340226661},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1623328907641},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1623328907641},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1623328907641},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1623328907641},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1623328907641},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1623328907641},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1623328907641},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1623328907641},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1623328907641},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1623328907641},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1623328907641},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1623328907641},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1623328907641},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1623328907641},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1623328907641},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1623340226661},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1623328907641},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1623328907641},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1623328907641},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1623328907641},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1623328907641},{"_id":"themes/next/next_config.yml","hash":"b77b5f78494c44f3df657720004aec34f54254ea","modified":1623323760520},{"_id":"themes/next/package-lock.json","hash":"9947e282f9b42e41718daad4f85e632c3ea609f2","modified":1623327721453},{"_id":"public/2021/06/10/hello/index.html","hash":"f8e77b70a7089e5c247f4b698eea91e7a96c0bf2","modified":1629866147266},{"_id":"source/_posts/roadmap.md","hash":"b48b5522a838dbb23bc385ffe4cf449639bae965","modified":1629870323715},{"_id":"source/_posts/vlog.md","hash":"ad64cac0b4cd49c8cd2bca12a2b16ad6236a3c87","modified":1629866127694},{"_id":"public/2021/08/25/vlog/index.html","hash":"d03ffb25f1c57675e17575e5e3b7cd4c436605b2","modified":1629866147266},{"_id":"public/2021/06/11/roadmap/index.html","hash":"b8a7cebe90439d709cac6fc007397a2ce5eda16e","modified":1629866147266},{"_id":"public/archives/2021/08/index.html","hash":"e4e999242cce96cc706e58b06d3662438ebdec9f","modified":1629866147266},{"_id":"public/tags/笔记/index.html","hash":"aa79315c9eca28981d123c700837436e448bc855","modified":1629866147266},{"_id":"source/_posts/wordpress-build.md","hash":"b662779473e1412e1a4c9bd008afc36d0d4e3e74","modified":1629882137027},{"_id":"source/_posts/wordpress-build/wordpress.png","hash":"7b07e32dc78d3ee45eae187320959855257d714a","modified":1629867038653},{"_id":"source/images/wordpress-build/wordpress.png","hash":"7b07e32dc78d3ee45eae187320959855257d714a","modified":1629867038653},{"_id":"source/_drafts/vlog-roadmap.md","hash":"e5fe3b74e56f794265b7236b0e3b7f2339cb252f","modified":1629868867881},{"_id":"source/images/vx.png","hash":"44a45d5e5cc6063c2bcec1d229d392542564e8e6","modified":1629869056244},{"_id":"source/tags/index.md","hash":"a0386462982e23ac79dd951a7edd5ad0f7ed8cdb","modified":1629881048612},{"_id":"source/categories/index.md","hash":"24b549bbaa28e4c6cc51b63b36ee3d1296cefb5f","modified":1629880960666},{"_id":"source/_drafts/work.md","hash":"7943b1f81a302751cce96a07fc75a4b208cfd8eb","modified":1629887894721},{"_id":"source/_posts/app-dev.md","hash":"eccc84453ea1a9279ea523af8be5db9aa3cf2a2e","modified":1629894336661},{"_id":"source/_posts/booknote.md","hash":"aa70fe0b8f418b09535ca5173f2fec3bce24d1b6","modified":1629893664194},{"_id":"source/_posts/cc-proto.md","hash":"b063df5d1ec718b008f012ca7cf45b7a5b3fea50","modified":1629893812548},{"_id":"source/_posts/design-mode.md","hash":"95db00dfebd6d140c895630854263d20232418e4","modified":1629893649954},{"_id":"source/_posts/linux-note.md","hash":"d143be7e6aa4dbaeda748bbb3a4a6e7adfa0372b","modified":1629893639057},{"_id":"source/_posts/redis-note.md","hash":"0226197a41eece9992c7056989f32922ce2c22cd","modified":1629895534742},{"_id":"source/_posts/weex-dev0.md","hash":"7452484726bb0957fee8c3e9a0049e40a96a140d","modified":1629895566288},{"_id":"source/_posts/weex-dev1.md","hash":"d8281f71813974cd2b9e1d6d7d36433b1e5696e8","modified":1629895511222},{"_id":"source/about/index.md","hash":"0637779fb1e0399884df7ebf598292774bf160e4","modified":1629897462860},{"_id":"source/contact/index.md","hash":"fbae46cdb04434ca527d55f92cc553a981ef5f59","modified":1629897495982},{"_id":"source/404/index.md","hash":"dbe9c1c8c63ba1b5fe90705b6654f8e24e5772a0","modified":1629897537788},{"_id":"themes/matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1606456707000},{"_id":"themes/matery/CHANGELOG.md","hash":"084ec8b110a20170d08a0aa5fd8accf601051835","modified":1606456707000},{"_id":"themes/matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1606456707000},{"_id":"themes/matery/README.md","hash":"0366f3d50b18d095b0581e7b5974e3283d693884","modified":1606456707000},{"_id":"themes/matery/README_CN.md","hash":"089de96e2165ea2a8a3adf38ebda85b65e7f716e","modified":1606456707000},{"_id":"themes/matery/_config.yml","hash":"056cf5f020e9a240522808b6872897f6dcee79fa","modified":1606456707000},{"_id":"themes/matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1606456707000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1606456707000},{"_id":"themes/matery/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1606456707000},{"_id":"themes/matery/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1606456707000},{"_id":"themes/matery/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1606456707000},{"_id":"themes/matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1606456707000},{"_id":"themes/matery/layout/bb.ejs","hash":"21959d702f17a3d98b716daf44c8b5eecd59c7c5","modified":1606456707000},{"_id":"themes/matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1606456707000},{"_id":"themes/matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1606456707000},{"_id":"themes/matery/layout/contact.ejs","hash":"19d62e521c4253496db559478db5164ddfd2480e","modified":1606456707000},{"_id":"themes/matery/layout/friends.ejs","hash":"92892bab5578ccf758ce57e19fca08be80d0d5b9","modified":1606456707000},{"_id":"themes/matery/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1606456707000},{"_id":"themes/matery/layout/layout.ejs","hash":"974b44eb3e343cd3ee57ebad34bbb0eff4184400","modified":1606456707000},{"_id":"themes/matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1606456707000},{"_id":"themes/matery/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1606456707000},{"_id":"themes/matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1606456707000},{"_id":"themes/matery/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1606456707000},{"_id":"themes/matery/layout/_widget/artitalk.ejs","hash":"b14e486f12b9ac42a273b80e4d785fcb94cf04b2","modified":1606456707000},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1606456707000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1606456707000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1606456707000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1606456707000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1606456707000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1606456707000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1606456707000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1606456707000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1606456707000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1606456707000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1606456707000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1606456707000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1606456707000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1606456707000},{"_id":"themes/matery/layout/_partial/background.ejs","hash":"aef6edeeb11209831a11d8c7f5d59992e2573335","modified":1606456707000},{"_id":"themes/matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1606456707000},{"_id":"themes/matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1606456707000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"28617bf2a35a4269eba6df466acd174e416d2d1e","modified":1606456707000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1606456707000},{"_id":"themes/matery/layout/_partial/changyan.ejs","hash":"cd919d31564e118c2ee8d5cbfb7d51ee6da15d82","modified":1606456707000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"3be24e4c370671eda53bdfd99fb748f4a22948ba","modified":1606456707000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1606456707000},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1606456707000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1606456707000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1606456707000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1606456707000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"f8438ac80df005934a330b029de292d26f0b6ecb","modified":1606456707000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1606456707000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1606456707000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1606456707000},{"_id":"themes/matery/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1606456707000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1606456707000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1606456707000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"3ff94aff01936242a9f4e1f31adb9b43bfab8d53","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"880ebaf78a947631a38ad0b3d65201315845a264","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1606456707000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1606456707000},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1606456707000},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1606456707000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"150529c9fb9aa8ddb42ec3e02645d301faa2503b","modified":1606456707000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1606456707000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1606456707000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1606456707000},{"_id":"themes/matery/source/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1606456707000},{"_id":"themes/matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1606456707000},{"_id":"themes/matery/source/css/matery.css","hash":"a630f6e8643904073dce9eada57b5c16c4dba5e2","modified":1606456707000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1606456707000},{"_id":"themes/matery/source/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1606456707000},{"_id":"themes/matery/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1606456707000},{"_id":"themes/matery/source/js/search.js","hash":"e1482406c58ea2a0eb178d7e4efb2c879cdddc80","modified":1606456707000},{"_id":"themes/matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1606456707000},{"_id":"themes/matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1606456707000},{"_id":"themes/matery/source/medias/contact.png","hash":"443ea472dd49b74d9d70295837eb381c8c64f02c","modified":1606456707000},{"_id":"themes/matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1606456707000},{"_id":"themes/matery/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1606456707000},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1606456707000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1606456707000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1606456707000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1606456707000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1606456707000},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1606456707000},{"_id":"themes/matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1606456707000},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1606456707000},{"_id":"themes/matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1606456707000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1606456707000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1606456707000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1606456707000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1606456707000},{"_id":"themes/matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1606456707000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1606456707000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1606456707000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1606456707000},{"_id":"themes/matery/source/libs/minivaline/MiniValine.js","hash":"fbb58c37e2c74f127ae0c566afa9b48889aab79f","modified":1606456707000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1606456707000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1606456707000},{"_id":"themes/matery/source/libs/prism/prism.css","hash":"62e5474893dece076534352f564ceabd6e088a5a","modified":1606456707000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1606456707000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1606456707000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1606456707000},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1606456707000},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1606456707000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1606456707000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1606456707000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1606456707000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1606456707000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1606456707000},{"_id":"themes/matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1606456707000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1606456707000},{"_id":"themes/matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1606456707000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1606456707000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1606456707000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1606456707000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1606456707000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1606456707000},{"_id":"source/_posts/cloud-restart.md","hash":"135ff3d35e35b1107d61f4daa117a0fb23e53dc4","modified":1630497041351},{"_id":"source/_posts/cloud-ver.md","hash":"c33cd6ffc10beb9766f59b7c72401cfa4c7bb00f","modified":1630497137403},{"_id":"source/_posts/flutter-dev.md","hash":"f028032896879189eea8bd3498245f0baa08c8b6","modified":1630548219150},{"_id":"source/_posts/garbage-first.md","hash":"b2cf81762c2b7ee5a0ff1c99bc5329c98a193e67","modified":1630495774548},{"_id":"source/_posts/gc-charator.md","hash":"45e688d27b41e8adb4a5f8ee9ace386f901e3ffe","modified":1630497295120},{"_id":"source/_posts/hackathon.md","hash":"ca578fb64f4a33c8b1858b41a355725fb24225e3","modified":1630495937502},{"_id":"source/_posts/https.md","hash":"a227967d92196303f783d445559af99f24e1fe1f","modified":1630496427089},{"_id":"source/_posts/java-hot.md","hash":"df1e15b74363f12741d5b3f4aa13124c755f9ba9","modified":1630033125485},{"_id":"source/_posts/jvm-self.md","hash":"efe52775f2cdfe71f268695fdf260db4f18b2aff","modified":1630496591396},{"_id":"source/_posts/kcp.md","hash":"327ad387ff6506725b5f239af5d83dcfc5c3eacc","modified":1630496237529},{"_id":"source/_posts/limiter.md","hash":"6fb8f04f4f64bf71f2008540b6342aa37b39dcaf","modified":1630327747730},{"_id":"source/_posts/nexus.md","hash":"17f463163b93a42d9a37f3a36fc78032978043d5","modified":1630496043849},{"_id":"source/_posts/redis-pre.md","hash":"8c38b9ed3fedd28201f94dd61cc499b7a37c84ad","modified":1630497218583},{"_id":"source/_posts/sandbox-scene.md","hash":"5104babd68f71899b031b39383376bab6e28a317","modified":1630495729802},{"_id":"source/_posts/srv-optimize.md","hash":"cdce89a6fb24d6ce527668fb134ad1097a0b82d0","modified":1630548219153},{"_id":"source/_posts/wordpress.md","hash":"242113799990dfccfe04db1968c9a9fa927965a4","modified":1630332814041},{"_id":"source/_posts/zset.md","hash":"5d08c3f123ad2b7de1c9eb2165e2f7ff59cb70a6","modified":1630496340730},{"_id":"source/_posts/geohash.md","hash":"699b47f1b43e8d8172d91944dcf94fd43dfd5f28","modified":1630037126586},{"_id":"source/_posts/java-hot/hot.png","hash":"a01c47fa721d0abc9bf55fa9172efd436fd9a136","modified":1630032987404},{"_id":"source/_posts/ali2tx.md","hash":"2a413574f7c9c9e02247c1fb4f7525553bd22bd4","modified":1630037259783},{"_id":"source/_posts/gamenote0.md","hash":"19b9560c3212c5a01680f7c74c73c0dcdbb1b963","modified":1630036764965},{"_id":"source/_posts/mvn-git.md","hash":"920c7d207b34f73866e33a8e00b4d9a124ebbc21","modified":1630033213032},{"_id":"source/_posts/jvm-remote.md","hash":"c14283c35208e45d52627d38c5c7152a7ed22de7","modified":1630033221473},{"_id":"source/_posts/notice.md","hash":"5161ce36d81e28b5794ffbac3ebbfcc979a01dbe","modified":1630548219152},{"_id":"source/_posts/golang-summary.md","hash":"7669cefd66c102a4f4668b0dd3e3a875068bc95c","modified":1630548219151}],"Category":[{"name":"WEB开发","_id":"cksr2lsxy000080mnao5hel1o"},{"name":"笔记","_id":"cksr2m80l000280mnh3x39nkl"},{"name":"公告","_id":"ckt2dv7s90004wcmn7yv66ft7"}],"Data":[],"Page":[{"title":"tags","date":"2021-08-25T08:43:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-08-25 16:43:26\ntype: \"tags\"\n---\n","updated":"2021-08-25T08:44:08.612Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cksr93i7a00003omndyepblnz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2021-08-25T08:41:38.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2021-08-25 16:41:38\ntype: \"categories\"\n---\n\n","updated":"2021-08-25T08:42:40.666Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cksr93i7c00013omnhj6711oz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2021-08-25T13:16:58.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-08-25 21:16:58\ntype: \"about\"\n---\n","updated":"2021-08-25T13:56:26.949Z","path":"about/index.html","_id":"cksriu9as0000j8mn5a2yg3bv","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"contact","date":"2021-08-25T13:18:00.000Z","type":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2021-08-25 21:18:00\ntype: \"contact\"\n---\n","updated":"2021-08-25T13:18:15.982Z","path":"contact/index.html","_id":"cksrivktz0001j8mn2os8e53n","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"404","date":"2021-08-25T13:18:43.000Z","type":404,"_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2021-08-25 21:18:43\ntype: 404\n---\n","updated":"2021-08-25T13:18:57.788Z","path":"404/index.html","_id":"cksriwhv20002j8mn3n8w5x57","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"WordPress迁移Hexo","date":"2021-06-10T15:50:05.000Z","id":"hello","_content":"\n# 搬[新家](http://kwaibook.com)了！\n\n在用了三年多WordPress后还是决定尝试下使用一些轻量的框架来搭建站点，比如Hexo。\n放弃WordPress主要出于以下几个方面的考虑吧：\n1. 成本：需要单独的服务器部署。\n2. 效率：功能大而全，便利性方面还是很好的，但是敏捷性方面就稍显欠缺了，而Hexo支持MD语法，大大激活创作效率。\n3. 性能：网页加载图片的速度较慢。\n4. 美观：简洁才是王道\n5. 杀鸡用牛刀：在个人站点方面，静态的Hexo完全够了。\n\n<!--more-->\n\n站点搭建完了，现在的方案是，本地编写MD文件，提交Github，Travis自动发布。\n皮肤：[next](http://theme-next.iissnan.com/getting-started.html)\n后续需要的插件陆续添加吧。\n主要参考的文章：\n\n* [Travis CI](https://segmentfault.com/a/1190000021987832)\n* [Hexo部署](https://kchen.cc/2016/11/12/hexo-instructions/)\n\n# 常用笔记\n1. 新建博文：hexo new post $title\n2. 新建草稿：hexo new draft $title\n3. 文章目录：source\\_posts\n4. 图片目录：source\\images\n5. https://typora.io/ markdown工具\n6. [Markdown语法](https://markdown.com.cn/basic-syntax/links.html)\n7. [参考链接](http://blog.smallerpig.com/set-hexo-show-more-button-on-indexpage.html)\n9. [参考链接](https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/)\n9. [met皮肤](https://huyongfei.com/posts/2324b80c.html)\n\n# hexo博客插入图片与视频方法\n### 图片插入\nHexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。\n### 本地引用–绝对路径\n当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。\n```\nsource/images/image.jpg\n\n![(可以写关于图片的描述)](/images/image.jpg)\n```\n图片既可以在首页内容中访问到，也可以在文章正文中访问到。\n### 本地引用–相对路径\n图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。\n```\n_config.yml\n\npost_asset_folder: true\n```\n将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成\n文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。\n```\n_posts/post_name/image.jpg\n\n![](image.jpg)\n```\n上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。  \n如果希望图片在文章和首页中同时显示，可以使用标签插件语法。\n```\n_posts/post_name/image.jpg\n\n{% asset_img image.jpg This is an image %}\n```\n### CDN引用\n除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。\n比如[Cloudinary](https://cloudinary.com/)（梯子访问）提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。或者上传到[路过图床](https://imgtu.com/)（不用梯子）。\n下面是路过图床上传的图片，引用格式从路过图床复制过来即可。\n[![hVCDOI.png](https://z3.ax1x.com/2021/08/25/hVCDOI.png)](https://imgtu.com/i/hVCDOI)\n### 视频插入\n插入视频与图片不同，这里以b站的视频为例\n```\n<iframe src=\"（视频网址）\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"100%\"  height=\"580\" quality=\"high\" > </iframe>\n```\n这样直接插入的代码手机端不能自适应，效果不完美。\n**最好这样**\n```\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe \nsrc=\"//player.bilibili.com/player.html?aid=39807850&cid=69927212&page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n```","source":"_posts/hello.md","raw":"---\ntitle: WordPress迁移Hexo\ndate: 2021-06-10 23:50:05\ntags: \n\t- 笔记\nid: hello\ncategories:\n\t- 笔记\n---\n\n# 搬[新家](http://kwaibook.com)了！\n\n在用了三年多WordPress后还是决定尝试下使用一些轻量的框架来搭建站点，比如Hexo。\n放弃WordPress主要出于以下几个方面的考虑吧：\n1. 成本：需要单独的服务器部署。\n2. 效率：功能大而全，便利性方面还是很好的，但是敏捷性方面就稍显欠缺了，而Hexo支持MD语法，大大激活创作效率。\n3. 性能：网页加载图片的速度较慢。\n4. 美观：简洁才是王道\n5. 杀鸡用牛刀：在个人站点方面，静态的Hexo完全够了。\n\n<!--more-->\n\n站点搭建完了，现在的方案是，本地编写MD文件，提交Github，Travis自动发布。\n皮肤：[next](http://theme-next.iissnan.com/getting-started.html)\n后续需要的插件陆续添加吧。\n主要参考的文章：\n\n* [Travis CI](https://segmentfault.com/a/1190000021987832)\n* [Hexo部署](https://kchen.cc/2016/11/12/hexo-instructions/)\n\n# 常用笔记\n1. 新建博文：hexo new post $title\n2. 新建草稿：hexo new draft $title\n3. 文章目录：source\\_posts\n4. 图片目录：source\\images\n5. https://typora.io/ markdown工具\n6. [Markdown语法](https://markdown.com.cn/basic-syntax/links.html)\n7. [参考链接](http://blog.smallerpig.com/set-hexo-show-more-button-on-indexpage.html)\n9. [参考链接](https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/)\n9. [met皮肤](https://huyongfei.com/posts/2324b80c.html)\n\n# hexo博客插入图片与视频方法\n### 图片插入\nHexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。\n### 本地引用–绝对路径\n当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。\n```\nsource/images/image.jpg\n\n![(可以写关于图片的描述)](/images/image.jpg)\n```\n图片既可以在首页内容中访问到，也可以在文章正文中访问到。\n### 本地引用–相对路径\n图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。\n```\n_config.yml\n\npost_asset_folder: true\n```\n将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成\n文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。\n```\n_posts/post_name/image.jpg\n\n![](image.jpg)\n```\n上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。  \n如果希望图片在文章和首页中同时显示，可以使用标签插件语法。\n```\n_posts/post_name/image.jpg\n\n{% asset_img image.jpg This is an image %}\n```\n### CDN引用\n除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。\n比如[Cloudinary](https://cloudinary.com/)（梯子访问）提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。或者上传到[路过图床](https://imgtu.com/)（不用梯子）。\n下面是路过图床上传的图片，引用格式从路过图床复制过来即可。\n[![hVCDOI.png](https://z3.ax1x.com/2021/08/25/hVCDOI.png)](https://imgtu.com/i/hVCDOI)\n### 视频插入\n插入视频与图片不同，这里以b站的视频为例\n```\n<iframe src=\"（视频网址）\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"100%\"  height=\"580\" quality=\"high\" > </iframe>\n```\n这样直接插入的代码手机端不能自适应，效果不完美。\n**最好这样**\n```\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe \nsrc=\"//player.bilibili.com/player.html?aid=39807850&cid=69927212&page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n```","slug":"hello","published":1,"updated":"2021-08-25T13:57:59.268Z","_id":"ckpqi95k00000e9lw258vf7vr","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"搬新家了！\"><a href=\"#搬新家了！\" class=\"headerlink\" title=\"搬新家了！\"></a>搬<a href=\"http://kwaibook.com/\">新家</a>了！</h1><p>在用了三年多WordPress后还是决定尝试下使用一些轻量的框架来搭建站点，比如Hexo。<br>放弃WordPress主要出于以下几个方面的考虑吧：</p>\n<ol>\n<li>成本：需要单独的服务器部署。</li>\n<li>效率：功能大而全，便利性方面还是很好的，但是敏捷性方面就稍显欠缺了，而Hexo支持MD语法，大大激活创作效率。</li>\n<li>性能：网页加载图片的速度较慢。</li>\n<li>美观：简洁才是王道</li>\n<li>杀鸡用牛刀：在个人站点方面，静态的Hexo完全够了。</li>\n</ol>\n<span id=\"more\"></span>\n\n<p>站点搭建完了，现在的方案是，本地编写MD文件，提交Github，Travis自动发布。<br>皮肤：<a href=\"http://theme-next.iissnan.com/getting-started.html\">next</a><br>后续需要的插件陆续添加吧。<br>主要参考的文章：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000021987832\">Travis CI</a></li>\n<li><a href=\"https://kchen.cc/2016/11/12/hexo-instructions/\">Hexo部署</a></li>\n</ul>\n<h1 id=\"常用笔记\"><a href=\"#常用笔记\" class=\"headerlink\" title=\"常用笔记\"></a>常用笔记</h1><ol>\n<li>新建博文：hexo new post $title</li>\n<li>新建草稿：hexo new draft $title</li>\n<li>文章目录：source_posts</li>\n<li>图片目录：source\\images</li>\n<li><a href=\"https://typora.io/\">https://typora.io/</a> markdown工具</li>\n<li><a href=\"https://markdown.com.cn/basic-syntax/links.html\">Markdown语法</a></li>\n<li><a href=\"http://blog.smallerpig.com/set-hexo-show-more-button-on-indexpage.html\">参考链接</a></li>\n<li><a href=\"https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/\">参考链接</a></li>\n<li><a href=\"https://huyongfei.com/posts/2324b80c.html\">met皮肤</a></li>\n</ol>\n<h1 id=\"hexo博客插入图片与视频方法\"><a href=\"#hexo博客插入图片与视频方法\" class=\"headerlink\" title=\"hexo博客插入图片与视频方法\"></a>hexo博客插入图片与视频方法</h1><h3 id=\"图片插入\"><a href=\"#图片插入\" class=\"headerlink\" title=\"图片插入\"></a>图片插入</h3><p>Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。</p>\n<h3 id=\"本地引用–绝对路径\"><a href=\"#本地引用–绝对路径\" class=\"headerlink\" title=\"本地引用–绝对路径\"></a>本地引用–绝对路径</h3><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source/images/image.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">![(可以写关于图片的描述)](/images/image.jpg)</span><br></pre></td></tr></table></figure>\n<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>\n<h3 id=\"本地引用–相对路径\"><a href=\"#本地引用–相对路径\" class=\"headerlink\" title=\"本地引用–相对路径\"></a>本地引用–相对路径</h3><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\"></span><br><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure>\n<p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成<br>文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_posts/post_name/image.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">![](image.jpg)</span><br></pre></td></tr></table></figure>\n<p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_posts/post_name/image.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CDN引用\"><a href=\"#CDN引用\" class=\"headerlink\" title=\"CDN引用\"></a>CDN引用</h3><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。<br>比如<a href=\"https://cloudinary.com/\">Cloudinary</a>（梯子访问）提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。或者上传到<a href=\"https://imgtu.com/\">路过图床</a>（不用梯子）。<br>下面是路过图床上传的图片，引用格式从路过图床复制过来即可。<br><a href=\"https://imgtu.com/i/hVCDOI\"><img src=\"https://z3.ax1x.com/2021/08/25/hVCDOI.png\" alt=\"hVCDOI.png\"></a></p>\n<h3 id=\"视频插入\"><a href=\"#视频插入\" class=\"headerlink\" title=\"视频插入\"></a>视频插入</h3><p>插入视频与图片不同，这里以b站的视频为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe src=&quot;（视频网址）&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;100%&quot;  height=&quot;580&quot; quality=&quot;high&quot; &gt; &lt;/iframe&gt;</span><br></pre></td></tr></table></figure>\n<p>这样直接插入的代码手机端不能自适应，效果不完美。<br><strong>最好这样</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe </span><br><span class=\"line\">src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; </span><br><span class=\"line\">frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; </span><br><span class=\"line\">height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"搬新家了！\"><a href=\"#搬新家了！\" class=\"headerlink\" title=\"搬新家了！\"></a>搬<a href=\"http://kwaibook.com/\">新家</a>了！</h1><p>在用了三年多WordPress后还是决定尝试下使用一些轻量的框架来搭建站点，比如Hexo。<br>放弃WordPress主要出于以下几个方面的考虑吧：</p>\n<ol>\n<li>成本：需要单独的服务器部署。</li>\n<li>效率：功能大而全，便利性方面还是很好的，但是敏捷性方面就稍显欠缺了，而Hexo支持MD语法，大大激活创作效率。</li>\n<li>性能：网页加载图片的速度较慢。</li>\n<li>美观：简洁才是王道</li>\n<li>杀鸡用牛刀：在个人站点方面，静态的Hexo完全够了。</li>\n</ol>","more":"<p>站点搭建完了，现在的方案是，本地编写MD文件，提交Github，Travis自动发布。<br>皮肤：<a href=\"http://theme-next.iissnan.com/getting-started.html\">next</a><br>后续需要的插件陆续添加吧。<br>主要参考的文章：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000021987832\">Travis CI</a></li>\n<li><a href=\"https://kchen.cc/2016/11/12/hexo-instructions/\">Hexo部署</a></li>\n</ul>\n<h1 id=\"常用笔记\"><a href=\"#常用笔记\" class=\"headerlink\" title=\"常用笔记\"></a>常用笔记</h1><ol>\n<li>新建博文：hexo new post $title</li>\n<li>新建草稿：hexo new draft $title</li>\n<li>文章目录：source_posts</li>\n<li>图片目录：source\\images</li>\n<li><a href=\"https://typora.io/\">https://typora.io/</a> markdown工具</li>\n<li><a href=\"https://markdown.com.cn/basic-syntax/links.html\">Markdown语法</a></li>\n<li><a href=\"http://blog.smallerpig.com/set-hexo-show-more-button-on-indexpage.html\">参考链接</a></li>\n<li><a href=\"https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/\">参考链接</a></li>\n<li><a href=\"https://huyongfei.com/posts/2324b80c.html\">met皮肤</a></li>\n</ol>\n<h1 id=\"hexo博客插入图片与视频方法\"><a href=\"#hexo博客插入图片与视频方法\" class=\"headerlink\" title=\"hexo博客插入图片与视频方法\"></a>hexo博客插入图片与视频方法</h1><h3 id=\"图片插入\"><a href=\"#图片插入\" class=\"headerlink\" title=\"图片插入\"></a>图片插入</h3><p>Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。</p>\n<h3 id=\"本地引用–绝对路径\"><a href=\"#本地引用–绝对路径\" class=\"headerlink\" title=\"本地引用–绝对路径\"></a>本地引用–绝对路径</h3><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source/images/image.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">![(可以写关于图片的描述)](/images/image.jpg)</span><br></pre></td></tr></table></figure>\n<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>\n<h3 id=\"本地引用–相对路径\"><a href=\"#本地引用–相对路径\" class=\"headerlink\" title=\"本地引用–相对路径\"></a>本地引用–相对路径</h3><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml</span><br><span class=\"line\"></span><br><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure>\n<p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成<br>文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_posts/post_name/image.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">![](image.jpg)</span><br></pre></td></tr></table></figure>\n<p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_posts/post_name/image.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CDN引用\"><a href=\"#CDN引用\" class=\"headerlink\" title=\"CDN引用\"></a>CDN引用</h3><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。<br>比如<a href=\"https://cloudinary.com/\">Cloudinary</a>（梯子访问）提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。或者上传到<a href=\"https://imgtu.com/\">路过图床</a>（不用梯子）。<br>下面是路过图床上传的图片，引用格式从路过图床复制过来即可。<br><a href=\"https://imgtu.com/i/hVCDOI\"><img src=\"https://z3.ax1x.com/2021/08/25/hVCDOI.png\" alt=\"hVCDOI.png\"></a></p>\n<h3 id=\"视频插入\"><a href=\"#视频插入\" class=\"headerlink\" title=\"视频插入\"></a>视频插入</h3><p>插入视频与图片不同，这里以b站的视频为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe src=&quot;（视频网址）&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;100%&quot;  height=&quot;580&quot; quality=&quot;high&quot; &gt; &lt;/iframe&gt;</span><br></pre></td></tr></table></figure>\n<p>这样直接插入的代码手机端不能自适应，效果不完美。<br><strong>最好这样</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe </span><br><span class=\"line\">src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; </span><br><span class=\"line\">frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; </span><br><span class=\"line\">height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>"},{"title":"RoadMap","date":"2021-06-10T16:15:42.000Z","id":"roadmap","_content":"\nRoadMap\n\n规划\n\n* 双周产出一篇文章\n* 迁移WordPress的文章\n* 总结Golang的一系列文章\n* Golang stream作业\n* C++学习\n* TX\n","source":"_posts/roadmap.md","raw":"---\ntitle: RoadMap\ndate: 2021-06-11 00:15:42\ntags:\n\t- 笔记\nid: roadmap\ncategories:\n\t- 笔记\n---\n\nRoadMap\n\n规划\n\n* 双周产出一篇文章\n* 迁移WordPress的文章\n* 总结Golang的一系列文章\n* Golang stream作业\n* C++学习\n* TX\n","slug":"roadmap","published":1,"updated":"2021-08-25T05:45:23.715Z","_id":"cksr02cky00009kmn3ehn9lja","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RoadMap</p>\n<p>规划</p>\n<ul>\n<li>双周产出一篇文章</li>\n<li>迁移WordPress的文章</li>\n<li>总结Golang的一系列文章</li>\n<li>Golang stream作业</li>\n<li>C++学习</li>\n<li>TX</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>RoadMap</p>\n<p>规划</p>\n<ul>\n<li>双周产出一篇文章</li>\n<li>迁移WordPress的文章</li>\n<li>总结Golang的一系列文章</li>\n<li>Golang stream作业</li>\n<li>C++学习</li>\n<li>TX</li>\n</ul>\n"},{"title":"搭建WordPress个人站点","date":"2016-10-01T04:49:39.000Z","id":"wordpress-build","_content":"\n[![hZViiq.md.png](https://z3.ax1x.com/2021/08/25/hZViiq.md.png)](https://imgtu.com/i/hZViiq)\n\n## LAMPP+WordPress搭建\n### 官网：https://wordpress.org/\n### 中文网：https://cn.wordpress.org/\n\n<!--more-->\n\n下载tar包，解压到lampp/htdocs文件夹下文件夹，修改成自己喜欢的名。  \n访问站点。如：http://47.95.10.167/站点文件夹名  \n设置数据库（数据库需要先建库），设置admin等信息。（配置文件存储在站点文件夹/wp-config.php文件）  \n使用域名访问指定博客  \n重定向。在xampp目录下修改文件重定向，我的机器在/opt/lampp/htdocs/目录下。修改index.php如下：  \n```\n<?php\n\tif (!empty($_SERVER['HTTPS']) && ('on' == $_SERVER['HTTPS'])) {\n\t\t$uri = 'https://';\n\t} else {\n\t\t$uri = 'http://';\n\t}\n\t$uri .= $_SERVER['HTTP_HOST'];\n\theader('Location: '.$uri.'/blog/');\n\texit;\n?>\n```\n","source":"_posts/wordpress-build.md","raw":"---\ntitle: 搭建WordPress个人站点\ndate: 2016-10-01 12:49:39\ntags: \n\t- 笔记\nid: wordpress-build\ncategories:\n\t- 笔记\n---\n\n[![hZViiq.md.png](https://z3.ax1x.com/2021/08/25/hZViiq.md.png)](https://imgtu.com/i/hZViiq)\n\n## LAMPP+WordPress搭建\n### 官网：https://wordpress.org/\n### 中文网：https://cn.wordpress.org/\n\n<!--more-->\n\n下载tar包，解压到lampp/htdocs文件夹下文件夹，修改成自己喜欢的名。  \n访问站点。如：http://47.95.10.167/站点文件夹名  \n设置数据库（数据库需要先建库），设置admin等信息。（配置文件存储在站点文件夹/wp-config.php文件）  \n使用域名访问指定博客  \n重定向。在xampp目录下修改文件重定向，我的机器在/opt/lampp/htdocs/目录下。修改index.php如下：  \n```\n<?php\n\tif (!empty($_SERVER['HTTPS']) && ('on' == $_SERVER['HTTPS'])) {\n\t\t$uri = 'https://';\n\t} else {\n\t\t$uri = 'http://';\n\t}\n\t$uri .= $_SERVER['HTTP_HOST'];\n\theader('Location: '.$uri.'/blog/');\n\texit;\n?>\n```\n","slug":"wordpress-build","published":1,"updated":"2021-08-25T09:02:17.027Z","_id":"cksr0voz100006cmn3kswbl5v","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://imgtu.com/i/hZViiq\"><img src=\"https://z3.ax1x.com/2021/08/25/hZViiq.md.png\" alt=\"hZViiq.md.png\"></a></p>\n<h2 id=\"LAMPP-WordPress搭建\"><a href=\"#LAMPP-WordPress搭建\" class=\"headerlink\" title=\"LAMPP+WordPress搭建\"></a>LAMPP+WordPress搭建</h2><h3 id=\"官网：https-wordpress-org\"><a href=\"#官网：https-wordpress-org\" class=\"headerlink\" title=\"官网：https://wordpress.org/\"></a>官网：<a href=\"https://wordpress.org/\">https://wordpress.org/</a></h3><h3 id=\"中文网：https-cn-wordpress-org\"><a href=\"#中文网：https-cn-wordpress-org\" class=\"headerlink\" title=\"中文网：https://cn.wordpress.org/\"></a>中文网：<a href=\"https://cn.wordpress.org/\">https://cn.wordpress.org/</a></h3><span id=\"more\"></span>\n\n<p>下载tar包，解压到lampp/htdocs文件夹下文件夹，修改成自己喜欢的名。<br>访问站点。如：<a href=\"http://47.95.10.167/%E7%AB%99%E7%82%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D\">http://47.95.10.167/站点文件夹名</a><br>设置数据库（数据库需要先建库），设置admin等信息。（配置文件存储在站点文件夹/wp-config.php文件）<br>使用域名访问指定博客<br>重定向。在xampp目录下修改文件重定向，我的机器在/opt/lampp/htdocs/目录下。修改index.php如下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">\tif (!empty($_SERVER[&#x27;HTTPS&#x27;]) &amp;&amp; (&#x27;on&#x27; == $_SERVER[&#x27;HTTPS&#x27;])) &#123;</span><br><span class=\"line\">\t\t$uri = &#x27;https://&#x27;;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t$uri = &#x27;http://&#x27;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t$uri .= $_SERVER[&#x27;HTTP_HOST&#x27;];</span><br><span class=\"line\">\theader(&#x27;Location: &#x27;.$uri.&#x27;/blog/&#x27;);</span><br><span class=\"line\">\texit;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://imgtu.com/i/hZViiq\"><img src=\"https://z3.ax1x.com/2021/08/25/hZViiq.md.png\" alt=\"hZViiq.md.png\"></a></p>\n<h2 id=\"LAMPP-WordPress搭建\"><a href=\"#LAMPP-WordPress搭建\" class=\"headerlink\" title=\"LAMPP+WordPress搭建\"></a>LAMPP+WordPress搭建</h2><h3 id=\"官网：https-wordpress-org\"><a href=\"#官网：https-wordpress-org\" class=\"headerlink\" title=\"官网：https://wordpress.org/\"></a>官网：<a href=\"https://wordpress.org/\">https://wordpress.org/</a></h3><h3 id=\"中文网：https-cn-wordpress-org\"><a href=\"#中文网：https-cn-wordpress-org\" class=\"headerlink\" title=\"中文网：https://cn.wordpress.org/\"></a>中文网：<a href=\"https://cn.wordpress.org/\">https://cn.wordpress.org/</a></h3>","more":"<p>下载tar包，解压到lampp/htdocs文件夹下文件夹，修改成自己喜欢的名。<br>访问站点。如：<a href=\"http://47.95.10.167/%E7%AB%99%E7%82%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D\">http://47.95.10.167/站点文件夹名</a><br>设置数据库（数据库需要先建库），设置admin等信息。（配置文件存储在站点文件夹/wp-config.php文件）<br>使用域名访问指定博客<br>重定向。在xampp目录下修改文件重定向，我的机器在/opt/lampp/htdocs/目录下。修改index.php如下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">\tif (!empty($_SERVER[&#x27;HTTPS&#x27;]) &amp;&amp; (&#x27;on&#x27; == $_SERVER[&#x27;HTTPS&#x27;])) &#123;</span><br><span class=\"line\">\t\t$uri = &#x27;https://&#x27;;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t$uri = &#x27;http://&#x27;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t$uri .= $_SERVER[&#x27;HTTP_HOST&#x27;];</span><br><span class=\"line\">\theader(&#x27;Location: &#x27;.$uri.&#x27;/blog/&#x27;);</span><br><span class=\"line\">\texit;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>"},{"title":"vlog蓝图计划","_content":"\n三十五被互联网优化程序员系列\n视频定位，小的不迷路，大的不迷茫","source":"_drafts/vlog-roadmap.md","raw":"---\ntitle: vlog蓝图计划\ntags:\n\t- 笔记\n---\n\n三十五被互联网优化程序员系列\n视频定位，小的不迷路，大的不迷茫","slug":"vlog-roadmap","published":0,"date":"2021-08-25T05:19:20.927Z","updated":"2021-08-25T05:21:07.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksr24dk500005gmn8rso7lhc","content":"<p>三十五被互联网优化程序员系列<br>视频定位，小的不迷路，大的不迷茫</p>\n","site":{"data":{}},"excerpt":"","more":"<p>三十五被互联网优化程序员系列<br>视频定位，小的不迷路，大的不迷茫</p>\n"},{"title":"work","id":"work","_content":"\n#### 工作总结\n\n- 工具\n  - 项目脚手架。服务器/机器人/TCP/HTTP/WS\n  - 多语言配置。java/cs/lua/ts/cpp/uecpp\n  - 平台工具，tcc、settings\n  - 通知机制。\n- 通用服务\n  - 货币服务。芒果斗地主在用\n  - 智能运营平台。P2、P3、P7在用，海外和国内\n  - 匹配服务。P5、P7在用。这块需要再看下！\n  - 网关服务。这块需要再看下！\n  - 抖音社交服务。\n- 框架\n  - 整合公司基础设施，容器化。\n  - 日志，服务发现，数据埋点\n  - 性能监控\n  - 流控，这块需要再看下！\n  - 异步RPC\n  - 多种协议加密支持。ChaCha20、AES\n- 性能调优\n  - P7春节活动\n\n#### leetcode做过的题过一遍\n\n#### sandbox项目过一遍\n\n","source":"_drafts/work.md","raw":"---\ntitle: work\ntags:\n  - 笔记\nid: work\ncategories:\n  - 笔记\n---\n\n#### 工作总结\n\n- 工具\n  - 项目脚手架。服务器/机器人/TCP/HTTP/WS\n  - 多语言配置。java/cs/lua/ts/cpp/uecpp\n  - 平台工具，tcc、settings\n  - 通知机制。\n- 通用服务\n  - 货币服务。芒果斗地主在用\n  - 智能运营平台。P2、P3、P7在用，海外和国内\n  - 匹配服务。P5、P7在用。这块需要再看下！\n  - 网关服务。这块需要再看下！\n  - 抖音社交服务。\n- 框架\n  - 整合公司基础设施，容器化。\n  - 日志，服务发现，数据埋点\n  - 性能监控\n  - 流控，这块需要再看下！\n  - 异步RPC\n  - 多种协议加密支持。ChaCha20、AES\n- 性能调优\n  - P7春节活动\n\n#### leetcode做过的题过一遍\n\n#### sandbox项目过一遍\n\n","slug":"work","published":0,"date":"2021-08-25T09:24:25.230Z","updated":"2021-08-25T10:38:14.721Z","_id":"cksraj6r90000ssmn11gqcrsf","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"工作总结\"><a href=\"#工作总结\" class=\"headerlink\" title=\"工作总结\"></a>工作总结</h4><ul>\n<li>工具<ul>\n<li>项目脚手架。服务器/机器人/TCP/HTTP/WS</li>\n<li>多语言配置。java/cs/lua/ts/cpp/uecpp</li>\n<li>平台工具，tcc、settings</li>\n<li>通知机制。</li>\n</ul>\n</li>\n<li>通用服务<ul>\n<li>货币服务。芒果斗地主在用</li>\n<li>智能运营平台。P2、P3、P7在用，海外和国内</li>\n<li>匹配服务。P5、P7在用。这块需要再看下！</li>\n<li>网关服务。这块需要再看下！</li>\n<li>抖音社交服务。</li>\n</ul>\n</li>\n<li>框架<ul>\n<li>整合公司基础设施，容器化。</li>\n<li>日志，服务发现，数据埋点</li>\n<li>性能监控</li>\n<li>流控，这块需要再看下！</li>\n<li>异步RPC</li>\n<li>多种协议加密支持。ChaCha20、AES</li>\n</ul>\n</li>\n<li>性能调优<ul>\n<li>P7春节活动</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"leetcode做过的题过一遍\"><a href=\"#leetcode做过的题过一遍\" class=\"headerlink\" title=\"leetcode做过的题过一遍\"></a>leetcode做过的题过一遍</h4><h4 id=\"sandbox项目过一遍\"><a href=\"#sandbox项目过一遍\" class=\"headerlink\" title=\"sandbox项目过一遍\"></a>sandbox项目过一遍</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"工作总结\"><a href=\"#工作总结\" class=\"headerlink\" title=\"工作总结\"></a>工作总结</h4><ul>\n<li>工具<ul>\n<li>项目脚手架。服务器/机器人/TCP/HTTP/WS</li>\n<li>多语言配置。java/cs/lua/ts/cpp/uecpp</li>\n<li>平台工具，tcc、settings</li>\n<li>通知机制。</li>\n</ul>\n</li>\n<li>通用服务<ul>\n<li>货币服务。芒果斗地主在用</li>\n<li>智能运营平台。P2、P3、P7在用，海外和国内</li>\n<li>匹配服务。P5、P7在用。这块需要再看下！</li>\n<li>网关服务。这块需要再看下！</li>\n<li>抖音社交服务。</li>\n</ul>\n</li>\n<li>框架<ul>\n<li>整合公司基础设施，容器化。</li>\n<li>日志，服务发现，数据埋点</li>\n<li>性能监控</li>\n<li>流控，这块需要再看下！</li>\n<li>异步RPC</li>\n<li>多种协议加密支持。ChaCha20、AES</li>\n</ul>\n</li>\n<li>性能调优<ul>\n<li>P7春节活动</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"leetcode做过的题过一遍\"><a href=\"#leetcode做过的题过一遍\" class=\"headerlink\" title=\"leetcode做过的题过一遍\"></a>leetcode做过的题过一遍</h4><h4 id=\"sandbox项目过一遍\"><a href=\"#sandbox项目过一遍\" class=\"headerlink\" title=\"sandbox项目过一遍\"></a>sandbox项目过一遍</h4>"},{"title":"设计模式笔记","date":"2017-04-01T10:40:51.000Z","id":"design-mode","_content":"\n1.简单工厂模式\n\n2.策略模式\n\n<!--more-->\n\n策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。\n\n策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。\n\n3.单一职责原则\n\n规则总是很美好，呵呵\n\n就一个类而言，应该仅有一个引起它变化的原因。\n\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。\n\n如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n4.开放-封闭原则\n\n开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n\n对于扩展是开放的，对于更改是封闭的。\n\n无论模块是多么封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。\n\n等到变化发生时立即采取行动。\n\n开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n\n5.依赖倒转原则\n\n高层模块不应该依赖低层模块，两个都应该依赖抽象。\n\n抽象不应该依赖细节，细节应该依赖抽象。\n\n里氏代换原则：子类型必须能够替换掉它们的父类型。\n\n6.装饰模式\n\n装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n\n```\nPerson穿衣服为例：\nabstract class Show {\n\npublic abstract void show();\n\n}\n\nclass Persion : Show {\n\npublic override void show() { 具体实现 }\n\n}\n\nabstract class Decorator : Show {\n\nprotected Show show;\n\npublic void setDecorator(Show show) {\n\nthis.show = show;\n\n}\n\npublic override void show() {\n\nif (show != null) {\n\nshow.show();\n\n}\n\n}\n\n}\n\nclass DecoratorA : Decorator {\n\npublic override void show() { super.show(); 具体实现; }\n\n}\n\n装饰模式：\n\nPerson p = new Person();\n\nDecoratorA da = new DecoratorA();\n\nDecoratorB db = new DecoratorB();\n\nDecoratorC dc = new DecoratorC();\n\nda.setDecorator(p);\n\ndb.setDecorator(da);\n\ndc.setDecorator(db);\n\ndc.show();\n```\n\n7.代理模式\n\n代理模式：为其他对象提供一种代理以控制对这个对象的访问。\n\n```abstract class Subject {\npublic abstract void request();\n\n}\n\nclass RealSubject : Subject {\n\npublic override void request() {实现}\n\n}\n\nclass Proxy : Subject {\n\nRealSubject realSubject;\n\npublic override void request() {\n\nrealSubject.request();\n\n}\n\n}\n\nClient:\n\nProxy proxy = new Proxy();\n\nproxy.request();\n```\n\n8.工厂方法模式\n\n9.原型模式\n\n对象拷贝。深拷贝。浅拷贝。\n\n10.模板方法模式\n\n11.迪米特法则\n\n迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。\n\n强调类之间的松耦合。\n\n12.外观模式\n\n13.建造者模式\n\n建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。\n\n14.观察者模式\n\n当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。\n\n一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。\n\n总结：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。\n\nC#的委托delegate\n\n委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看做是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。\n\n一个委托可以搭载多个方法，所有方法被依次唤起。可以使得委托对象所搭载的方法并不需要属于同一个类。\n\n委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。\n\n15.抽象工厂模式\n\n抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n16.状态模式\n\n状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。\n\n17.适配器模式\n\n适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作了。\n\n18.备忘录模式\n\n备忘录：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\n19.组合模式\n\n组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n20.迭代器模式\n\n迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。\n\n21.单例模式\n\n单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n单例模式和静态工具类Static方法的区别：静态工具类不保存状态，仅提供一些静态方法或静态属性来让你使用，而单例类是有状态的。静态工具类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。静态类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。\n\n### 1、懒汉式，线程不安全\n\n```\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n```\n\n### 2、懒汉式，线程安全\n\n```\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n    public static synchronized Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n```\n\n### 3、饿汉式\n\n```\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n    return instance;  \n    }  \n}\n```\n\n### 4、双检锁/双重校验锁（DCL，即 double-checked locking）\n\n```\npublic class Singleton {  \n    private volatile static Singleton singleton;    // 加volatile的作用，防止singleton变量在new的时候引用逃逸\n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {  \n        synchronized (Singleton.class) {  \n        if (singleton == null) {  \n            singleton = new Singleton();  \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n}\n```\n\n### 5、登记式/静态内部类\n\n```\npublic class Singleton {  \n    private static class SingletonHolder {  \n    private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n    return SingletonHolder.INSTANCE;  \n    }  \n}\n```\n\n### 6、枚举\n\n```\npublic enum Singleton {  \n    INSTANCE;  \n    public void whateverMethod() {  \n    }  \n}\n```\n\n22.桥接模式\n\n合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。组合优于继承。\n\n桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。\n\n23.命令模式\n\n24.职责链模式\n\n职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n25.中介者模式\n\n26.享元模式\n\n27.解释器模式\n\n解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n28.访问者模式\n\n访问者模式：表示一个作用于某对象结构中的各元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n","source":"_posts/design-mode.md","raw":"---\ntitle: 设计模式笔记\ndate: 2017-04-01 18:40:51\ntags:\n  - 笔记\nid: design-mode\ncategories:\n  - 笔记\n---\n\n1.简单工厂模式\n\n2.策略模式\n\n<!--more-->\n\n策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。\n\n策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。\n\n3.单一职责原则\n\n规则总是很美好，呵呵\n\n就一个类而言，应该仅有一个引起它变化的原因。\n\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。\n\n如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n4.开放-封闭原则\n\n开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n\n对于扩展是开放的，对于更改是封闭的。\n\n无论模块是多么封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。\n\n等到变化发生时立即采取行动。\n\n开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n\n5.依赖倒转原则\n\n高层模块不应该依赖低层模块，两个都应该依赖抽象。\n\n抽象不应该依赖细节，细节应该依赖抽象。\n\n里氏代换原则：子类型必须能够替换掉它们的父类型。\n\n6.装饰模式\n\n装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n\n```\nPerson穿衣服为例：\nabstract class Show {\n\npublic abstract void show();\n\n}\n\nclass Persion : Show {\n\npublic override void show() { 具体实现 }\n\n}\n\nabstract class Decorator : Show {\n\nprotected Show show;\n\npublic void setDecorator(Show show) {\n\nthis.show = show;\n\n}\n\npublic override void show() {\n\nif (show != null) {\n\nshow.show();\n\n}\n\n}\n\n}\n\nclass DecoratorA : Decorator {\n\npublic override void show() { super.show(); 具体实现; }\n\n}\n\n装饰模式：\n\nPerson p = new Person();\n\nDecoratorA da = new DecoratorA();\n\nDecoratorB db = new DecoratorB();\n\nDecoratorC dc = new DecoratorC();\n\nda.setDecorator(p);\n\ndb.setDecorator(da);\n\ndc.setDecorator(db);\n\ndc.show();\n```\n\n7.代理模式\n\n代理模式：为其他对象提供一种代理以控制对这个对象的访问。\n\n```abstract class Subject {\npublic abstract void request();\n\n}\n\nclass RealSubject : Subject {\n\npublic override void request() {实现}\n\n}\n\nclass Proxy : Subject {\n\nRealSubject realSubject;\n\npublic override void request() {\n\nrealSubject.request();\n\n}\n\n}\n\nClient:\n\nProxy proxy = new Proxy();\n\nproxy.request();\n```\n\n8.工厂方法模式\n\n9.原型模式\n\n对象拷贝。深拷贝。浅拷贝。\n\n10.模板方法模式\n\n11.迪米特法则\n\n迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。\n\n强调类之间的松耦合。\n\n12.外观模式\n\n13.建造者模式\n\n建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。\n\n14.观察者模式\n\n当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。\n\n一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。\n\n总结：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。\n\nC#的委托delegate\n\n委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看做是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。\n\n一个委托可以搭载多个方法，所有方法被依次唤起。可以使得委托对象所搭载的方法并不需要属于同一个类。\n\n委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。\n\n15.抽象工厂模式\n\n抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n16.状态模式\n\n状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。\n\n17.适配器模式\n\n适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作了。\n\n18.备忘录模式\n\n备忘录：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\n19.组合模式\n\n组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n20.迭代器模式\n\n迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。\n\n21.单例模式\n\n单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n单例模式和静态工具类Static方法的区别：静态工具类不保存状态，仅提供一些静态方法或静态属性来让你使用，而单例类是有状态的。静态工具类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。静态类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。\n\n### 1、懒汉式，线程不安全\n\n```\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n```\n\n### 2、懒汉式，线程安全\n\n```\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n    public static synchronized Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n```\n\n### 3、饿汉式\n\n```\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n    return instance;  \n    }  \n}\n```\n\n### 4、双检锁/双重校验锁（DCL，即 double-checked locking）\n\n```\npublic class Singleton {  \n    private volatile static Singleton singleton;    // 加volatile的作用，防止singleton变量在new的时候引用逃逸\n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {  \n        synchronized (Singleton.class) {  \n        if (singleton == null) {  \n            singleton = new Singleton();  \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n}\n```\n\n### 5、登记式/静态内部类\n\n```\npublic class Singleton {  \n    private static class SingletonHolder {  \n    private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n    return SingletonHolder.INSTANCE;  \n    }  \n}\n```\n\n### 6、枚举\n\n```\npublic enum Singleton {  \n    INSTANCE;  \n    public void whateverMethod() {  \n    }  \n}\n```\n\n22.桥接模式\n\n合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。组合优于继承。\n\n桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。\n\n23.命令模式\n\n24.职责链模式\n\n职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n25.中介者模式\n\n26.享元模式\n\n27.解释器模式\n\n解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n28.访问者模式\n\n访问者模式：表示一个作用于某对象结构中的各元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n","slug":"design-mode","published":1,"updated":"2021-08-25T12:14:09.954Z","_id":"cksrd9hvm0003ssmn8kxm7eix","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1.简单工厂模式</p>\n<p>2.策略模式</p>\n<span id=\"more\"></span>\n\n<p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>\n<p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。</p>\n<p>3.单一职责原则</p>\n<p>规则总是很美好，呵呵</p>\n<p>就一个类而言，应该仅有一个引起它变化的原因。</p>\n<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p>\n<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p>\n<p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n<p>4.开放-封闭原则</p>\n<p>开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。</p>\n<p>对于扩展是开放的，对于更改是封闭的。</p>\n<p>无论模块是多么封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。</p>\n<p>等到变化发生时立即采取行动。</p>\n<p>开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>\n<p>5.依赖倒转原则</p>\n<p>高层模块不应该依赖低层模块，两个都应该依赖抽象。</p>\n<p>抽象不应该依赖细节，细节应该依赖抽象。</p>\n<p>里氏代换原则：子类型必须能够替换掉它们的父类型。</p>\n<p>6.装饰模式</p>\n<p>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person穿衣服为例：</span><br><span class=\"line\">abstract class Show &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public abstract void show();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Persion : Show &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void show() &#123; 具体实现 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class Decorator : Show &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">protected Show show;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setDecorator(Show show) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">this.show = show;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void show() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">if (show != null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">show.show();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class DecoratorA : Decorator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void show() &#123; super.show(); 具体实现; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">装饰模式：</span><br><span class=\"line\"></span><br><span class=\"line\">Person p = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">DecoratorA da = new DecoratorA();</span><br><span class=\"line\"></span><br><span class=\"line\">DecoratorB db = new DecoratorB();</span><br><span class=\"line\"></span><br><span class=\"line\">DecoratorC dc = new DecoratorC();</span><br><span class=\"line\"></span><br><span class=\"line\">da.setDecorator(p);</span><br><span class=\"line\"></span><br><span class=\"line\">db.setDecorator(da);</span><br><span class=\"line\"></span><br><span class=\"line\">dc.setDecorator(db);</span><br><span class=\"line\"></span><br><span class=\"line\">dc.show();</span><br></pre></td></tr></table></figure>\n\n<p>7.代理模式</p>\n<p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>class Subject &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract void request();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class RealSubject : Subject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void request() &#123;实现&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy : Subject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">RealSubject realSubject;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void request() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">realSubject.request();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client:</span><br><span class=\"line\"></span><br><span class=\"line\">Proxy proxy = new Proxy();</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.request();</span><br></pre></td></tr></table></figure>\n\n<p>8.工厂方法模式</p>\n<p>9.原型模式</p>\n<p>对象拷贝。深拷贝。浅拷贝。</p>\n<p>10.模板方法模式</p>\n<p>11.迪米特法则</p>\n<p>迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>\n<p>强调类之间的松耦合。</p>\n<p>12.外观模式</p>\n<p>13.建造者模式</p>\n<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n<p>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</p>\n<p>14.观察者模式</p>\n<p>当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。</p>\n<p>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>\n<p>总结：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p>\n<p>C#的委托delegate</p>\n<p>委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看做是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。</p>\n<p>一个委托可以搭载多个方法，所有方法被依次唤起。可以使得委托对象所搭载的方法并不需要属于同一个类。</p>\n<p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</p>\n<p>15.抽象工厂模式</p>\n<p>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>\n<p>16.状态模式</p>\n<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>\n<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p>\n<p>17.适配器模式</p>\n<p>适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作了。</p>\n<p>18.备忘录模式</p>\n<p>备忘录：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>\n<p>19.组合模式</p>\n<p>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p>20.迭代器模式</p>\n<p>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>\n<p>21.单例模式</p>\n<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<p>单例模式和静态工具类Static方法的区别：静态工具类不保存状态，仅提供一些静态方法或静态属性来让你使用，而单例类是有状态的。静态工具类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。静态类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。</p>\n<h3 id=\"1、懒汉式，线程不安全\"><a href=\"#1、懒汉式，线程不安全\" class=\"headerlink\" title=\"1、懒汉式，线程不安全\"></a>1、懒汉式，线程不安全</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static Singleton instance;  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static Singleton getInstance() &#123;  </span><br><span class=\"line\">    if (instance == null) &#123;  </span><br><span class=\"line\">        instance = new Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、懒汉式，线程安全\"><a href=\"#2、懒汉式，线程安全\" class=\"headerlink\" title=\"2、懒汉式，线程安全\"></a>2、懒汉式，线程安全</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static Singleton instance;  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static synchronized Singleton getInstance() &#123;  </span><br><span class=\"line\">    if (instance == null) &#123;  </span><br><span class=\"line\">        instance = new Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、饿汉式\"><a href=\"#3、饿汉式\" class=\"headerlink\" title=\"3、饿汉式\"></a>3、饿汉式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static Singleton instance = new Singleton();  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static Singleton getInstance() &#123;  </span><br><span class=\"line\">    return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、双检锁-双重校验锁（DCL，即-double-checked-locking）\"><a href=\"#4、双检锁-双重校验锁（DCL，即-double-checked-locking）\" class=\"headerlink\" title=\"4、双检锁/双重校验锁（DCL，即 double-checked locking）\"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private volatile static Singleton singleton;    // 加volatile的作用，防止singleton变量在new的时候引用逃逸</span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static Singleton getSingleton() &#123;  </span><br><span class=\"line\">    if (singleton == null) &#123;  </span><br><span class=\"line\">        synchronized (Singleton.class) &#123;  </span><br><span class=\"line\">        if (singleton == null) &#123;  </span><br><span class=\"line\">            singleton = new Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、登记式-静态内部类\"><a href=\"#5、登记式-静态内部类\" class=\"headerlink\" title=\"5、登记式/静态内部类\"></a>5、登记式/静态内部类</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static class SingletonHolder &#123;  </span><br><span class=\"line\">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static final Singleton getInstance() &#123;  </span><br><span class=\"line\">    return SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、枚举\"><a href=\"#6、枚举\" class=\"headerlink\" title=\"6、枚举\"></a>6、枚举</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Singleton &#123;  </span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    public void whateverMethod() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>22.桥接模式</p>\n<p>合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。组合优于继承。</p>\n<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>\n<p>23.命令模式</p>\n<p>24.职责链模式</p>\n<p>职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>\n<p>25.中介者模式</p>\n<p>26.享元模式</p>\n<p>27.解释器模式</p>\n<p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>\n<p>28.访问者模式</p>\n<p>访问者模式：表示一个作用于某对象结构中的各元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>\n","site":{"data":{}},"excerpt":"<p>1.简单工厂模式</p>\n<p>2.策略模式</p>","more":"<p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>\n<p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。</p>\n<p>3.单一职责原则</p>\n<p>规则总是很美好，呵呵</p>\n<p>就一个类而言，应该仅有一个引起它变化的原因。</p>\n<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p>\n<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p>\n<p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n<p>4.开放-封闭原则</p>\n<p>开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。</p>\n<p>对于扩展是开放的，对于更改是封闭的。</p>\n<p>无论模块是多么封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。</p>\n<p>等到变化发生时立即采取行动。</p>\n<p>开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>\n<p>5.依赖倒转原则</p>\n<p>高层模块不应该依赖低层模块，两个都应该依赖抽象。</p>\n<p>抽象不应该依赖细节，细节应该依赖抽象。</p>\n<p>里氏代换原则：子类型必须能够替换掉它们的父类型。</p>\n<p>6.装饰模式</p>\n<p>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person穿衣服为例：</span><br><span class=\"line\">abstract class Show &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public abstract void show();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Persion : Show &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void show() &#123; 具体实现 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class Decorator : Show &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">protected Show show;</span><br><span class=\"line\"></span><br><span class=\"line\">public void setDecorator(Show show) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">this.show = show;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void show() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">if (show != null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">show.show();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class DecoratorA : Decorator &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void show() &#123; super.show(); 具体实现; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">装饰模式：</span><br><span class=\"line\"></span><br><span class=\"line\">Person p = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">DecoratorA da = new DecoratorA();</span><br><span class=\"line\"></span><br><span class=\"line\">DecoratorB db = new DecoratorB();</span><br><span class=\"line\"></span><br><span class=\"line\">DecoratorC dc = new DecoratorC();</span><br><span class=\"line\"></span><br><span class=\"line\">da.setDecorator(p);</span><br><span class=\"line\"></span><br><span class=\"line\">db.setDecorator(da);</span><br><span class=\"line\"></span><br><span class=\"line\">dc.setDecorator(db);</span><br><span class=\"line\"></span><br><span class=\"line\">dc.show();</span><br></pre></td></tr></table></figure>\n\n<p>7.代理模式</p>\n<p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>class Subject &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract void request();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class RealSubject : Subject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void request() &#123;实现&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy : Subject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">RealSubject realSubject;</span><br><span class=\"line\"></span><br><span class=\"line\">public override void request() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">realSubject.request();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client:</span><br><span class=\"line\"></span><br><span class=\"line\">Proxy proxy = new Proxy();</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.request();</span><br></pre></td></tr></table></figure>\n\n<p>8.工厂方法模式</p>\n<p>9.原型模式</p>\n<p>对象拷贝。深拷贝。浅拷贝。</p>\n<p>10.模板方法模式</p>\n<p>11.迪米特法则</p>\n<p>迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>\n<p>强调类之间的松耦合。</p>\n<p>12.外观模式</p>\n<p>13.建造者模式</p>\n<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n<p>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</p>\n<p>14.观察者模式</p>\n<p>当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。</p>\n<p>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>\n<p>总结：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p>\n<p>C#的委托delegate</p>\n<p>委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看做是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。</p>\n<p>一个委托可以搭载多个方法，所有方法被依次唤起。可以使得委托对象所搭载的方法并不需要属于同一个类。</p>\n<p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</p>\n<p>15.抽象工厂模式</p>\n<p>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>\n<p>16.状态模式</p>\n<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>\n<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p>\n<p>17.适配器模式</p>\n<p>适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作了。</p>\n<p>18.备忘录模式</p>\n<p>备忘录：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>\n<p>19.组合模式</p>\n<p>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n<p>20.迭代器模式</p>\n<p>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>\n<p>21.单例模式</p>\n<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<p>单例模式和静态工具类Static方法的区别：静态工具类不保存状态，仅提供一些静态方法或静态属性来让你使用，而单例类是有状态的。静态工具类不能用于继承多态，而单例虽然实例唯一，却是可以有子类来继承。静态类只不过是一些方法属性的集合，而单例却是有着唯一的对象实例。</p>\n<h3 id=\"1、懒汉式，线程不安全\"><a href=\"#1、懒汉式，线程不安全\" class=\"headerlink\" title=\"1、懒汉式，线程不安全\"></a>1、懒汉式，线程不安全</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static Singleton instance;  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static Singleton getInstance() &#123;  </span><br><span class=\"line\">    if (instance == null) &#123;  </span><br><span class=\"line\">        instance = new Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、懒汉式，线程安全\"><a href=\"#2、懒汉式，线程安全\" class=\"headerlink\" title=\"2、懒汉式，线程安全\"></a>2、懒汉式，线程安全</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static Singleton instance;  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static synchronized Singleton getInstance() &#123;  </span><br><span class=\"line\">    if (instance == null) &#123;  </span><br><span class=\"line\">        instance = new Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、饿汉式\"><a href=\"#3、饿汉式\" class=\"headerlink\" title=\"3、饿汉式\"></a>3、饿汉式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static Singleton instance = new Singleton();  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static Singleton getInstance() &#123;  </span><br><span class=\"line\">    return instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、双检锁-双重校验锁（DCL，即-double-checked-locking）\"><a href=\"#4、双检锁-双重校验锁（DCL，即-double-checked-locking）\" class=\"headerlink\" title=\"4、双检锁/双重校验锁（DCL，即 double-checked locking）\"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private volatile static Singleton singleton;    // 加volatile的作用，防止singleton变量在new的时候引用逃逸</span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static Singleton getSingleton() &#123;  </span><br><span class=\"line\">    if (singleton == null) &#123;  </span><br><span class=\"line\">        synchronized (Singleton.class) &#123;  </span><br><span class=\"line\">        if (singleton == null) &#123;  </span><br><span class=\"line\">            singleton = new Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、登记式-静态内部类\"><a href=\"#5、登记式-静态内部类\" class=\"headerlink\" title=\"5、登记式/静态内部类\"></a>5、登记式/静态内部类</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;  </span><br><span class=\"line\">    private static class SingletonHolder &#123;  </span><br><span class=\"line\">    private static final Singleton INSTANCE = new Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    private Singleton ()&#123;&#125;  </span><br><span class=\"line\">    public static final Singleton getInstance() &#123;  </span><br><span class=\"line\">    return SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、枚举\"><a href=\"#6、枚举\" class=\"headerlink\" title=\"6、枚举\"></a>6、枚举</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Singleton &#123;  </span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    public void whateverMethod() &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>22.桥接模式</p>\n<p>合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。组合优于继承。</p>\n<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>\n<p>23.命令模式</p>\n<p>24.职责链模式</p>\n<p>职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>\n<p>25.中介者模式</p>\n<p>26.享元模式</p>\n<p>27.解释器模式</p>\n<p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>\n<p>28.访问者模式</p>\n<p>访问者模式：表示一个作用于某对象结构中的各元素操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>"},{"title":"读书笔记","date":"2017-05-01T12:02:17.000Z","id":"booknote","_content":"\n# 一、Redis\n\n1.《redis设计与实现》\n\n2.《redis开发与运维》\n\n<!--more-->\n\n# 二、MySQL\n\n1.《MySQL技术内幕：InnoDB存储引擎》\n\n# 三、JAVA\n\n0.《Effective Java》\n\n1.《Java程序性能优化》\n\n2.《Java数据结构和算法》\n\n3.《重构、改善既有代码的质量》\n\n4.《深入理解Java虚拟机：JVM高级特性与最佳实现》\n\n5.《Java并发编程的艺术》\n\n6.《Java并发编程实战》  先读实战再读艺术\n\n7.《分布式Java应用》\n\n8.《自己动手写JAVA虚拟机》 \n\n9.《Spring源码深度解析》\n\n10.《深入浅出Spring Boot 2》\n\n11.《JVM G1 源码分析和调优》 **未读**\n\n# 四、技术\n\n1.《代码简洁之道》\n\n2.《大话设计模式》\n\n3.《垃圾回收的算法与实现》 **50%**\n\n4.《腾讯游戏开发精粹》 **周末读**\n\n5.《点石成金》 近期\n\n6.《从小工到专家》 近期\n\n7.《Clean Architecture: A Craftsman’s Guide to Software Structure and Design 》 购书清单\n\n8.《DDIA：Designing Data-Intensive Applications。 》 购书清单\n\n# 五、综合\n\n1.《从领先到极致:互联网时代下的创业、创新与管理哲学》\n\n2.《人月神话》\n\n3.《影响力》\n\n4.《自控力》\n\n5.《情商》全6本 1/6\n\n6.《如何阅读一本书》\n\n","source":"_posts/booknote.md","raw":"---\ntitle: 读书笔记\ndate: 2017-05-01 20:02:17\ntags:\n  - 笔记\nid: booknote\ncategories:\n  - 笔记\n---\n\n# 一、Redis\n\n1.《redis设计与实现》\n\n2.《redis开发与运维》\n\n<!--more-->\n\n# 二、MySQL\n\n1.《MySQL技术内幕：InnoDB存储引擎》\n\n# 三、JAVA\n\n0.《Effective Java》\n\n1.《Java程序性能优化》\n\n2.《Java数据结构和算法》\n\n3.《重构、改善既有代码的质量》\n\n4.《深入理解Java虚拟机：JVM高级特性与最佳实现》\n\n5.《Java并发编程的艺术》\n\n6.《Java并发编程实战》  先读实战再读艺术\n\n7.《分布式Java应用》\n\n8.《自己动手写JAVA虚拟机》 \n\n9.《Spring源码深度解析》\n\n10.《深入浅出Spring Boot 2》\n\n11.《JVM G1 源码分析和调优》 **未读**\n\n# 四、技术\n\n1.《代码简洁之道》\n\n2.《大话设计模式》\n\n3.《垃圾回收的算法与实现》 **50%**\n\n4.《腾讯游戏开发精粹》 **周末读**\n\n5.《点石成金》 近期\n\n6.《从小工到专家》 近期\n\n7.《Clean Architecture: A Craftsman’s Guide to Software Structure and Design 》 购书清单\n\n8.《DDIA：Designing Data-Intensive Applications。 》 购书清单\n\n# 五、综合\n\n1.《从领先到极致:互联网时代下的创业、创新与管理哲学》\n\n2.《人月神话》\n\n3.《影响力》\n\n4.《自控力》\n\n5.《情商》全6本 1/6\n\n6.《如何阅读一本书》\n\n","slug":"booknote","published":1,"updated":"2021-08-25T12:14:24.194Z","_id":"cksrg67bx0006ssmnh3hmbmki","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"一、Redis\"><a href=\"#一、Redis\" class=\"headerlink\" title=\"一、Redis\"></a>一、Redis</h1><p>1.《redis设计与实现》</p>\n<p>2.《redis开发与运维》</p>\n<span id=\"more\"></span>\n\n<h1 id=\"二、MySQL\"><a href=\"#二、MySQL\" class=\"headerlink\" title=\"二、MySQL\"></a>二、MySQL</h1><p>1.《MySQL技术内幕：InnoDB存储引擎》</p>\n<h1 id=\"三、JAVA\"><a href=\"#三、JAVA\" class=\"headerlink\" title=\"三、JAVA\"></a>三、JAVA</h1><p>0.《Effective Java》</p>\n<p>1.《Java程序性能优化》</p>\n<p>2.《Java数据结构和算法》</p>\n<p>3.《重构、改善既有代码的质量》</p>\n<p>4.《深入理解Java虚拟机：JVM高级特性与最佳实现》</p>\n<p>5.《Java并发编程的艺术》</p>\n<p>6.《Java并发编程实战》  先读实战再读艺术</p>\n<p>7.《分布式Java应用》</p>\n<p>8.《自己动手写JAVA虚拟机》 </p>\n<p>9.《Spring源码深度解析》</p>\n<p>10.《深入浅出Spring Boot 2》</p>\n<p>11.《JVM G1 源码分析和调优》 <strong>未读</strong></p>\n<h1 id=\"四、技术\"><a href=\"#四、技术\" class=\"headerlink\" title=\"四、技术\"></a>四、技术</h1><p>1.《代码简洁之道》</p>\n<p>2.《大话设计模式》</p>\n<p>3.《垃圾回收的算法与实现》 <strong>50%</strong></p>\n<p>4.《腾讯游戏开发精粹》 <strong>周末读</strong></p>\n<p>5.《点石成金》 近期</p>\n<p>6.《从小工到专家》 近期</p>\n<p>7.《Clean Architecture: A Craftsman’s Guide to Software Structure and Design 》 购书清单</p>\n<p>8.《DDIA：Designing Data-Intensive Applications。 》 购书清单</p>\n<h1 id=\"五、综合\"><a href=\"#五、综合\" class=\"headerlink\" title=\"五、综合\"></a>五、综合</h1><p>1.《从领先到极致:互联网时代下的创业、创新与管理哲学》</p>\n<p>2.《人月神话》</p>\n<p>3.《影响力》</p>\n<p>4.《自控力》</p>\n<p>5.《情商》全6本 1/6</p>\n<p>6.《如何阅读一本书》</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、Redis\"><a href=\"#一、Redis\" class=\"headerlink\" title=\"一、Redis\"></a>一、Redis</h1><p>1.《redis设计与实现》</p>\n<p>2.《redis开发与运维》</p>","more":"<h1 id=\"二、MySQL\"><a href=\"#二、MySQL\" class=\"headerlink\" title=\"二、MySQL\"></a>二、MySQL</h1><p>1.《MySQL技术内幕：InnoDB存储引擎》</p>\n<h1 id=\"三、JAVA\"><a href=\"#三、JAVA\" class=\"headerlink\" title=\"三、JAVA\"></a>三、JAVA</h1><p>0.《Effective Java》</p>\n<p>1.《Java程序性能优化》</p>\n<p>2.《Java数据结构和算法》</p>\n<p>3.《重构、改善既有代码的质量》</p>\n<p>4.《深入理解Java虚拟机：JVM高级特性与最佳实现》</p>\n<p>5.《Java并发编程的艺术》</p>\n<p>6.《Java并发编程实战》  先读实战再读艺术</p>\n<p>7.《分布式Java应用》</p>\n<p>8.《自己动手写JAVA虚拟机》 </p>\n<p>9.《Spring源码深度解析》</p>\n<p>10.《深入浅出Spring Boot 2》</p>\n<p>11.《JVM G1 源码分析和调优》 <strong>未读</strong></p>\n<h1 id=\"四、技术\"><a href=\"#四、技术\" class=\"headerlink\" title=\"四、技术\"></a>四、技术</h1><p>1.《代码简洁之道》</p>\n<p>2.《大话设计模式》</p>\n<p>3.《垃圾回收的算法与实现》 <strong>50%</strong></p>\n<p>4.《腾讯游戏开发精粹》 <strong>周末读</strong></p>\n<p>5.《点石成金》 近期</p>\n<p>6.《从小工到专家》 近期</p>\n<p>7.《Clean Architecture: A Craftsman’s Guide to Software Structure and Design 》 购书清单</p>\n<p>8.《DDIA：Designing Data-Intensive Applications。 》 购书清单</p>\n<h1 id=\"五、综合\"><a href=\"#五、综合\" class=\"headerlink\" title=\"五、综合\"></a>五、综合</h1><p>1.《从领先到极致:互联网时代下的创业、创新与管理哲学》</p>\n<p>2.《人月神话》</p>\n<p>3.《影响力》</p>\n<p>4.《自控力》</p>\n<p>5.《情商》全6本 1/6</p>\n<p>6.《如何阅读一本书》</p>"},{"title":"Linux笔记","date":"2017-06-25T12:05:01.000Z","id":"linux-note","_content":"\n查看磁盘使用情况：\n\n查看当前目录：df -h\n\n<!--more-->\n\n查看文件夹的占用情况：du –max-depth=1 -h /usr/\n\n计算文件夹大小：du -sh /usr/\n\nSVN启动:  svnserve -d -r /var/svn/svnrepos/\n","source":"_posts/linux-note.md","raw":"---\ntitle: Linux笔记\ndate: 2017-06-25 20:05:01\ntags:\n  - 笔记\nid: linux-note\ncategories:\n  - 笔记\n---\n\n查看磁盘使用情况：\n\n查看当前目录：df -h\n\n<!--more-->\n\n查看文件夹的占用情况：du –max-depth=1 -h /usr/\n\n计算文件夹大小：du -sh /usr/\n\nSVN启动:  svnserve -d -r /var/svn/svnrepos/\n","slug":"linux-note","published":1,"updated":"2021-08-25T12:13:59.057Z","_id":"cksrg9qch0009ssmn5h10evws","comments":1,"layout":"post","photos":[],"link":"","content":"<p>查看磁盘使用情况：</p>\n<p>查看当前目录：df -h</p>\n<span id=\"more\"></span>\n\n<p>查看文件夹的占用情况：du –max-depth=1 -h /usr/</p>\n<p>计算文件夹大小：du -sh /usr/</p>\n<p>SVN启动:  svnserve -d -r /var/svn/svnrepos/</p>\n","site":{"data":{}},"excerpt":"<p>查看磁盘使用情况：</p>\n<p>查看当前目录：df -h</p>","more":"<p>查看文件夹的占用情况：du –max-depth=1 -h /usr/</p>\n<p>计算文件夹大小：du -sh /usr/</p>\n<p>SVN启动:  svnserve -d -r /var/svn/svnrepos/</p>"},{"title":"cocos creator使用protobuf ts版","date":"2018-05-03T12:15:07.000Z","id":"cc-proto","_content":"\n一、安装npm nodejs下的包管理器\n\n官网：https://nodejs.org  下载最新稳定版安装。如node-v8.11.4-x64.msi。\n\n<!--more-->\n\n双击安装\n\n一路点next下去，安装完成。\n\n在nodejs文件夹下新建两个文件夹：node_cache、node_global。\n\n然后运行以下两条命令：\n\n### npm config set prefix “D:\\IDE\\nodejs\\node_global”\n\n### npm config set cache “D:\\IDE\\nodejs\\node_cache”\n\n### npm config set registry=http://registry.npm.taobao.org  配置镜像站\n\n配置完后使用npm config list显示所有配置信息。\n\n### 增加环境变量NODE_PATH 内容是：D:\\IDE\\nodejs\\node_global\\node_modules\n\n重启命令行生效。\n\n二、安装protobufjs\n\n命令行执行：npm init\n\n然后安装：npm install protobufjs -g\n\n安装成功后，在nodejs\\node_global文件夹下有对应文件。\n\n三、生成js、ts文件\n\n编写proto文件。\n\n进入node_modules.bin目录，或者添加到环境变量path里\n\\* 第一步生成js:\n\\* pbjs -t static-module -w commonjs -o test.js test.proto\n\\* 第二步生成ts:\n\\* pbts -o test.d.ts test.js\n\n四、项目中使用proto\n\n在项目的根目录下，运行命令\n\nnpm init\n\nnpm install protobufjs\n","source":"_posts/cc-proto.md","raw":"---\ntitle: cocos creator使用protobuf ts版\ndate: 2018-05-03 20:15:07\ntags:\n  - 笔记\nid: cc-proto\ncategories:\n  - 笔记\n---\n\n一、安装npm nodejs下的包管理器\n\n官网：https://nodejs.org  下载最新稳定版安装。如node-v8.11.4-x64.msi。\n\n<!--more-->\n\n双击安装\n\n一路点next下去，安装完成。\n\n在nodejs文件夹下新建两个文件夹：node_cache、node_global。\n\n然后运行以下两条命令：\n\n### npm config set prefix “D:\\IDE\\nodejs\\node_global”\n\n### npm config set cache “D:\\IDE\\nodejs\\node_cache”\n\n### npm config set registry=http://registry.npm.taobao.org  配置镜像站\n\n配置完后使用npm config list显示所有配置信息。\n\n### 增加环境变量NODE_PATH 内容是：D:\\IDE\\nodejs\\node_global\\node_modules\n\n重启命令行生效。\n\n二、安装protobufjs\n\n命令行执行：npm init\n\n然后安装：npm install protobufjs -g\n\n安装成功后，在nodejs\\node_global文件夹下有对应文件。\n\n三、生成js、ts文件\n\n编写proto文件。\n\n进入node_modules.bin目录，或者添加到环境变量path里\n\\* 第一步生成js:\n\\* pbjs -t static-module -w commonjs -o test.js test.proto\n\\* 第二步生成ts:\n\\* pbts -o test.d.ts test.js\n\n四、项目中使用proto\n\n在项目的根目录下，运行命令\n\nnpm init\n\nnpm install protobufjs\n","slug":"cc-proto","published":1,"updated":"2021-08-25T12:16:52.548Z","_id":"cksrgmpej000cssmne1ydab53","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一、安装npm nodejs下的包管理器</p>\n<p>官网：<a href=\"https://nodejs.org/\">https://nodejs.org</a>  下载最新稳定版安装。如node-v8.11.4-x64.msi。</p>\n<span id=\"more\"></span>\n\n<p>双击安装</p>\n<p>一路点next下去，安装完成。</p>\n<p>在nodejs文件夹下新建两个文件夹：node_cache、node_global。</p>\n<p>然后运行以下两条命令：</p>\n<h3 id=\"npm-config-set-prefix-“D-IDE-nodejs-node-global”\"><a href=\"#npm-config-set-prefix-“D-IDE-nodejs-node-global”\" class=\"headerlink\" title=\"npm config set prefix “D:\\IDE\\nodejs\\node_global”\"></a>npm config set prefix “D:\\IDE\\nodejs\\node_global”</h3><h3 id=\"npm-config-set-cache-“D-IDE-nodejs-node-cache”\"><a href=\"#npm-config-set-cache-“D-IDE-nodejs-node-cache”\" class=\"headerlink\" title=\"npm config set cache “D:\\IDE\\nodejs\\node_cache”\"></a>npm config set cache “D:\\IDE\\nodejs\\node_cache”</h3><h3 id=\"npm-config-set-registry-http-registry-npm-taobao-org-配置镜像站\"><a href=\"#npm-config-set-registry-http-registry-npm-taobao-org-配置镜像站\" class=\"headerlink\" title=\"npm config set registry=http://registry.npm.taobao.org  配置镜像站\"></a>npm config set registry=<a href=\"http://registry.npm.taobao.org/\">http://registry.npm.taobao.org</a>  配置镜像站</h3><p>配置完后使用npm config list显示所有配置信息。</p>\n<h3 id=\"增加环境变量NODE-PATH-内容是：D-IDE-nodejs-node-global-node-modules\"><a href=\"#增加环境变量NODE-PATH-内容是：D-IDE-nodejs-node-global-node-modules\" class=\"headerlink\" title=\"增加环境变量NODE_PATH 内容是：D:\\IDE\\nodejs\\node_global\\node_modules\"></a>增加环境变量NODE_PATH 内容是：D:\\IDE\\nodejs\\node_global\\node_modules</h3><p>重启命令行生效。</p>\n<p>二、安装protobufjs</p>\n<p>命令行执行：npm init</p>\n<p>然后安装：npm install protobufjs -g</p>\n<p>安装成功后，在nodejs\\node_global文件夹下有对应文件。</p>\n<p>三、生成js、ts文件</p>\n<p>编写proto文件。</p>\n<p>进入node_modules.bin目录，或者添加到环境变量path里<br>* 第一步生成js:<br>* pbjs -t static-module -w commonjs -o test.js test.proto<br>* 第二步生成ts:<br>* pbts -o test.d.ts test.js</p>\n<p>四、项目中使用proto</p>\n<p>在项目的根目录下，运行命令</p>\n<p>npm init</p>\n<p>npm install protobufjs</p>\n","site":{"data":{}},"excerpt":"<p>一、安装npm nodejs下的包管理器</p>\n<p>官网：<a href=\"https://nodejs.org/\">https://nodejs.org</a>  下载最新稳定版安装。如node-v8.11.4-x64.msi。</p>","more":"<p>双击安装</p>\n<p>一路点next下去，安装完成。</p>\n<p>在nodejs文件夹下新建两个文件夹：node_cache、node_global。</p>\n<p>然后运行以下两条命令：</p>\n<h3 id=\"npm-config-set-prefix-“D-IDE-nodejs-node-global”\"><a href=\"#npm-config-set-prefix-“D-IDE-nodejs-node-global”\" class=\"headerlink\" title=\"npm config set prefix “D:\\IDE\\nodejs\\node_global”\"></a>npm config set prefix “D:\\IDE\\nodejs\\node_global”</h3><h3 id=\"npm-config-set-cache-“D-IDE-nodejs-node-cache”\"><a href=\"#npm-config-set-cache-“D-IDE-nodejs-node-cache”\" class=\"headerlink\" title=\"npm config set cache “D:\\IDE\\nodejs\\node_cache”\"></a>npm config set cache “D:\\IDE\\nodejs\\node_cache”</h3><h3 id=\"npm-config-set-registry-http-registry-npm-taobao-org-配置镜像站\"><a href=\"#npm-config-set-registry-http-registry-npm-taobao-org-配置镜像站\" class=\"headerlink\" title=\"npm config set registry=http://registry.npm.taobao.org  配置镜像站\"></a>npm config set registry=<a href=\"http://registry.npm.taobao.org/\">http://registry.npm.taobao.org</a>  配置镜像站</h3><p>配置完后使用npm config list显示所有配置信息。</p>\n<h3 id=\"增加环境变量NODE-PATH-内容是：D-IDE-nodejs-node-global-node-modules\"><a href=\"#增加环境变量NODE-PATH-内容是：D-IDE-nodejs-node-global-node-modules\" class=\"headerlink\" title=\"增加环境变量NODE_PATH 内容是：D:\\IDE\\nodejs\\node_global\\node_modules\"></a>增加环境变量NODE_PATH 内容是：D:\\IDE\\nodejs\\node_global\\node_modules</h3><p>重启命令行生效。</p>\n<p>二、安装protobufjs</p>\n<p>命令行执行：npm init</p>\n<p>然后安装：npm install protobufjs -g</p>\n<p>安装成功后，在nodejs\\node_global文件夹下有对应文件。</p>\n<p>三、生成js、ts文件</p>\n<p>编写proto文件。</p>\n<p>进入node_modules.bin目录，或者添加到环境变量path里<br>* 第一步生成js:<br>* pbjs -t static-module -w commonjs -o test.js test.proto<br>* 第二步生成ts:<br>* pbts -o test.d.ts test.js</p>\n<p>四、项目中使用proto</p>\n<p>在项目的根目录下，运行命令</p>\n<p>npm init</p>\n<p>npm install protobufjs</p>"},{"title":"Redis笔记","date":"2018-05-13T12:18:05.000Z","id":"redis-mode","_content":"\n1.单线程：Redis是单线程来处理命令的，所以一条命令从客户端到达服务器不会立刻被执行，所有命令都会进入一个队列中，然后逐个执行。\n\n2.Redis使用I/O多路复用技术来解决I/O的问题。\n\n<!--more-->\n\n3.性能：纯内存访问、非阻塞IO，Redis使用epoll作为I/O多路复用技术的实现。单线程避免了线程切换和竞态产生的消耗。\n\n4.单线程的问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞。致命的！\n\n5.setnx可以作为分布式锁的一种实现方案。http://redis.io/topics/distlock\n\n6.批量操作解决网络性能的瓶颈，Redis支持每秒数万的读写操作，网络可能会成为性能的瓶颈。\n\n7.Redis支持简单的事务，multi开始  exec执行  discard舍弃。Redis不支持回滚功能，事务中可能第一条执行成功，第二条执行失败，第一条也会生效。\n\n8.watch命令，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。\n\n9.线上环境：redis-cli 超时的检测，timeout设置为大于0，客户端做空闲检测，jedis-pool的common-pool。\n\n10.client pause 命令应用：让主、从保持一致。可控的将客户端连接从一个节点切换到另一个节点。线上暂停成本非常高。\n\n11.rename-command命令重命名指令。\n\n12.fork操作跟内存量成正比，线上建议单个Redis实例内存控制在10GB以内。\n\n13.Redis是CPU密集型服务，不要和其他CPU密集型服务部署在一起。\n\n14.主从：写高并发时，可以开启从的AOF，关闭主的持久化，要注意主库自动重启后没有数据，避免从库同步清空，血崩。\n\n15.主从：读高并发时，可以让客户端从从库读取。\n\n16.主从：写并发高的主库不适宜有多个从库。可以使用树状结构。\n\n17.Redis执行fork操作产生的子进程，使用写时复制技术（copy-on-write），减少内存的占用。\n\n18.尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。\n\n19.控制数据类型的编码来实现时间和空间的平衡。\n\n20.键值对很多时，可以分组映射到多个hash结构中，来降低键的数量。如100W个键分组映射到1000个hash中，每个1000个field、value。\n\n21.集群故障转移时不影响其他主节点，配置cluster-require-full-coverage no。\n\n","source":"_posts/redis-note.md","raw":"---\ntitle: Redis笔记\ndate: 2018-05-13 20:18:05\ntags:\n  - 笔记\nid: redis-mode\ncategories:\n  - 笔记\n---\n\n1.单线程：Redis是单线程来处理命令的，所以一条命令从客户端到达服务器不会立刻被执行，所有命令都会进入一个队列中，然后逐个执行。\n\n2.Redis使用I/O多路复用技术来解决I/O的问题。\n\n<!--more-->\n\n3.性能：纯内存访问、非阻塞IO，Redis使用epoll作为I/O多路复用技术的实现。单线程避免了线程切换和竞态产生的消耗。\n\n4.单线程的问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞。致命的！\n\n5.setnx可以作为分布式锁的一种实现方案。http://redis.io/topics/distlock\n\n6.批量操作解决网络性能的瓶颈，Redis支持每秒数万的读写操作，网络可能会成为性能的瓶颈。\n\n7.Redis支持简单的事务，multi开始  exec执行  discard舍弃。Redis不支持回滚功能，事务中可能第一条执行成功，第二条执行失败，第一条也会生效。\n\n8.watch命令，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。\n\n9.线上环境：redis-cli 超时的检测，timeout设置为大于0，客户端做空闲检测，jedis-pool的common-pool。\n\n10.client pause 命令应用：让主、从保持一致。可控的将客户端连接从一个节点切换到另一个节点。线上暂停成本非常高。\n\n11.rename-command命令重命名指令。\n\n12.fork操作跟内存量成正比，线上建议单个Redis实例内存控制在10GB以内。\n\n13.Redis是CPU密集型服务，不要和其他CPU密集型服务部署在一起。\n\n14.主从：写高并发时，可以开启从的AOF，关闭主的持久化，要注意主库自动重启后没有数据，避免从库同步清空，血崩。\n\n15.主从：读高并发时，可以让客户端从从库读取。\n\n16.主从：写并发高的主库不适宜有多个从库。可以使用树状结构。\n\n17.Redis执行fork操作产生的子进程，使用写时复制技术（copy-on-write），减少内存的占用。\n\n18.尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。\n\n19.控制数据类型的编码来实现时间和空间的平衡。\n\n20.键值对很多时，可以分组映射到多个hash结构中，来降低键的数量。如100W个键分组映射到1000个hash中，每个1000个field、value。\n\n21.集群故障转移时不影响其他主节点，配置cluster-require-full-coverage no。\n\n","slug":"redis-note","published":1,"updated":"2021-08-25T12:45:34.742Z","_id":"cksrgqixf000fssmn17s5cfja","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1.单线程：Redis是单线程来处理命令的，所以一条命令从客户端到达服务器不会立刻被执行，所有命令都会进入一个队列中，然后逐个执行。</p>\n<p>2.Redis使用I/O多路复用技术来解决I/O的问题。</p>\n<span id=\"more\"></span>\n\n<p>3.性能：纯内存访问、非阻塞IO，Redis使用epoll作为I/O多路复用技术的实现。单线程避免了线程切换和竞态产生的消耗。</p>\n<p>4.单线程的问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞。致命的！</p>\n<p>5.setnx可以作为分布式锁的一种实现方案。<a href=\"http://redis.io/topics/distlock\">http://redis.io/topics/distlock</a></p>\n<p>6.批量操作解决网络性能的瓶颈，Redis支持每秒数万的读写操作，网络可能会成为性能的瓶颈。</p>\n<p>7.Redis支持简单的事务，multi开始  exec执行  discard舍弃。Redis不支持回滚功能，事务中可能第一条执行成功，第二条执行失败，第一条也会生效。</p>\n<p>8.watch命令，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。</p>\n<p>9.线上环境：redis-cli 超时的检测，timeout设置为大于0，客户端做空闲检测，jedis-pool的common-pool。</p>\n<p>10.client pause 命令应用：让主、从保持一致。可控的将客户端连接从一个节点切换到另一个节点。线上暂停成本非常高。</p>\n<p>11.rename-command命令重命名指令。</p>\n<p>12.fork操作跟内存量成正比，线上建议单个Redis实例内存控制在10GB以内。</p>\n<p>13.Redis是CPU密集型服务，不要和其他CPU密集型服务部署在一起。</p>\n<p>14.主从：写高并发时，可以开启从的AOF，关闭主的持久化，要注意主库自动重启后没有数据，避免从库同步清空，血崩。</p>\n<p>15.主从：读高并发时，可以让客户端从从库读取。</p>\n<p>16.主从：写并发高的主库不适宜有多个从库。可以使用树状结构。</p>\n<p>17.Redis执行fork操作产生的子进程，使用写时复制技术（copy-on-write），减少内存的占用。</p>\n<p>18.尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。</p>\n<p>19.控制数据类型的编码来实现时间和空间的平衡。</p>\n<p>20.键值对很多时，可以分组映射到多个hash结构中，来降低键的数量。如100W个键分组映射到1000个hash中，每个1000个field、value。</p>\n<p>21.集群故障转移时不影响其他主节点，配置cluster-require-full-coverage no。</p>\n","site":{"data":{}},"excerpt":"<p>1.单线程：Redis是单线程来处理命令的，所以一条命令从客户端到达服务器不会立刻被执行，所有命令都会进入一个队列中，然后逐个执行。</p>\n<p>2.Redis使用I/O多路复用技术来解决I/O的问题。</p>","more":"<p>3.性能：纯内存访问、非阻塞IO，Redis使用epoll作为I/O多路复用技术的实现。单线程避免了线程切换和竞态产生的消耗。</p>\n<p>4.单线程的问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞。致命的！</p>\n<p>5.setnx可以作为分布式锁的一种实现方案。<a href=\"http://redis.io/topics/distlock\">http://redis.io/topics/distlock</a></p>\n<p>6.批量操作解决网络性能的瓶颈，Redis支持每秒数万的读写操作，网络可能会成为性能的瓶颈。</p>\n<p>7.Redis支持简单的事务，multi开始  exec执行  discard舍弃。Redis不支持回滚功能，事务中可能第一条执行成功，第二条执行失败，第一条也会生效。</p>\n<p>8.watch命令，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。</p>\n<p>9.线上环境：redis-cli 超时的检测，timeout设置为大于0，客户端做空闲检测，jedis-pool的common-pool。</p>\n<p>10.client pause 命令应用：让主、从保持一致。可控的将客户端连接从一个节点切换到另一个节点。线上暂停成本非常高。</p>\n<p>11.rename-command命令重命名指令。</p>\n<p>12.fork操作跟内存量成正比，线上建议单个Redis实例内存控制在10GB以内。</p>\n<p>13.Redis是CPU密集型服务，不要和其他CPU密集型服务部署在一起。</p>\n<p>14.主从：写高并发时，可以开启从的AOF，关闭主的持久化，要注意主库自动重启后没有数据，避免从库同步清空，血崩。</p>\n<p>15.主从：读高并发时，可以让客户端从从库读取。</p>\n<p>16.主从：写并发高的主库不适宜有多个从库。可以使用树状结构。</p>\n<p>17.Redis执行fork操作产生的子进程，使用写时复制技术（copy-on-write），减少内存的占用。</p>\n<p>18.尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。</p>\n<p>19.控制数据类型的编码来实现时间和空间的平衡。</p>\n<p>20.键值对很多时，可以分组映射到多个hash结构中，来降低键的数量。如100W个键分组映射到1000个hash中，每个1000个field、value。</p>\n<p>21.集群故障转移时不影响其他主节点，配置cluster-require-full-coverage no。</p>"},{"title":"APP开发选型","date":"2018-07-25T12:22:47.000Z","id":"app-dev","_content":"\n## 这次真的是从入坑到弃坑。最后还是觉得使用flutter\n\n在使用weex做了一个简单的应用，调通通信和资源加载后，发现坑还是很多的。\n\n主要weex适合用来做单页面的开发，开发完整的APP还是有一些局限性，在浏览器端调试也存在问题。\n\n主要还是社区和文档很不齐全。\n\n为什么选择flutter呢？\n\n<!--more-->\n\n1.google爸爸背书。\n\n2.dart开发。（自己对JS不熟悉。常年使用JAVA）\n\n3.idea，和服务器端统一IDE。\n\n4.flutter的理念才是跨平台的最终解决方案。\n\n5.感觉不能再好了、\n\nps：就在前几天（2018.12.5）出正式1.0版本了\n\n## 原文：\n\n最近有做一款APP的想法，调研下开发工具链。一直做游戏开发，引擎用过u3d，cocos，egret。\n\n最终决定使用weex。\n\n学习整理：\n\nhttps://segmentfault.com/a/1190000011027225\n\nhtml，css的基础知识；\n\nNode：[《Node.js 教程》](http://www.runoob.com/nodejs/nodejs-tutorial.html)\nVue：[《Vue.js官方教程》](https://cn.vuejs.org/v2/guide/)\nES6：[《ECMAScript 6 入门》](http://es6.ruanyifeng.com/)\n\n转载：https://www.jianshu.com/p/33246251cfae\n\n# 浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣\n\n# 一句话概要\n\n> Native、Web App、Hybrid、ReactNative（后面以RN简称）、WEEX间的异同点\n\n# APP常用开发模式【简介】\n\n此处APP为应用，application，并非我们通常讲的手机App\n[常用的几种APP开发模式-脑图](https://link.jianshu.com/?t=http://naotu.baidu.com/file/6af15fcbb72f89926043779811b1ea44?token=df0378691ecdcef2)\n\n## Native App\n\n传统的原生APP开发模式，有IOS和AOS两大系统，需要各自语言开发各自APP。\n\n**优点**：性能和体验都是最好的\n**缺点**：开发和发布成本高\n**举个栗子**：[网易管家APP](https://link.jianshu.com/?t=https://id.163.com/gj/) （Tab1，Tab2）\n**应用技术**：Swift，OC，JAVA\n\n## WebApp\n\n移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application，再后面做介绍）对应。\n\n**优点**：开发和发布成本最低\n**缺点**：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量\n**举个栗子**：[网易管家APP](https://link.jianshu.com/?t=https://id.163.com/gj/)（Tab3）\n**应用技术**：ReactJS，RegularJS等\n\n## Hybrid App\n\n混合模式移动应用，介于web-app、native-app这两者之间的app，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）\n\n主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用HTML+CSS实现界面，JS来写逻辑，调用API，最终的页面在webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所有有跨平台效果。\n\n**优点**：开发和发布都比较方便，效率介于Native App、Web App之间\n**缺点**：学习范围较广，需要原生配合\n**举个栗子**：[网易云音乐](https://link.jianshu.com/?t=https://music.163.com/#/download)，我爱我家App\n**应用技术**：PhoneGap，AppCan，Wex5\n\n## React Native App\n\nFacebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的APP开发方案RN App。。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。\n\n**优点**：效率体验接近Native App，发布和开发成本低于Native App\n**缺点**：学习有一定成本，且文档较少，免不了踩坑\n**举个栗子**：Facebook、youtube、discord、QQ、百度等等\n\n## WEEX App\n\n阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。\n\n**优点**：开发效率和体验上跟RN不相上下，并且跨平台性更强\n**缺点**：刚刚起步，社区没有RN活跃\n**举个栗子**：淘宝、天猫、饿了么等\n\n# 继续剖析\n\n## Native App\n\n![APP开发选型 - 第1张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-70fa348f3db0fca7.png?w=640)\n\nNative App是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序,也叫本地app。一般使用的开发语言为JAVA、C++、Objective-C。\n\n自iOS和Android这两个的手机操作系统发布以来，在互联网界从此就多了一个新的名词：App意为运行在智能的移动终端设备第三方应用程序)。\n\nNative App因为位于平台层上方，向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。但是比较乐观的是，AppStore培养了一种比较好的用户付费模式，所以在Apple的生态圈里，开发者的盈利模式是一种明朗状态，其他market也在往这条路上靠拢。\n\n### 优势\n\n1、相比于其它模式，提供最佳的用户体验，最优质的用户界面，最华丽的交互\n2、针对不同平台提供不同体验\n3、可节省带宽成本，打开速度更快\n4、功能最为强大,特别是在与系统交互中,几乎所有功能都能实现\n\n### 劣势\n\n1、门槛高，原生开发人才稀缺，至少比前端和后端少，开发环境昂贵\n2、无法跨平台，开发的成本比较大，各个系统独立开发\n3、发布成本高，需要通过store或market的审核，导致更新缓慢\n4、维持多个版本、多个系统的成本比较高，而且必须做兼容\n5、应用市场逐渐饱和，怎么样抢占用户时间需要投入大量时间和金钱，这也导致“僵尸”App的增多\n\n## WebApp\n\n![APP开发选型 - 第2张  | 张嘎](https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-a16fa91905d4214e.png?w=640)\n\n说到Web App不少人会联想到WAP，或者有人认为，WAP就是WebApp，其实不然。\n\nWebApp与WAP最直接的区别就是功能层面。WAP更侧重使用网页技术在移动端做展示，包括文字、媒体文件等。而Web App更侧重“功能”，是使用网页技术实现的App。总的来说，Web App就是运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用。\n\n响应式的大部分技术都是为实现WebApp能适配多类客户端而设计的。\n\nWeb网站一般分两种，MPA(Multi-page Application)和SPA(Single-page Application)。而WebApp一般泛指SPA形式开发出的网站。这样更像是一个App。\n\n### 优势\n\n1、可以跨平台，调试方便\n2、无需安装，不会占用手机内存，而且更新速度最快\n3、不存在多版本问题，维护成本低\n4、临时入口，可以随意嵌入\n\n### 劣势\n\n1、依赖于网络，第一次访问页面速度慢，耗费流量\n2、受限于手机和浏览器性能，用户体验相较于其他模式最差\n3、功能受限，大量移动端功能无法实现\n4、入口强依赖于第三方浏览器，且只能以URL地址的形式存在，导致用户留存率低（优点即缺点）\n\n## Hybird App\n\n![APP开发选型 - 第3张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-e8ed4f0375d2639b.png?w=640)\n\n混合开发，也就是半原生半Web的开发模式，由原生提供统一的API给JS调用，实际的主要逻辑有Html和JS来完成，最终是放在webview中显示的，所以只需要写一套代码即可达到跨平台效果，另外也可以直接在浏览器中调试，很方便。最重要的是只需要一个前端人员稍微学习下JS api的调用即可。\n\nHybird App 的较早实践者是PhoneGap，随后遍地开花，如Titanium、Salama、WeX5、Kerkee和国内的AppCan，项目各有各的实现方式，大致的原理基本相同。有幸在AppCan上海总部参与过一段时间的学习研究，如下大致简介：\n\nAppCan是基于HTML5技术的Hybird跨平台移动应用开发工具。开发者利用HTML5+CSS3+JavaScript技术，通过AppCan IDE集成开发系统、云端打包器等，快速开发出Android、iOS、WP平台上的移动应用。\n\nAppCan的平台构成\n\n![APP开发选型 - 第4张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-cd8c63378a612022.png?w=640)\n\n在实际的APP开发中，AppCan可以完成大部分的工作量，如图示：\n\n![APP开发选型 - 第5张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-634591b2598fa8ad.png?w=640)\n\nAppCan将APP底层复杂的原生功能封装在引擎、插件中，开发者仅需调用接口、打包编译，就可以获得原生功能；灵活的插件扩展机制。\n\n开发者可以像开发WebApp一样开发app的视觉UI，以及绝大部分的交互，当需要使用原生功能（如摄像头，陀螺仪等功能）时，只需要调用官方的API就可以轻松实现Native的效果。至于JS和Native的通信，常用的有URL监听和绝大部分Hybrid厂商使用的JSBridge通信，两者原理相近。\n\n![APP开发选型 - 第6张  | 张嘎](https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-400b4c6162d774f4.png?w=640)\n\nJsBridge通信简图\n\n关于JsBridge的原理详解，可见[http://blog.csdn.net/xiangzhihong8/article/details/66970600](https://link.jianshu.com/?t=http://blog.csdn.net/xiangzhihong8/article/details/66970600)\n\n在Hybird概念盛行的时候，国内外各大公司也参与了探索，国外代表有Facebook、google、亚马逊，国内的有腾讯、阿里巴巴、网易等，慢慢的他们发现Hybird严重受限于WebView的解析渲染效率，于是Facebook开始了他的类原生的研究探索。\n\n## React Native App\n\n![APP开发选型 - 第7张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-846d1bcbe4f9b505.png?w=640)\n\n请移驾 [【笔记】React Native 快速入门笔记](https://link.jianshu.com/?t=https://segmentfault.com/a/1190000010989345)\n\n## Weex App\n\n![APP开发选型 - 第8张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-ec1e7c9c4de9f9c0.png?w=640)\n\n请移驾[网易严选App感受Weex开发](https://link.jianshu.com/?t=https://segmentfault.com/a/1190000011027225)\n\n作者：木羽zwwill\n链接：https://www.jianshu.com/p/33246251cfae\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n\n真的从入门到放弃，fluuter\n\nhttp://www.52im.net/thread-1870-1-1.html\n\nhttps://www.jianshu.com/p/139c5074ae5d\n\n","source":"_posts/app-dev.md","raw":"---\ntitle: APP开发选型\ndate: 2018-07-25 20:22:47\ntags:\n  - 笔记\nid: app-dev\ncategories:\n  - 笔记\n---\n\n## 这次真的是从入坑到弃坑。最后还是觉得使用flutter\n\n在使用weex做了一个简单的应用，调通通信和资源加载后，发现坑还是很多的。\n\n主要weex适合用来做单页面的开发，开发完整的APP还是有一些局限性，在浏览器端调试也存在问题。\n\n主要还是社区和文档很不齐全。\n\n为什么选择flutter呢？\n\n<!--more-->\n\n1.google爸爸背书。\n\n2.dart开发。（自己对JS不熟悉。常年使用JAVA）\n\n3.idea，和服务器端统一IDE。\n\n4.flutter的理念才是跨平台的最终解决方案。\n\n5.感觉不能再好了、\n\nps：就在前几天（2018.12.5）出正式1.0版本了\n\n## 原文：\n\n最近有做一款APP的想法，调研下开发工具链。一直做游戏开发，引擎用过u3d，cocos，egret。\n\n最终决定使用weex。\n\n学习整理：\n\nhttps://segmentfault.com/a/1190000011027225\n\nhtml，css的基础知识；\n\nNode：[《Node.js 教程》](http://www.runoob.com/nodejs/nodejs-tutorial.html)\nVue：[《Vue.js官方教程》](https://cn.vuejs.org/v2/guide/)\nES6：[《ECMAScript 6 入门》](http://es6.ruanyifeng.com/)\n\n转载：https://www.jianshu.com/p/33246251cfae\n\n# 浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣\n\n# 一句话概要\n\n> Native、Web App、Hybrid、ReactNative（后面以RN简称）、WEEX间的异同点\n\n# APP常用开发模式【简介】\n\n此处APP为应用，application，并非我们通常讲的手机App\n[常用的几种APP开发模式-脑图](https://link.jianshu.com/?t=http://naotu.baidu.com/file/6af15fcbb72f89926043779811b1ea44?token=df0378691ecdcef2)\n\n## Native App\n\n传统的原生APP开发模式，有IOS和AOS两大系统，需要各自语言开发各自APP。\n\n**优点**：性能和体验都是最好的\n**缺点**：开发和发布成本高\n**举个栗子**：[网易管家APP](https://link.jianshu.com/?t=https://id.163.com/gj/) （Tab1，Tab2）\n**应用技术**：Swift，OC，JAVA\n\n## WebApp\n\n移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application，再后面做介绍）对应。\n\n**优点**：开发和发布成本最低\n**缺点**：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量\n**举个栗子**：[网易管家APP](https://link.jianshu.com/?t=https://id.163.com/gj/)（Tab3）\n**应用技术**：ReactJS，RegularJS等\n\n## Hybrid App\n\n混合模式移动应用，介于web-app、native-app这两者之间的app，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）\n\n主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用HTML+CSS实现界面，JS来写逻辑，调用API，最终的页面在webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所有有跨平台效果。\n\n**优点**：开发和发布都比较方便，效率介于Native App、Web App之间\n**缺点**：学习范围较广，需要原生配合\n**举个栗子**：[网易云音乐](https://link.jianshu.com/?t=https://music.163.com/#/download)，我爱我家App\n**应用技术**：PhoneGap，AppCan，Wex5\n\n## React Native App\n\nFacebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的APP开发方案RN App。。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。\n\n**优点**：效率体验接近Native App，发布和开发成本低于Native App\n**缺点**：学习有一定成本，且文档较少，免不了踩坑\n**举个栗子**：Facebook、youtube、discord、QQ、百度等等\n\n## WEEX App\n\n阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。\n\n**优点**：开发效率和体验上跟RN不相上下，并且跨平台性更强\n**缺点**：刚刚起步，社区没有RN活跃\n**举个栗子**：淘宝、天猫、饿了么等\n\n# 继续剖析\n\n## Native App\n\n![APP开发选型 - 第1张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-70fa348f3db0fca7.png?w=640)\n\nNative App是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序,也叫本地app。一般使用的开发语言为JAVA、C++、Objective-C。\n\n自iOS和Android这两个的手机操作系统发布以来，在互联网界从此就多了一个新的名词：App意为运行在智能的移动终端设备第三方应用程序)。\n\nNative App因为位于平台层上方，向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。但是比较乐观的是，AppStore培养了一种比较好的用户付费模式，所以在Apple的生态圈里，开发者的盈利模式是一种明朗状态，其他market也在往这条路上靠拢。\n\n### 优势\n\n1、相比于其它模式，提供最佳的用户体验，最优质的用户界面，最华丽的交互\n2、针对不同平台提供不同体验\n3、可节省带宽成本，打开速度更快\n4、功能最为强大,特别是在与系统交互中,几乎所有功能都能实现\n\n### 劣势\n\n1、门槛高，原生开发人才稀缺，至少比前端和后端少，开发环境昂贵\n2、无法跨平台，开发的成本比较大，各个系统独立开发\n3、发布成本高，需要通过store或market的审核，导致更新缓慢\n4、维持多个版本、多个系统的成本比较高，而且必须做兼容\n5、应用市场逐渐饱和，怎么样抢占用户时间需要投入大量时间和金钱，这也导致“僵尸”App的增多\n\n## WebApp\n\n![APP开发选型 - 第2张  | 张嘎](https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-a16fa91905d4214e.png?w=640)\n\n说到Web App不少人会联想到WAP，或者有人认为，WAP就是WebApp，其实不然。\n\nWebApp与WAP最直接的区别就是功能层面。WAP更侧重使用网页技术在移动端做展示，包括文字、媒体文件等。而Web App更侧重“功能”，是使用网页技术实现的App。总的来说，Web App就是运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用。\n\n响应式的大部分技术都是为实现WebApp能适配多类客户端而设计的。\n\nWeb网站一般分两种，MPA(Multi-page Application)和SPA(Single-page Application)。而WebApp一般泛指SPA形式开发出的网站。这样更像是一个App。\n\n### 优势\n\n1、可以跨平台，调试方便\n2、无需安装，不会占用手机内存，而且更新速度最快\n3、不存在多版本问题，维护成本低\n4、临时入口，可以随意嵌入\n\n### 劣势\n\n1、依赖于网络，第一次访问页面速度慢，耗费流量\n2、受限于手机和浏览器性能，用户体验相较于其他模式最差\n3、功能受限，大量移动端功能无法实现\n4、入口强依赖于第三方浏览器，且只能以URL地址的形式存在，导致用户留存率低（优点即缺点）\n\n## Hybird App\n\n![APP开发选型 - 第3张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-e8ed4f0375d2639b.png?w=640)\n\n混合开发，也就是半原生半Web的开发模式，由原生提供统一的API给JS调用，实际的主要逻辑有Html和JS来完成，最终是放在webview中显示的，所以只需要写一套代码即可达到跨平台效果，另外也可以直接在浏览器中调试，很方便。最重要的是只需要一个前端人员稍微学习下JS api的调用即可。\n\nHybird App 的较早实践者是PhoneGap，随后遍地开花，如Titanium、Salama、WeX5、Kerkee和国内的AppCan，项目各有各的实现方式，大致的原理基本相同。有幸在AppCan上海总部参与过一段时间的学习研究，如下大致简介：\n\nAppCan是基于HTML5技术的Hybird跨平台移动应用开发工具。开发者利用HTML5+CSS3+JavaScript技术，通过AppCan IDE集成开发系统、云端打包器等，快速开发出Android、iOS、WP平台上的移动应用。\n\nAppCan的平台构成\n\n![APP开发选型 - 第4张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-cd8c63378a612022.png?w=640)\n\n在实际的APP开发中，AppCan可以完成大部分的工作量，如图示：\n\n![APP开发选型 - 第5张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-634591b2598fa8ad.png?w=640)\n\nAppCan将APP底层复杂的原生功能封装在引擎、插件中，开发者仅需调用接口、打包编译，就可以获得原生功能；灵活的插件扩展机制。\n\n开发者可以像开发WebApp一样开发app的视觉UI，以及绝大部分的交互，当需要使用原生功能（如摄像头，陀螺仪等功能）时，只需要调用官方的API就可以轻松实现Native的效果。至于JS和Native的通信，常用的有URL监听和绝大部分Hybrid厂商使用的JSBridge通信，两者原理相近。\n\n![APP开发选型 - 第6张  | 张嘎](https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-400b4c6162d774f4.png?w=640)\n\nJsBridge通信简图\n\n关于JsBridge的原理详解，可见[http://blog.csdn.net/xiangzhihong8/article/details/66970600](https://link.jianshu.com/?t=http://blog.csdn.net/xiangzhihong8/article/details/66970600)\n\n在Hybird概念盛行的时候，国内外各大公司也参与了探索，国外代表有Facebook、google、亚马逊，国内的有腾讯、阿里巴巴、网易等，慢慢的他们发现Hybird严重受限于WebView的解析渲染效率，于是Facebook开始了他的类原生的研究探索。\n\n## React Native App\n\n![APP开发选型 - 第7张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-846d1bcbe4f9b505.png?w=640)\n\n请移驾 [【笔记】React Native 快速入门笔记](https://link.jianshu.com/?t=https://segmentfault.com/a/1190000010989345)\n\n## Weex App\n\n![APP开发选型 - 第8张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-ec1e7c9c4de9f9c0.png?w=640)\n\n请移驾[网易严选App感受Weex开发](https://link.jianshu.com/?t=https://segmentfault.com/a/1190000011027225)\n\n作者：木羽zwwill\n链接：https://www.jianshu.com/p/33246251cfae\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n\n真的从入门到放弃，fluuter\n\nhttp://www.52im.net/thread-1870-1-1.html\n\nhttps://www.jianshu.com/p/139c5074ae5d\n\n","slug":"app-dev","published":1,"updated":"2021-08-25T12:25:36.661Z","_id":"cksrgwkhf000issmngzyba8tu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"这次真的是从入坑到弃坑。最后还是觉得使用flutter\"><a href=\"#这次真的是从入坑到弃坑。最后还是觉得使用flutter\" class=\"headerlink\" title=\"这次真的是从入坑到弃坑。最后还是觉得使用flutter\"></a>这次真的是从入坑到弃坑。最后还是觉得使用flutter</h2><p>在使用weex做了一个简单的应用，调通通信和资源加载后，发现坑还是很多的。</p>\n<p>主要weex适合用来做单页面的开发，开发完整的APP还是有一些局限性，在浏览器端调试也存在问题。</p>\n<p>主要还是社区和文档很不齐全。</p>\n<p>为什么选择flutter呢？</p>\n<span id=\"more\"></span>\n\n<p>1.google爸爸背书。</p>\n<p>2.dart开发。（自己对JS不熟悉。常年使用JAVA）</p>\n<p>3.idea，和服务器端统一IDE。</p>\n<p>4.flutter的理念才是跨平台的最终解决方案。</p>\n<p>5.感觉不能再好了、</p>\n<p>ps：就在前几天（2018.12.5）出正式1.0版本了</p>\n<h2 id=\"原文：\"><a href=\"#原文：\" class=\"headerlink\" title=\"原文：\"></a>原文：</h2><p>最近有做一款APP的想法，调研下开发工具链。一直做游戏开发，引擎用过u3d，cocos，egret。</p>\n<p>最终决定使用weex。</p>\n<p>学习整理：</p>\n<p><a href=\"https://segmentfault.com/a/1190000011027225\">https://segmentfault.com/a/1190000011027225</a></p>\n<p>html，css的基础知识；</p>\n<p>Node：<a href=\"http://www.runoob.com/nodejs/nodejs-tutorial.html\">《Node.js 教程》</a><br>Vue：<a href=\"https://cn.vuejs.org/v2/guide/\">《Vue.js官方教程》</a><br>ES6：<a href=\"http://es6.ruanyifeng.com/\">《ECMAScript 6 入门》</a></p>\n<p>转载：<a href=\"https://www.jianshu.com/p/33246251cfae\">https://www.jianshu.com/p/33246251cfae</a></p>\n<h1 id=\"浅谈Native、Web-App、Hybrid、ReactNative和WEEX的优劣\"><a href=\"#浅谈Native、Web-App、Hybrid、ReactNative和WEEX的优劣\" class=\"headerlink\" title=\"浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣\"></a>浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣</h1><h1 id=\"一句话概要\"><a href=\"#一句话概要\" class=\"headerlink\" title=\"一句话概要\"></a>一句话概要</h1><blockquote>\n<p>Native、Web App、Hybrid、ReactNative（后面以RN简称）、WEEX间的异同点</p>\n</blockquote>\n<h1 id=\"APP常用开发模式【简介】\"><a href=\"#APP常用开发模式【简介】\" class=\"headerlink\" title=\"APP常用开发模式【简介】\"></a>APP常用开发模式【简介】</h1><p>此处APP为应用，application，并非我们通常讲的手机App<br><a href=\"https://link.jianshu.com/?t=http://naotu.baidu.com/file/6af15fcbb72f89926043779811b1ea44?token=df0378691ecdcef2\">常用的几种APP开发模式-脑图</a></p>\n<h2 id=\"Native-App\"><a href=\"#Native-App\" class=\"headerlink\" title=\"Native App\"></a>Native App</h2><p>传统的原生APP开发模式，有IOS和AOS两大系统，需要各自语言开发各自APP。</p>\n<p><strong>优点</strong>：性能和体验都是最好的<br><strong>缺点</strong>：开发和发布成本高<br><strong>举个栗子</strong>：<a href=\"https://link.jianshu.com/?t=https://id.163.com/gj/\">网易管家APP</a> （Tab1，Tab2）<br><strong>应用技术</strong>：Swift，OC，JAVA</p>\n<h2 id=\"WebApp\"><a href=\"#WebApp\" class=\"headerlink\" title=\"WebApp\"></a>WebApp</h2><p>移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application，再后面做介绍）对应。</p>\n<p><strong>优点</strong>：开发和发布成本最低<br><strong>缺点</strong>：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量<br><strong>举个栗子</strong>：<a href=\"https://link.jianshu.com/?t=https://id.163.com/gj/\">网易管家APP</a>（Tab3）<br><strong>应用技术</strong>：ReactJS，RegularJS等</p>\n<h2 id=\"Hybrid-App\"><a href=\"#Hybrid-App\" class=\"headerlink\" title=\"Hybrid App\"></a>Hybrid App</h2><p>混合模式移动应用，介于web-app、native-app这两者之间的app，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）</p>\n<p>主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用HTML+CSS实现界面，JS来写逻辑，调用API，最终的页面在webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所有有跨平台效果。</p>\n<p><strong>优点</strong>：开发和发布都比较方便，效率介于Native App、Web App之间<br><strong>缺点</strong>：学习范围较广，需要原生配合<br><strong>举个栗子</strong>：<a href=\"https://link.jianshu.com/?t=https://music.163.com/#/download\">网易云音乐</a>，我爱我家App<br><strong>应用技术</strong>：PhoneGap，AppCan，Wex5</p>\n<h2 id=\"React-Native-App\"><a href=\"#React-Native-App\" class=\"headerlink\" title=\"React Native App\"></a>React Native App</h2><p>Facebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的APP开发方案RN App。。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。</p>\n<p><strong>优点</strong>：效率体验接近Native App，发布和开发成本低于Native App<br><strong>缺点</strong>：学习有一定成本，且文档较少，免不了踩坑<br><strong>举个栗子</strong>：Facebook、youtube、discord、QQ、百度等等</p>\n<h2 id=\"WEEX-App\"><a href=\"#WEEX-App\" class=\"headerlink\" title=\"WEEX App\"></a>WEEX App</h2><p>阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。</p>\n<p><strong>优点</strong>：开发效率和体验上跟RN不相上下，并且跨平台性更强<br><strong>缺点</strong>：刚刚起步，社区没有RN活跃<br><strong>举个栗子</strong>：淘宝、天猫、饿了么等</p>\n<h1 id=\"继续剖析\"><a href=\"#继续剖析\" class=\"headerlink\" title=\"继续剖析\"></a>继续剖析</h1><h2 id=\"Native-App-1\"><a href=\"#Native-App-1\" class=\"headerlink\" title=\"Native App\"></a>Native App</h2><p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-70fa348f3db0fca7.png?w=640\" alt=\"APP开发选型 - 第1张  | 张嘎\"></p>\n<p>Native App是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序,也叫本地app。一般使用的开发语言为JAVA、C++、Objective-C。</p>\n<p>自iOS和Android这两个的手机操作系统发布以来，在互联网界从此就多了一个新的名词：App意为运行在智能的移动终端设备第三方应用程序)。</p>\n<p>Native App因为位于平台层上方，向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。但是比较乐观的是，AppStore培养了一种比较好的用户付费模式，所以在Apple的生态圈里，开发者的盈利模式是一种明朗状态，其他market也在往这条路上靠拢。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>1、相比于其它模式，提供最佳的用户体验，最优质的用户界面，最华丽的交互<br>2、针对不同平台提供不同体验<br>3、可节省带宽成本，打开速度更快<br>4、功能最为强大,特别是在与系统交互中,几乎所有功能都能实现</p>\n<h3 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><p>1、门槛高，原生开发人才稀缺，至少比前端和后端少，开发环境昂贵<br>2、无法跨平台，开发的成本比较大，各个系统独立开发<br>3、发布成本高，需要通过store或market的审核，导致更新缓慢<br>4、维持多个版本、多个系统的成本比较高，而且必须做兼容<br>5、应用市场逐渐饱和，怎么样抢占用户时间需要投入大量时间和金钱，这也导致“僵尸”App的增多</p>\n<h2 id=\"WebApp-1\"><a href=\"#WebApp-1\" class=\"headerlink\" title=\"WebApp\"></a>WebApp</h2><p><img src=\"https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-a16fa91905d4214e.png?w=640\" alt=\"APP开发选型 - 第2张  | 张嘎\"></p>\n<p>说到Web App不少人会联想到WAP，或者有人认为，WAP就是WebApp，其实不然。</p>\n<p>WebApp与WAP最直接的区别就是功能层面。WAP更侧重使用网页技术在移动端做展示，包括文字、媒体文件等。而Web App更侧重“功能”，是使用网页技术实现的App。总的来说，Web App就是运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用。</p>\n<p>响应式的大部分技术都是为实现WebApp能适配多类客户端而设计的。</p>\n<p>Web网站一般分两种，MPA(Multi-page Application)和SPA(Single-page Application)。而WebApp一般泛指SPA形式开发出的网站。这样更像是一个App。</p>\n<h3 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>1、可以跨平台，调试方便<br>2、无需安装，不会占用手机内存，而且更新速度最快<br>3、不存在多版本问题，维护成本低<br>4、临时入口，可以随意嵌入</p>\n<h3 id=\"劣势-1\"><a href=\"#劣势-1\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><p>1、依赖于网络，第一次访问页面速度慢，耗费流量<br>2、受限于手机和浏览器性能，用户体验相较于其他模式最差<br>3、功能受限，大量移动端功能无法实现<br>4、入口强依赖于第三方浏览器，且只能以URL地址的形式存在，导致用户留存率低（优点即缺点）</p>\n<h2 id=\"Hybird-App\"><a href=\"#Hybird-App\" class=\"headerlink\" title=\"Hybird App\"></a>Hybird App</h2><p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-e8ed4f0375d2639b.png?w=640\" alt=\"APP开发选型 - 第3张  | 张嘎\"></p>\n<p>混合开发，也就是半原生半Web的开发模式，由原生提供统一的API给JS调用，实际的主要逻辑有Html和JS来完成，最终是放在webview中显示的，所以只需要写一套代码即可达到跨平台效果，另外也可以直接在浏览器中调试，很方便。最重要的是只需要一个前端人员稍微学习下JS api的调用即可。</p>\n<p>Hybird App 的较早实践者是PhoneGap，随后遍地开花，如Titanium、Salama、WeX5、Kerkee和国内的AppCan，项目各有各的实现方式，大致的原理基本相同。有幸在AppCan上海总部参与过一段时间的学习研究，如下大致简介：</p>\n<p>AppCan是基于HTML5技术的Hybird跨平台移动应用开发工具。开发者利用HTML5+CSS3+JavaScript技术，通过AppCan IDE集成开发系统、云端打包器等，快速开发出Android、iOS、WP平台上的移动应用。</p>\n<p>AppCan的平台构成</p>\n<p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-cd8c63378a612022.png?w=640\" alt=\"APP开发选型 - 第4张  | 张嘎\"></p>\n<p>在实际的APP开发中，AppCan可以完成大部分的工作量，如图示：</p>\n<p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-634591b2598fa8ad.png?w=640\" alt=\"APP开发选型 - 第5张  | 张嘎\"></p>\n<p>AppCan将APP底层复杂的原生功能封装在引擎、插件中，开发者仅需调用接口、打包编译，就可以获得原生功能；灵活的插件扩展机制。</p>\n<p>开发者可以像开发WebApp一样开发app的视觉UI，以及绝大部分的交互，当需要使用原生功能（如摄像头，陀螺仪等功能）时，只需要调用官方的API就可以轻松实现Native的效果。至于JS和Native的通信，常用的有URL监听和绝大部分Hybrid厂商使用的JSBridge通信，两者原理相近。</p>\n<p><img src=\"https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-400b4c6162d774f4.png?w=640\" alt=\"APP开发选型 - 第6张  | 张嘎\"></p>\n<p>JsBridge通信简图</p>\n<p>关于JsBridge的原理详解，可见<a href=\"https://link.jianshu.com/?t=http://blog.csdn.net/xiangzhihong8/article/details/66970600\">http://blog.csdn.net/xiangzhihong8/article/details/66970600</a></p>\n<p>在Hybird概念盛行的时候，国内外各大公司也参与了探索，国外代表有Facebook、google、亚马逊，国内的有腾讯、阿里巴巴、网易等，慢慢的他们发现Hybird严重受限于WebView的解析渲染效率，于是Facebook开始了他的类原生的研究探索。</p>\n<h2 id=\"React-Native-App-1\"><a href=\"#React-Native-App-1\" class=\"headerlink\" title=\"React Native App\"></a>React Native App</h2><p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-846d1bcbe4f9b505.png?w=640\" alt=\"APP开发选型 - 第7张  | 张嘎\"></p>\n<p>请移驾 <a href=\"https://link.jianshu.com/?t=https://segmentfault.com/a/1190000010989345\">【笔记】React Native 快速入门笔记</a></p>\n<h2 id=\"Weex-App\"><a href=\"#Weex-App\" class=\"headerlink\" title=\"Weex App\"></a>Weex App</h2><p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-ec1e7c9c4de9f9c0.png?w=640\" alt=\"APP开发选型 - 第8张  | 张嘎\"></p>\n<p>请移驾<a href=\"https://link.jianshu.com/?t=https://segmentfault.com/a/1190000011027225\">网易严选App感受Weex开发</a></p>\n<p>作者：木羽zwwill<br>链接：<a href=\"https://www.jianshu.com/p/33246251cfae\">https://www.jianshu.com/p/33246251cfae</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>\n<p>真的从入门到放弃，fluuter</p>\n<p><a href=\"http://www.52im.net/thread-1870-1-1.html\">http://www.52im.net/thread-1870-1-1.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/139c5074ae5d\">https://www.jianshu.com/p/139c5074ae5d</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"这次真的是从入坑到弃坑。最后还是觉得使用flutter\"><a href=\"#这次真的是从入坑到弃坑。最后还是觉得使用flutter\" class=\"headerlink\" title=\"这次真的是从入坑到弃坑。最后还是觉得使用flutter\"></a>这次真的是从入坑到弃坑。最后还是觉得使用flutter</h2><p>在使用weex做了一个简单的应用，调通通信和资源加载后，发现坑还是很多的。</p>\n<p>主要weex适合用来做单页面的开发，开发完整的APP还是有一些局限性，在浏览器端调试也存在问题。</p>\n<p>主要还是社区和文档很不齐全。</p>\n<p>为什么选择flutter呢？</p>","more":"<p>1.google爸爸背书。</p>\n<p>2.dart开发。（自己对JS不熟悉。常年使用JAVA）</p>\n<p>3.idea，和服务器端统一IDE。</p>\n<p>4.flutter的理念才是跨平台的最终解决方案。</p>\n<p>5.感觉不能再好了、</p>\n<p>ps：就在前几天（2018.12.5）出正式1.0版本了</p>\n<h2 id=\"原文：\"><a href=\"#原文：\" class=\"headerlink\" title=\"原文：\"></a>原文：</h2><p>最近有做一款APP的想法，调研下开发工具链。一直做游戏开发，引擎用过u3d，cocos，egret。</p>\n<p>最终决定使用weex。</p>\n<p>学习整理：</p>\n<p><a href=\"https://segmentfault.com/a/1190000011027225\">https://segmentfault.com/a/1190000011027225</a></p>\n<p>html，css的基础知识；</p>\n<p>Node：<a href=\"http://www.runoob.com/nodejs/nodejs-tutorial.html\">《Node.js 教程》</a><br>Vue：<a href=\"https://cn.vuejs.org/v2/guide/\">《Vue.js官方教程》</a><br>ES6：<a href=\"http://es6.ruanyifeng.com/\">《ECMAScript 6 入门》</a></p>\n<p>转载：<a href=\"https://www.jianshu.com/p/33246251cfae\">https://www.jianshu.com/p/33246251cfae</a></p>\n<h1 id=\"浅谈Native、Web-App、Hybrid、ReactNative和WEEX的优劣\"><a href=\"#浅谈Native、Web-App、Hybrid、ReactNative和WEEX的优劣\" class=\"headerlink\" title=\"浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣\"></a>浅谈Native、Web App、Hybrid、ReactNative和WEEX的优劣</h1><h1 id=\"一句话概要\"><a href=\"#一句话概要\" class=\"headerlink\" title=\"一句话概要\"></a>一句话概要</h1><blockquote>\n<p>Native、Web App、Hybrid、ReactNative（后面以RN简称）、WEEX间的异同点</p>\n</blockquote>\n<h1 id=\"APP常用开发模式【简介】\"><a href=\"#APP常用开发模式【简介】\" class=\"headerlink\" title=\"APP常用开发模式【简介】\"></a>APP常用开发模式【简介】</h1><p>此处APP为应用，application，并非我们通常讲的手机App<br><a href=\"https://link.jianshu.com/?t=http://naotu.baidu.com/file/6af15fcbb72f89926043779811b1ea44?token=df0378691ecdcef2\">常用的几种APP开发模式-脑图</a></p>\n<h2 id=\"Native-App\"><a href=\"#Native-App\" class=\"headerlink\" title=\"Native App\"></a>Native App</h2><p>传统的原生APP开发模式，有IOS和AOS两大系统，需要各自语言开发各自APP。</p>\n<p><strong>优点</strong>：性能和体验都是最好的<br><strong>缺点</strong>：开发和发布成本高<br><strong>举个栗子</strong>：<a href=\"https://link.jianshu.com/?t=https://id.163.com/gj/\">网易管家APP</a> （Tab1，Tab2）<br><strong>应用技术</strong>：Swift，OC，JAVA</p>\n<h2 id=\"WebApp\"><a href=\"#WebApp\" class=\"headerlink\" title=\"WebApp\"></a>WebApp</h2><p>移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application，再后面做介绍）对应。</p>\n<p><strong>优点</strong>：开发和发布成本最低<br><strong>缺点</strong>：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量<br><strong>举个栗子</strong>：<a href=\"https://link.jianshu.com/?t=https://id.163.com/gj/\">网易管家APP</a>（Tab3）<br><strong>应用技术</strong>：ReactJS，RegularJS等</p>\n<h2 id=\"Hybrid-App\"><a href=\"#Hybrid-App\" class=\"headerlink\" title=\"Hybrid App\"></a>Hybrid App</h2><p>混合模式移动应用，介于web-app、native-app这两者之间的app，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）</p>\n<p>主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用HTML+CSS实现界面，JS来写逻辑，调用API，最终的页面在webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所有有跨平台效果。</p>\n<p><strong>优点</strong>：开发和发布都比较方便，效率介于Native App、Web App之间<br><strong>缺点</strong>：学习范围较广，需要原生配合<br><strong>举个栗子</strong>：<a href=\"https://link.jianshu.com/?t=https://music.163.com/#/download\">网易云音乐</a>，我爱我家App<br><strong>应用技术</strong>：PhoneGap，AppCan，Wex5</p>\n<h2 id=\"React-Native-App\"><a href=\"#React-Native-App\" class=\"headerlink\" title=\"React Native App\"></a>React Native App</h2><p>Facebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的APP开发方案RN App。。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。</p>\n<p><strong>优点</strong>：效率体验接近Native App，发布和开发成本低于Native App<br><strong>缺点</strong>：学习有一定成本，且文档较少，免不了踩坑<br><strong>举个栗子</strong>：Facebook、youtube、discord、QQ、百度等等</p>\n<h2 id=\"WEEX-App\"><a href=\"#WEEX-App\" class=\"headerlink\" title=\"WEEX App\"></a>WEEX App</h2><p>阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。</p>\n<p><strong>优点</strong>：开发效率和体验上跟RN不相上下，并且跨平台性更强<br><strong>缺点</strong>：刚刚起步，社区没有RN活跃<br><strong>举个栗子</strong>：淘宝、天猫、饿了么等</p>\n<h1 id=\"继续剖析\"><a href=\"#继续剖析\" class=\"headerlink\" title=\"继续剖析\"></a>继续剖析</h1><h2 id=\"Native-App-1\"><a href=\"#Native-App-1\" class=\"headerlink\" title=\"Native App\"></a>Native App</h2><p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-70fa348f3db0fca7.png?w=640\" alt=\"APP开发选型 - 第1张  | 张嘎\"></p>\n<p>Native App是一种基于智能手机本地操作系统如iOS、Android、WP并使用原生程式编写运行的第三方应用程序,也叫本地app。一般使用的开发语言为JAVA、C++、Objective-C。</p>\n<p>自iOS和Android这两个的手机操作系统发布以来，在互联网界从此就多了一个新的名词：App意为运行在智能的移动终端设备第三方应用程序)。</p>\n<p>Native App因为位于平台层上方，向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。但是比较乐观的是，AppStore培养了一种比较好的用户付费模式，所以在Apple的生态圈里，开发者的盈利模式是一种明朗状态，其他market也在往这条路上靠拢。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>1、相比于其它模式，提供最佳的用户体验，最优质的用户界面，最华丽的交互<br>2、针对不同平台提供不同体验<br>3、可节省带宽成本，打开速度更快<br>4、功能最为强大,特别是在与系统交互中,几乎所有功能都能实现</p>\n<h3 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><p>1、门槛高，原生开发人才稀缺，至少比前端和后端少，开发环境昂贵<br>2、无法跨平台，开发的成本比较大，各个系统独立开发<br>3、发布成本高，需要通过store或market的审核，导致更新缓慢<br>4、维持多个版本、多个系统的成本比较高，而且必须做兼容<br>5、应用市场逐渐饱和，怎么样抢占用户时间需要投入大量时间和金钱，这也导致“僵尸”App的增多</p>\n<h2 id=\"WebApp-1\"><a href=\"#WebApp-1\" class=\"headerlink\" title=\"WebApp\"></a>WebApp</h2><p><img src=\"https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-a16fa91905d4214e.png?w=640\" alt=\"APP开发选型 - 第2张  | 张嘎\"></p>\n<p>说到Web App不少人会联想到WAP，或者有人认为，WAP就是WebApp，其实不然。</p>\n<p>WebApp与WAP最直接的区别就是功能层面。WAP更侧重使用网页技术在移动端做展示，包括文字、媒体文件等。而Web App更侧重“功能”，是使用网页技术实现的App。总的来说，Web App就是运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用。</p>\n<p>响应式的大部分技术都是为实现WebApp能适配多类客户端而设计的。</p>\n<p>Web网站一般分两种，MPA(Multi-page Application)和SPA(Single-page Application)。而WebApp一般泛指SPA形式开发出的网站。这样更像是一个App。</p>\n<h3 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>1、可以跨平台，调试方便<br>2、无需安装，不会占用手机内存，而且更新速度最快<br>3、不存在多版本问题，维护成本低<br>4、临时入口，可以随意嵌入</p>\n<h3 id=\"劣势-1\"><a href=\"#劣势-1\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><p>1、依赖于网络，第一次访问页面速度慢，耗费流量<br>2、受限于手机和浏览器性能，用户体验相较于其他模式最差<br>3、功能受限，大量移动端功能无法实现<br>4、入口强依赖于第三方浏览器，且只能以URL地址的形式存在，导致用户留存率低（优点即缺点）</p>\n<h2 id=\"Hybird-App\"><a href=\"#Hybird-App\" class=\"headerlink\" title=\"Hybird App\"></a>Hybird App</h2><p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-e8ed4f0375d2639b.png?w=640\" alt=\"APP开发选型 - 第3张  | 张嘎\"></p>\n<p>混合开发，也就是半原生半Web的开发模式，由原生提供统一的API给JS调用，实际的主要逻辑有Html和JS来完成，最终是放在webview中显示的，所以只需要写一套代码即可达到跨平台效果，另外也可以直接在浏览器中调试，很方便。最重要的是只需要一个前端人员稍微学习下JS api的调用即可。</p>\n<p>Hybird App 的较早实践者是PhoneGap，随后遍地开花，如Titanium、Salama、WeX5、Kerkee和国内的AppCan，项目各有各的实现方式，大致的原理基本相同。有幸在AppCan上海总部参与过一段时间的学习研究，如下大致简介：</p>\n<p>AppCan是基于HTML5技术的Hybird跨平台移动应用开发工具。开发者利用HTML5+CSS3+JavaScript技术，通过AppCan IDE集成开发系统、云端打包器等，快速开发出Android、iOS、WP平台上的移动应用。</p>\n<p>AppCan的平台构成</p>\n<p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-cd8c63378a612022.png?w=640\" alt=\"APP开发选型 - 第4张  | 张嘎\"></p>\n<p>在实际的APP开发中，AppCan可以完成大部分的工作量，如图示：</p>\n<p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/1494908-634591b2598fa8ad.png?w=640\" alt=\"APP开发选型 - 第5张  | 张嘎\"></p>\n<p>AppCan将APP底层复杂的原生功能封装在引擎、插件中，开发者仅需调用接口、打包编译，就可以获得原生功能；灵活的插件扩展机制。</p>\n<p>开发者可以像开发WebApp一样开发app的视觉UI，以及绝大部分的交互，当需要使用原生功能（如摄像头，陀螺仪等功能）时，只需要调用官方的API就可以轻松实现Native的效果。至于JS和Native的通信，常用的有URL监听和绝大部分Hybrid厂商使用的JSBridge通信，两者原理相近。</p>\n<p><img src=\"https://i1.wp.com/upload-images.jianshu.io/upload_images/1494908-400b4c6162d774f4.png?w=640\" alt=\"APP开发选型 - 第6张  | 张嘎\"></p>\n<p>JsBridge通信简图</p>\n<p>关于JsBridge的原理详解，可见<a href=\"https://link.jianshu.com/?t=http://blog.csdn.net/xiangzhihong8/article/details/66970600\">http://blog.csdn.net/xiangzhihong8/article/details/66970600</a></p>\n<p>在Hybird概念盛行的时候，国内外各大公司也参与了探索，国外代表有Facebook、google、亚马逊，国内的有腾讯、阿里巴巴、网易等，慢慢的他们发现Hybird严重受限于WebView的解析渲染效率，于是Facebook开始了他的类原生的研究探索。</p>\n<h2 id=\"React-Native-App-1\"><a href=\"#React-Native-App-1\" class=\"headerlink\" title=\"React Native App\"></a>React Native App</h2><p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-846d1bcbe4f9b505.png?w=640\" alt=\"APP开发选型 - 第7张  | 张嘎\"></p>\n<p>请移驾 <a href=\"https://link.jianshu.com/?t=https://segmentfault.com/a/1190000010989345\">【笔记】React Native 快速入门笔记</a></p>\n<h2 id=\"Weex-App\"><a href=\"#Weex-App\" class=\"headerlink\" title=\"Weex App\"></a>Weex App</h2><p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/1494908-ec1e7c9c4de9f9c0.png?w=640\" alt=\"APP开发选型 - 第8张  | 张嘎\"></p>\n<p>请移驾<a href=\"https://link.jianshu.com/?t=https://segmentfault.com/a/1190000011027225\">网易严选App感受Weex开发</a></p>\n<p>作者：木羽zwwill<br>链接：<a href=\"https://www.jianshu.com/p/33246251cfae\">https://www.jianshu.com/p/33246251cfae</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>\n<p>真的从入门到放弃，fluuter</p>\n<p><a href=\"http://www.52im.net/thread-1870-1-1.html\">http://www.52im.net/thread-1870-1-1.html</a></p>\n<p><a href=\"https://www.jianshu.com/p/139c5074ae5d\">https://www.jianshu.com/p/139c5074ae5d</a></p>"},{"title":"Weex环境搭建","date":"2018-07-25T12:36:23.000Z","id":"weex-dev0","_content":"\n## 一、安装node.js\n\n点击链接 [http://nodejs.cn/download/](https://link.jianshu.com/?t=http://nodejs.cn/download/) 选择你需要安装的版本（windows ，mac，linux 3种系统的版本），下载你需要的版本\n\n![Weex环境搭建 - 第1张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-4c3b9f270d217291.png?w=640&ssl=1)\n\n<!--more-->\n\n点击安装包，下一步，下一步，安装完成即可。\n执行查看node版本号\n\n```\nnode -v\n```\n\n显示当前node版本号\n\n```\ndeiMac:~ li$ node -v\nv8.1.0\n```\n\n查看npm配置信息\n\n```\nnpm config ls\n```\n\n2.修改路径\n\n这里需要修改两个路径，module路径和cache路径\n\nmodule对应prefix\n\ncache对应cache\n\n首先在别的盘新建两个目录\n\nD:\\nodejs\\node_global\n\nD:\\nodejs\\node_cache\n\n然后依次执行\n\n修改配置文件（userconfig C:\\Users\\zhangga\\.npmrc）中对应的路径\n\n或者命令行修改\n\nnpm config set prefix”D:\\nodejs\\node_global”\n\nnpm config set cache”D:\\nodejs\\node_cache”\n\n3.修改环境变量\n\n新增环境变量 NODE_HOME\n\n![Weex环境搭建 - 第2张  | 张嘎](https://blog.csdn.net/wkkyo/article/details/52799488)\n\n![Weex环境搭建 - 第3张  | 张嘎](https://img-blog.csdn.net/20161013135353107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n修改Path，追加 %NODE_HOME%\\;%NODE_HOME%\\node_global\\;\n\n使用淘宝NPM源\n\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n## 二、安装webpack\n\n```\n//全局安装\n$ cnpm install -g webpack\n```\n\n或者\n\n```\n//安装到你的项目目录\n$ cd 你的工程目录\n$ cnpm install --save-dev webpack\n```\n\n## 三、安装serve\n\n```\n//全局安装\n$ cnpm install -g serve\n```\n\n或者\n\n```\n//安装到你的项目目录\n$ cd 你的工程目录\n$ cnpm install  serve\n```\n\n## 四、安装weexpack\n\n首先，全局安装 weex-pack 命令：\n\n```\n$ cnpm install -g weexpack\n```\n\n或者 在 clone 的 weexpack 根目录下执行\n\n```\n$ cnpm install\n```\n\n1. 创建 weexpack 工程\n\n```\n$ weexpack create appName\n```\n\n使用WebStrom打开创建的工程目录如下\n\n![Weex环境搭建 - 第4张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/63643-9f0f43e765b4f787.png?w=640)\n\n2.进入创建的工程目录，并且安装相关依赖\n\n```\n$ cd appName && cnpm install\n```\n\n安装完第三方依赖，工程目录添加了node_modules目录\n\n![Weex环境搭建 - 第5张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-ef5d1f547e4d5e25.png?w=640)\n\n### weex-toolkit和weexpack的区别\n\nweex-toolkit 初始化的项目是针对开发单个 Weex 页面而设计的，也就是说这样的项目只包括单个页面开发需要的东西，比如前端页面源文件、webpack 配置、npm 脚本等。项目产生的输出就是一个 JS Bundle 文件，可以自由的进行部署。\nweex-pack 是初始化一个完整的 App 工程，包括 Android 和 iOS 的整个 App 起步，前端页面只是其中的一部分。这样的项目最终产出是一个 Android App 和一个 iOS App。\n\n## 五、创建.babelrc文件\n\n将ES6转成ES5代码执行\n\n```\n{ \"presets\": [\"es2015\"] }\n```\n\n## 六、发布安卓\n\n安装androidSDK，配置环境变量。\n\nnpm run build\n\nweex platform add android\n\nweex build android\n\n坑：\n","source":"_posts/weex-dev0.md","raw":"---\ntitle: Weex环境搭建\ndate: 2018-07-25 20:36:23\ntags:\n  - 笔记\nid: weex-dev0\ncategories:\n  - 笔记\n---\n\n## 一、安装node.js\n\n点击链接 [http://nodejs.cn/download/](https://link.jianshu.com/?t=http://nodejs.cn/download/) 选择你需要安装的版本（windows ，mac，linux 3种系统的版本），下载你需要的版本\n\n![Weex环境搭建 - 第1张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-4c3b9f270d217291.png?w=640&ssl=1)\n\n<!--more-->\n\n点击安装包，下一步，下一步，安装完成即可。\n执行查看node版本号\n\n```\nnode -v\n```\n\n显示当前node版本号\n\n```\ndeiMac:~ li$ node -v\nv8.1.0\n```\n\n查看npm配置信息\n\n```\nnpm config ls\n```\n\n2.修改路径\n\n这里需要修改两个路径，module路径和cache路径\n\nmodule对应prefix\n\ncache对应cache\n\n首先在别的盘新建两个目录\n\nD:\\nodejs\\node_global\n\nD:\\nodejs\\node_cache\n\n然后依次执行\n\n修改配置文件（userconfig C:\\Users\\zhangga\\.npmrc）中对应的路径\n\n或者命令行修改\n\nnpm config set prefix”D:\\nodejs\\node_global”\n\nnpm config set cache”D:\\nodejs\\node_cache”\n\n3.修改环境变量\n\n新增环境变量 NODE_HOME\n\n![Weex环境搭建 - 第2张  | 张嘎](https://blog.csdn.net/wkkyo/article/details/52799488)\n\n![Weex环境搭建 - 第3张  | 张嘎](https://img-blog.csdn.net/20161013135353107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n修改Path，追加 %NODE_HOME%\\;%NODE_HOME%\\node_global\\;\n\n使用淘宝NPM源\n\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n## 二、安装webpack\n\n```\n//全局安装\n$ cnpm install -g webpack\n```\n\n或者\n\n```\n//安装到你的项目目录\n$ cd 你的工程目录\n$ cnpm install --save-dev webpack\n```\n\n## 三、安装serve\n\n```\n//全局安装\n$ cnpm install -g serve\n```\n\n或者\n\n```\n//安装到你的项目目录\n$ cd 你的工程目录\n$ cnpm install  serve\n```\n\n## 四、安装weexpack\n\n首先，全局安装 weex-pack 命令：\n\n```\n$ cnpm install -g weexpack\n```\n\n或者 在 clone 的 weexpack 根目录下执行\n\n```\n$ cnpm install\n```\n\n1. 创建 weexpack 工程\n\n```\n$ weexpack create appName\n```\n\n使用WebStrom打开创建的工程目录如下\n\n![Weex环境搭建 - 第4张  | 张嘎](https://i2.wp.com/upload-images.jianshu.io/upload_images/63643-9f0f43e765b4f787.png?w=640)\n\n2.进入创建的工程目录，并且安装相关依赖\n\n```\n$ cd appName && cnpm install\n```\n\n安装完第三方依赖，工程目录添加了node_modules目录\n\n![Weex环境搭建 - 第5张  | 张嘎](https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-ef5d1f547e4d5e25.png?w=640)\n\n### weex-toolkit和weexpack的区别\n\nweex-toolkit 初始化的项目是针对开发单个 Weex 页面而设计的，也就是说这样的项目只包括单个页面开发需要的东西，比如前端页面源文件、webpack 配置、npm 脚本等。项目产生的输出就是一个 JS Bundle 文件，可以自由的进行部署。\nweex-pack 是初始化一个完整的 App 工程，包括 Android 和 iOS 的整个 App 起步，前端页面只是其中的一部分。这样的项目最终产出是一个 Android App 和一个 iOS App。\n\n## 五、创建.babelrc文件\n\n将ES6转成ES5代码执行\n\n```\n{ \"presets\": [\"es2015\"] }\n```\n\n## 六、发布安卓\n\n安装androidSDK，配置环境变量。\n\nnpm run build\n\nweex platform add android\n\nweex build android\n\n坑：\n","slug":"weex-dev0","published":1,"updated":"2021-08-25T12:46:06.288Z","_id":"cksrhe20i000lssmnbbxp7xir","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、安装node-js\"><a href=\"#一、安装node-js\" class=\"headerlink\" title=\"一、安装node.js\"></a>一、安装node.js</h2><p>点击链接 <a href=\"https://link.jianshu.com/?t=http://nodejs.cn/download/\">http://nodejs.cn/download/</a> 选择你需要安装的版本（windows ，mac，linux 3种系统的版本），下载你需要的版本</p>\n<p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-4c3b9f270d217291.png?w=640&ssl=1\" alt=\"Weex环境搭建 - 第1张  | 张嘎\"></p>\n<span id=\"more\"></span>\n\n<p>点击安装包，下一步，下一步，安装完成即可。<br>执行查看node版本号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n<p>显示当前node版本号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deiMac:~ li$ node -v</span><br><span class=\"line\">v8.1.0</span><br></pre></td></tr></table></figure>\n\n<p>查看npm配置信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config ls</span><br></pre></td></tr></table></figure>\n\n<p>2.修改路径</p>\n<p>这里需要修改两个路径，module路径和cache路径</p>\n<p>module对应prefix</p>\n<p>cache对应cache</p>\n<p>首先在别的盘新建两个目录</p>\n<p>D:\\nodejs\\node_global</p>\n<p>D:\\nodejs\\node_cache</p>\n<p>然后依次执行</p>\n<p>修改配置文件（userconfig C:\\Users\\zhangga.npmrc）中对应的路径</p>\n<p>或者命令行修改</p>\n<p>npm config set prefix”D:\\nodejs\\node_global”</p>\n<p>npm config set cache”D:\\nodejs\\node_cache”</p>\n<p>3.修改环境变量</p>\n<p>新增环境变量 NODE_HOME</p>\n<p><img src=\"https://blog.csdn.net/wkkyo/article/details/52799488\" alt=\"Weex环境搭建 - 第2张  | 张嘎\"></p>\n<p><img src=\"https://img-blog.csdn.net/20161013135353107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Weex环境搭建 - 第3张  | 张嘎\"></p>\n<p>修改Path，追加 %NODE_HOME%;%NODE_HOME%\\node_global;</p>\n<p>使用淘宝NPM源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、安装webpack\"><a href=\"#二、安装webpack\" class=\"headerlink\" title=\"二、安装webpack\"></a>二、安装webpack</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//全局安装</span><br><span class=\"line\">$ cnpm install -g webpack</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装到你的项目目录</span><br><span class=\"line\">$ cd 你的工程目录</span><br><span class=\"line\">$ cnpm install --save-dev webpack</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、安装serve\"><a href=\"#三、安装serve\" class=\"headerlink\" title=\"三、安装serve\"></a>三、安装serve</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//全局安装</span><br><span class=\"line\">$ cnpm install -g serve</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装到你的项目目录</span><br><span class=\"line\">$ cd 你的工程目录</span><br><span class=\"line\">$ cnpm install  serve</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、安装weexpack\"><a href=\"#四、安装weexpack\" class=\"headerlink\" title=\"四、安装weexpack\"></a>四、安装weexpack</h2><p>首先，全局安装 weex-pack 命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g weexpack</span><br></pre></td></tr></table></figure>\n\n<p>或者 在 clone 的 weexpack 根目录下执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>创建 weexpack 工程</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ weexpack create appName</span><br></pre></td></tr></table></figure>\n\n<p>使用WebStrom打开创建的工程目录如下</p>\n<p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/63643-9f0f43e765b4f787.png?w=640\" alt=\"Weex环境搭建 - 第4张  | 张嘎\"></p>\n<p>2.进入创建的工程目录，并且安装相关依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd appName &amp;&amp; cnpm install</span><br></pre></td></tr></table></figure>\n\n<p>安装完第三方依赖，工程目录添加了node_modules目录</p>\n<p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-ef5d1f547e4d5e25.png?w=640\" alt=\"Weex环境搭建 - 第5张  | 张嘎\"></p>\n<h3 id=\"weex-toolkit和weexpack的区别\"><a href=\"#weex-toolkit和weexpack的区别\" class=\"headerlink\" title=\"weex-toolkit和weexpack的区别\"></a>weex-toolkit和weexpack的区别</h3><p>weex-toolkit 初始化的项目是针对开发单个 Weex 页面而设计的，也就是说这样的项目只包括单个页面开发需要的东西，比如前端页面源文件、webpack 配置、npm 脚本等。项目产生的输出就是一个 JS Bundle 文件，可以自由的进行部署。<br>weex-pack 是初始化一个完整的 App 工程，包括 Android 和 iOS 的整个 App 起步，前端页面只是其中的一部分。这样的项目最终产出是一个 Android App 和一个 iOS App。</p>\n<h2 id=\"五、创建-babelrc文件\"><a href=\"#五、创建-babelrc文件\" class=\"headerlink\" title=\"五、创建.babelrc文件\"></a>五、创建.babelrc文件</h2><p>将ES6转成ES5代码执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;presets&quot;: [&quot;es2015&quot;] &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、发布安卓\"><a href=\"#六、发布安卓\" class=\"headerlink\" title=\"六、发布安卓\"></a>六、发布安卓</h2><p>安装androidSDK，配置环境变量。</p>\n<p>npm run build</p>\n<p>weex platform add android</p>\n<p>weex build android</p>\n<p>坑：</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、安装node-js\"><a href=\"#一、安装node-js\" class=\"headerlink\" title=\"一、安装node.js\"></a>一、安装node.js</h2><p>点击链接 <a href=\"https://link.jianshu.com/?t=http://nodejs.cn/download/\">http://nodejs.cn/download/</a> 选择你需要安装的版本（windows ，mac，linux 3种系统的版本），下载你需要的版本</p>\n<p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-4c3b9f270d217291.png?w=640&ssl=1\" alt=\"Weex环境搭建 - 第1张  | 张嘎\"></p>","more":"<p>点击安装包，下一步，下一步，安装完成即可。<br>执行查看node版本号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n<p>显示当前node版本号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deiMac:~ li$ node -v</span><br><span class=\"line\">v8.1.0</span><br></pre></td></tr></table></figure>\n\n<p>查看npm配置信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config ls</span><br></pre></td></tr></table></figure>\n\n<p>2.修改路径</p>\n<p>这里需要修改两个路径，module路径和cache路径</p>\n<p>module对应prefix</p>\n<p>cache对应cache</p>\n<p>首先在别的盘新建两个目录</p>\n<p>D:\\nodejs\\node_global</p>\n<p>D:\\nodejs\\node_cache</p>\n<p>然后依次执行</p>\n<p>修改配置文件（userconfig C:\\Users\\zhangga.npmrc）中对应的路径</p>\n<p>或者命令行修改</p>\n<p>npm config set prefix”D:\\nodejs\\node_global”</p>\n<p>npm config set cache”D:\\nodejs\\node_cache”</p>\n<p>3.修改环境变量</p>\n<p>新增环境变量 NODE_HOME</p>\n<p><img src=\"https://blog.csdn.net/wkkyo/article/details/52799488\" alt=\"Weex环境搭建 - 第2张  | 张嘎\"></p>\n<p><img src=\"https://img-blog.csdn.net/20161013135353107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Weex环境搭建 - 第3张  | 张嘎\"></p>\n<p>修改Path，追加 %NODE_HOME%;%NODE_HOME%\\node_global;</p>\n<p>使用淘宝NPM源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、安装webpack\"><a href=\"#二、安装webpack\" class=\"headerlink\" title=\"二、安装webpack\"></a>二、安装webpack</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//全局安装</span><br><span class=\"line\">$ cnpm install -g webpack</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装到你的项目目录</span><br><span class=\"line\">$ cd 你的工程目录</span><br><span class=\"line\">$ cnpm install --save-dev webpack</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、安装serve\"><a href=\"#三、安装serve\" class=\"headerlink\" title=\"三、安装serve\"></a>三、安装serve</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//全局安装</span><br><span class=\"line\">$ cnpm install -g serve</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装到你的项目目录</span><br><span class=\"line\">$ cd 你的工程目录</span><br><span class=\"line\">$ cnpm install  serve</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、安装weexpack\"><a href=\"#四、安装weexpack\" class=\"headerlink\" title=\"四、安装weexpack\"></a>四、安装weexpack</h2><p>首先，全局安装 weex-pack 命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g weexpack</span><br></pre></td></tr></table></figure>\n\n<p>或者 在 clone 的 weexpack 根目录下执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>创建 weexpack 工程</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ weexpack create appName</span><br></pre></td></tr></table></figure>\n\n<p>使用WebStrom打开创建的工程目录如下</p>\n<p><img src=\"https://i2.wp.com/upload-images.jianshu.io/upload_images/63643-9f0f43e765b4f787.png?w=640\" alt=\"Weex环境搭建 - 第4张  | 张嘎\"></p>\n<p>2.进入创建的工程目录，并且安装相关依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd appName &amp;&amp; cnpm install</span><br></pre></td></tr></table></figure>\n\n<p>安装完第三方依赖，工程目录添加了node_modules目录</p>\n<p><img src=\"https://i0.wp.com/upload-images.jianshu.io/upload_images/63643-ef5d1f547e4d5e25.png?w=640\" alt=\"Weex环境搭建 - 第5张  | 张嘎\"></p>\n<h3 id=\"weex-toolkit和weexpack的区别\"><a href=\"#weex-toolkit和weexpack的区别\" class=\"headerlink\" title=\"weex-toolkit和weexpack的区别\"></a>weex-toolkit和weexpack的区别</h3><p>weex-toolkit 初始化的项目是针对开发单个 Weex 页面而设计的，也就是说这样的项目只包括单个页面开发需要的东西，比如前端页面源文件、webpack 配置、npm 脚本等。项目产生的输出就是一个 JS Bundle 文件，可以自由的进行部署。<br>weex-pack 是初始化一个完整的 App 工程，包括 Android 和 iOS 的整个 App 起步，前端页面只是其中的一部分。这样的项目最终产出是一个 Android App 和一个 iOS App。</p>\n<h2 id=\"五、创建-babelrc文件\"><a href=\"#五、创建-babelrc文件\" class=\"headerlink\" title=\"五、创建.babelrc文件\"></a>五、创建.babelrc文件</h2><p>将ES6转成ES5代码执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &quot;presets&quot;: [&quot;es2015&quot;] &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、发布安卓\"><a href=\"#六、发布安卓\" class=\"headerlink\" title=\"六、发布安卓\"></a>六、发布安卓</h2><p>安装androidSDK，配置环境变量。</p>\n<p>npm run build</p>\n<p>weex platform add android</p>\n<p>weex build android</p>\n<p>坑：</p>"},{"title":"Weex开发","date":"2018-07-26T12:43:18.000Z","id":"weex-dev1","_content":"\n# Weex开发-0.打包\n\n# 参考文档：\n\nhttps://segmentfault.com/a/1190000008342533\n\n<!--more-->\n\nWeex工程：\n\nsrc/filters src/mixins\n\n安卓包：\n\nres/mipmap/ic_launcher.png为icon图标\n\nres/values/strings/下 一个英文strings的配置，一个中文的配置。 app_name修改APP名字\n\n打包安卓和iOS都需要运行weex工程下package.json里的copy脚本拷贝下资源文件。\n\n# Weex开发-1.文件目录结构\n\n# 一、eslint\n\n.eslintignore忽略文件目录\n\n.eslintrc.js\n\n","source":"_posts/weex-dev1.md","raw":"---\ntitle: Weex开发\ndate: 2018-07-26 20:43:18\ntags:\n  - 笔记\nid: weex-dev1\ncategories:\n  - 笔记\n---\n\n# Weex开发-0.打包\n\n# 参考文档：\n\nhttps://segmentfault.com/a/1190000008342533\n\n<!--more-->\n\nWeex工程：\n\nsrc/filters src/mixins\n\n安卓包：\n\nres/mipmap/ic_launcher.png为icon图标\n\nres/values/strings/下 一个英文strings的配置，一个中文的配置。 app_name修改APP名字\n\n打包安卓和iOS都需要运行weex工程下package.json里的copy脚本拷贝下资源文件。\n\n# Weex开发-1.文件目录结构\n\n# 一、eslint\n\n.eslintignore忽略文件目录\n\n.eslintrc.js\n\n","slug":"weex-dev1","published":1,"updated":"2021-08-25T12:45:11.222Z","_id":"cksrhmyab000ossmn6xap1wab","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Weex开发-0-打包\"><a href=\"#Weex开发-0-打包\" class=\"headerlink\" title=\"Weex开发-0.打包\"></a>Weex开发-0.打包</h1><h1 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h1><p><a href=\"https://segmentfault.com/a/1190000008342533\">https://segmentfault.com/a/1190000008342533</a></p>\n<span id=\"more\"></span>\n\n<p>Weex工程：</p>\n<p>src/filters src/mixins</p>\n<p>安卓包：</p>\n<p>res/mipmap/ic_launcher.png为icon图标</p>\n<p>res/values/strings/下 一个英文strings的配置，一个中文的配置。 app_name修改APP名字</p>\n<p>打包安卓和iOS都需要运行weex工程下package.json里的copy脚本拷贝下资源文件。</p>\n<h1 id=\"Weex开发-1-文件目录结构\"><a href=\"#Weex开发-1-文件目录结构\" class=\"headerlink\" title=\"Weex开发-1.文件目录结构\"></a>Weex开发-1.文件目录结构</h1><h1 id=\"一、eslint\"><a href=\"#一、eslint\" class=\"headerlink\" title=\"一、eslint\"></a>一、eslint</h1><p>.eslintignore忽略文件目录</p>\n<p>.eslintrc.js</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Weex开发-0-打包\"><a href=\"#Weex开发-0-打包\" class=\"headerlink\" title=\"Weex开发-0.打包\"></a>Weex开发-0.打包</h1><h1 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h1><p><a href=\"https://segmentfault.com/a/1190000008342533\">https://segmentfault.com/a/1190000008342533</a></p>","more":"<p>Weex工程：</p>\n<p>src/filters src/mixins</p>\n<p>安卓包：</p>\n<p>res/mipmap/ic_launcher.png为icon图标</p>\n<p>res/values/strings/下 一个英文strings的配置，一个中文的配置。 app_name修改APP名字</p>\n<p>打包安卓和iOS都需要运行weex工程下package.json里的copy脚本拷贝下资源文件。</p>\n<h1 id=\"Weex开发-1-文件目录结构\"><a href=\"#Weex开发-1-文件目录结构\" class=\"headerlink\" title=\"Weex开发-1.文件目录结构\"></a>Weex开发-1.文件目录结构</h1><h1 id=\"一、eslint\"><a href=\"#一、eslint\" class=\"headerlink\" title=\"一、eslint\"></a>一、eslint</h1><p>.eslintignore忽略文件目录</p>\n<p>.eslintrc.js</p>"},{"title":"阿里云转战腾讯云-全纪录","date":"2018-10-01T04:06:11.000Z","id":"ali2tx","_content":"\n# 机器迁移全记录。\n\n[![hMnUVP.md.png](https://z3.ax1x.com/2021/08/27/hMnUVP.md.png)](https://imgtu.com/i/hMnUVP)\n\n<!--more-->\n\n### 1.JDK\n\n/usr/local/java/下，放jdk11和jdk1.8。default软连接到jdk11。\n\n/etc/profile 文件加入环境变量指向default。执行source /etc/profile\n\n### 2.maven\n\n/usr/local/mvn/下，放maven解压包，加入环境变量。\n\n### 3.cmake\n\n/opt下放cmake的解压包，加入环境变量。\n\n### 4.xampp\n\n/opt下放xampp的安装文件，xampp-xxx.run文件。\n\nchmod -R 755 xampp-linux-xxx-installer.run 添加执行权限。\n\n./xampp-linux-xxx-installer.run 执行安装。\n\n安装的过程就不多说了，也不用设置什么，无非就是问你时候确定一些选项，出现提问，直接按 回车 下去即可。xampp默认安装在/opt/lampp下\n\n安装完毕之后，并没有运行，我们需要手动启动xampp服务，也就是启动apache，ftp和mysql这些服务器。使用命令\n\n/opt/lampp/lampp start\n\n此时，lampp组件就成功启动了，但它并不是每次随系统启动\n输入以下命令\nln -s /opt/lampp/lampp /etc/rc.d/rc3.d/S99lampp\nln -s /opt/lampp/lampp /etc/rc.d/rc4.d/S99lampp\nln -s /opt/lampp/lampp /etc/rc.d/rc5.d/S99lampp\n\n这样，就随系统启动了！\n\n环境安装完了，但是MySQL的密码是多少，ftp的账号密码也是多少？我们不知道，这个默认为空，还需要我们自己设置。【要先在文本上面写好先在复制安全点，不然密码设置成什么自己都不记得了】输入命令\n\nsudo /opt/lampp/lampp security\n\n如图所示:他会依次要求你\n\n1、先输入xampp控制面板的密码（用户名是xampp）；\n\n2、输入phpmyadmin的密码（用户名是pma）\n\n3、输入mysql的密码（用户名是root）\n\n4、输入ftp密码（用户名是daemon，默认端口21）\n\n9、在浏览器输入服务器的ip访问看一下成功了没有？\n\n由于服务器设置了xampp不允许远程访问，所以远程不能访问需要修改conf文件\n\nvi /opt/lampp/etc/extra/httpd-xampp.conf\n\n将  Require local 改成 Require all granted\n\n/opt/lampp/lampp restart 重启xampp\n\n到此xampp安装完成\n\nmysql指令无法执行，简单的方法是可以直接将/opt/lampp/bin/目录添加到环境变量中，这样就可以直接使用mysql和mysqldump命令了。\n\n打开 ~/.bashrc 文件\n在最后一行加入\n\\# PATH\nexport PATH=/opt/lampp/bin:$PATH\n保存退出执行该文件中的命令\nsource ~/.bashrc\n\n修改/opt/lampp/etc/my.cnf 配置文件，开放3306端口。可能需要重启服务器，注意查看下mysql是否启动在33066端口上。\n\n### 4.迁移wordpress。\n\n### 5.redis迁移。\n\n### 6.server和htdocs迁移。\n\n## 7.maven私有仓库和SVN。\n\n8.nginx安装https://www.cnblogs.com/wyd168/p/6636529.html\n","source":"_posts/ali2tx.md","raw":"---\ntitle: 阿里云转战腾讯云-全纪录\ndate: 2018-10-01 12:06:11\ntags:\n  - 笔记\nid: ali2tx\ncategories:\n  - 笔记\n---\n\n# 机器迁移全记录。\n\n[![hMnUVP.md.png](https://z3.ax1x.com/2021/08/27/hMnUVP.md.png)](https://imgtu.com/i/hMnUVP)\n\n<!--more-->\n\n### 1.JDK\n\n/usr/local/java/下，放jdk11和jdk1.8。default软连接到jdk11。\n\n/etc/profile 文件加入环境变量指向default。执行source /etc/profile\n\n### 2.maven\n\n/usr/local/mvn/下，放maven解压包，加入环境变量。\n\n### 3.cmake\n\n/opt下放cmake的解压包，加入环境变量。\n\n### 4.xampp\n\n/opt下放xampp的安装文件，xampp-xxx.run文件。\n\nchmod -R 755 xampp-linux-xxx-installer.run 添加执行权限。\n\n./xampp-linux-xxx-installer.run 执行安装。\n\n安装的过程就不多说了，也不用设置什么，无非就是问你时候确定一些选项，出现提问，直接按 回车 下去即可。xampp默认安装在/opt/lampp下\n\n安装完毕之后，并没有运行，我们需要手动启动xampp服务，也就是启动apache，ftp和mysql这些服务器。使用命令\n\n/opt/lampp/lampp start\n\n此时，lampp组件就成功启动了，但它并不是每次随系统启动\n输入以下命令\nln -s /opt/lampp/lampp /etc/rc.d/rc3.d/S99lampp\nln -s /opt/lampp/lampp /etc/rc.d/rc4.d/S99lampp\nln -s /opt/lampp/lampp /etc/rc.d/rc5.d/S99lampp\n\n这样，就随系统启动了！\n\n环境安装完了，但是MySQL的密码是多少，ftp的账号密码也是多少？我们不知道，这个默认为空，还需要我们自己设置。【要先在文本上面写好先在复制安全点，不然密码设置成什么自己都不记得了】输入命令\n\nsudo /opt/lampp/lampp security\n\n如图所示:他会依次要求你\n\n1、先输入xampp控制面板的密码（用户名是xampp）；\n\n2、输入phpmyadmin的密码（用户名是pma）\n\n3、输入mysql的密码（用户名是root）\n\n4、输入ftp密码（用户名是daemon，默认端口21）\n\n9、在浏览器输入服务器的ip访问看一下成功了没有？\n\n由于服务器设置了xampp不允许远程访问，所以远程不能访问需要修改conf文件\n\nvi /opt/lampp/etc/extra/httpd-xampp.conf\n\n将  Require local 改成 Require all granted\n\n/opt/lampp/lampp restart 重启xampp\n\n到此xampp安装完成\n\nmysql指令无法执行，简单的方法是可以直接将/opt/lampp/bin/目录添加到环境变量中，这样就可以直接使用mysql和mysqldump命令了。\n\n打开 ~/.bashrc 文件\n在最后一行加入\n\\# PATH\nexport PATH=/opt/lampp/bin:$PATH\n保存退出执行该文件中的命令\nsource ~/.bashrc\n\n修改/opt/lampp/etc/my.cnf 配置文件，开放3306端口。可能需要重启服务器，注意查看下mysql是否启动在33066端口上。\n\n### 4.迁移wordpress。\n\n### 5.redis迁移。\n\n### 6.server和htdocs迁移。\n\n## 7.maven私有仓库和SVN。\n\n8.nginx安装https://www.cnblogs.com/wyd168/p/6636529.html\n","slug":"ali2tx","published":1,"updated":"2021-08-27T04:07:39.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lje0000hcmn80ozcxl4","content":"<h1 id=\"机器迁移全记录。\"><a href=\"#机器迁移全记录。\" class=\"headerlink\" title=\"机器迁移全记录。\"></a>机器迁移全记录。</h1><p><a href=\"https://imgtu.com/i/hMnUVP\"><img src=\"https://z3.ax1x.com/2021/08/27/hMnUVP.md.png\" alt=\"hMnUVP.md.png\"></a></p>\n<span id=\"more\"></span>\n\n<h3 id=\"1-JDK\"><a href=\"#1-JDK\" class=\"headerlink\" title=\"1.JDK\"></a>1.JDK</h3><p>/usr/local/java/下，放jdk11和jdk1.8。default软连接到jdk11。</p>\n<p>/etc/profile 文件加入环境变量指向default。执行source /etc/profile</p>\n<h3 id=\"2-maven\"><a href=\"#2-maven\" class=\"headerlink\" title=\"2.maven\"></a>2.maven</h3><p>/usr/local/mvn/下，放maven解压包，加入环境变量。</p>\n<h3 id=\"3-cmake\"><a href=\"#3-cmake\" class=\"headerlink\" title=\"3.cmake\"></a>3.cmake</h3><p>/opt下放cmake的解压包，加入环境变量。</p>\n<h3 id=\"4-xampp\"><a href=\"#4-xampp\" class=\"headerlink\" title=\"4.xampp\"></a>4.xampp</h3><p>/opt下放xampp的安装文件，xampp-xxx.run文件。</p>\n<p>chmod -R 755 xampp-linux-xxx-installer.run 添加执行权限。</p>\n<p>./xampp-linux-xxx-installer.run 执行安装。</p>\n<p>安装的过程就不多说了，也不用设置什么，无非就是问你时候确定一些选项，出现提问，直接按 回车 下去即可。xampp默认安装在/opt/lampp下</p>\n<p>安装完毕之后，并没有运行，我们需要手动启动xampp服务，也就是启动apache，ftp和mysql这些服务器。使用命令</p>\n<p>/opt/lampp/lampp start</p>\n<p>此时，lampp组件就成功启动了，但它并不是每次随系统启动<br>输入以下命令<br>ln -s /opt/lampp/lampp /etc/rc.d/rc3.d/S99lampp<br>ln -s /opt/lampp/lampp /etc/rc.d/rc4.d/S99lampp<br>ln -s /opt/lampp/lampp /etc/rc.d/rc5.d/S99lampp</p>\n<p>这样，就随系统启动了！</p>\n<p>环境安装完了，但是MySQL的密码是多少，ftp的账号密码也是多少？我们不知道，这个默认为空，还需要我们自己设置。【要先在文本上面写好先在复制安全点，不然密码设置成什么自己都不记得了】输入命令</p>\n<p>sudo /opt/lampp/lampp security</p>\n<p>如图所示:他会依次要求你</p>\n<p>1、先输入xampp控制面板的密码（用户名是xampp）；</p>\n<p>2、输入phpmyadmin的密码（用户名是pma）</p>\n<p>3、输入mysql的密码（用户名是root）</p>\n<p>4、输入ftp密码（用户名是daemon，默认端口21）</p>\n<p>9、在浏览器输入服务器的ip访问看一下成功了没有？</p>\n<p>由于服务器设置了xampp不允许远程访问，所以远程不能访问需要修改conf文件</p>\n<p>vi /opt/lampp/etc/extra/httpd-xampp.conf</p>\n<p>将  Require local 改成 Require all granted</p>\n<p>/opt/lampp/lampp restart 重启xampp</p>\n<p>到此xampp安装完成</p>\n<p>mysql指令无法执行，简单的方法是可以直接将/opt/lampp/bin/目录添加到环境变量中，这样就可以直接使用mysql和mysqldump命令了。</p>\n<p>打开 ~/.bashrc 文件<br>在最后一行加入<br># PATH<br>export PATH=/opt/lampp/bin:$PATH<br>保存退出执行该文件中的命令<br>source ~/.bashrc</p>\n<p>修改/opt/lampp/etc/my.cnf 配置文件，开放3306端口。可能需要重启服务器，注意查看下mysql是否启动在33066端口上。</p>\n<h3 id=\"4-迁移wordpress。\"><a href=\"#4-迁移wordpress。\" class=\"headerlink\" title=\"4.迁移wordpress。\"></a>4.迁移wordpress。</h3><h3 id=\"5-redis迁移。\"><a href=\"#5-redis迁移。\" class=\"headerlink\" title=\"5.redis迁移。\"></a>5.redis迁移。</h3><h3 id=\"6-server和htdocs迁移。\"><a href=\"#6-server和htdocs迁移。\" class=\"headerlink\" title=\"6.server和htdocs迁移。\"></a>6.server和htdocs迁移。</h3><h2 id=\"7-maven私有仓库和SVN。\"><a href=\"#7-maven私有仓库和SVN。\" class=\"headerlink\" title=\"7.maven私有仓库和SVN。\"></a>7.maven私有仓库和SVN。</h2><p>8.nginx安装<a href=\"https://www.cnblogs.com/wyd168/p/6636529.html\">https://www.cnblogs.com/wyd168/p/6636529.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"机器迁移全记录。\"><a href=\"#机器迁移全记录。\" class=\"headerlink\" title=\"机器迁移全记录。\"></a>机器迁移全记录。</h1><p><a href=\"https://imgtu.com/i/hMnUVP\"><img src=\"https://z3.ax1x.com/2021/08/27/hMnUVP.md.png\" alt=\"hMnUVP.md.png\"></a></p>","more":"<h3 id=\"1-JDK\"><a href=\"#1-JDK\" class=\"headerlink\" title=\"1.JDK\"></a>1.JDK</h3><p>/usr/local/java/下，放jdk11和jdk1.8。default软连接到jdk11。</p>\n<p>/etc/profile 文件加入环境变量指向default。执行source /etc/profile</p>\n<h3 id=\"2-maven\"><a href=\"#2-maven\" class=\"headerlink\" title=\"2.maven\"></a>2.maven</h3><p>/usr/local/mvn/下，放maven解压包，加入环境变量。</p>\n<h3 id=\"3-cmake\"><a href=\"#3-cmake\" class=\"headerlink\" title=\"3.cmake\"></a>3.cmake</h3><p>/opt下放cmake的解压包，加入环境变量。</p>\n<h3 id=\"4-xampp\"><a href=\"#4-xampp\" class=\"headerlink\" title=\"4.xampp\"></a>4.xampp</h3><p>/opt下放xampp的安装文件，xampp-xxx.run文件。</p>\n<p>chmod -R 755 xampp-linux-xxx-installer.run 添加执行权限。</p>\n<p>./xampp-linux-xxx-installer.run 执行安装。</p>\n<p>安装的过程就不多说了，也不用设置什么，无非就是问你时候确定一些选项，出现提问，直接按 回车 下去即可。xampp默认安装在/opt/lampp下</p>\n<p>安装完毕之后，并没有运行，我们需要手动启动xampp服务，也就是启动apache，ftp和mysql这些服务器。使用命令</p>\n<p>/opt/lampp/lampp start</p>\n<p>此时，lampp组件就成功启动了，但它并不是每次随系统启动<br>输入以下命令<br>ln -s /opt/lampp/lampp /etc/rc.d/rc3.d/S99lampp<br>ln -s /opt/lampp/lampp /etc/rc.d/rc4.d/S99lampp<br>ln -s /opt/lampp/lampp /etc/rc.d/rc5.d/S99lampp</p>\n<p>这样，就随系统启动了！</p>\n<p>环境安装完了，但是MySQL的密码是多少，ftp的账号密码也是多少？我们不知道，这个默认为空，还需要我们自己设置。【要先在文本上面写好先在复制安全点，不然密码设置成什么自己都不记得了】输入命令</p>\n<p>sudo /opt/lampp/lampp security</p>\n<p>如图所示:他会依次要求你</p>\n<p>1、先输入xampp控制面板的密码（用户名是xampp）；</p>\n<p>2、输入phpmyadmin的密码（用户名是pma）</p>\n<p>3、输入mysql的密码（用户名是root）</p>\n<p>4、输入ftp密码（用户名是daemon，默认端口21）</p>\n<p>9、在浏览器输入服务器的ip访问看一下成功了没有？</p>\n<p>由于服务器设置了xampp不允许远程访问，所以远程不能访问需要修改conf文件</p>\n<p>vi /opt/lampp/etc/extra/httpd-xampp.conf</p>\n<p>将  Require local 改成 Require all granted</p>\n<p>/opt/lampp/lampp restart 重启xampp</p>\n<p>到此xampp安装完成</p>\n<p>mysql指令无法执行，简单的方法是可以直接将/opt/lampp/bin/目录添加到环境变量中，这样就可以直接使用mysql和mysqldump命令了。</p>\n<p>打开 ~/.bashrc 文件<br>在最后一行加入<br># PATH<br>export PATH=/opt/lampp/bin:$PATH<br>保存退出执行该文件中的命令<br>source ~/.bashrc</p>\n<p>修改/opt/lampp/etc/my.cnf 配置文件，开放3306端口。可能需要重启服务器，注意查看下mysql是否启动在33066端口上。</p>\n<h3 id=\"4-迁移wordpress。\"><a href=\"#4-迁移wordpress。\" class=\"headerlink\" title=\"4.迁移wordpress。\"></a>4.迁移wordpress。</h3><h3 id=\"5-redis迁移。\"><a href=\"#5-redis迁移。\" class=\"headerlink\" title=\"5.redis迁移。\"></a>5.redis迁移。</h3><h3 id=\"6-server和htdocs迁移。\"><a href=\"#6-server和htdocs迁移。\" class=\"headerlink\" title=\"6.server和htdocs迁移。\"></a>6.server和htdocs迁移。</h3><h2 id=\"7-maven私有仓库和SVN。\"><a href=\"#7-maven私有仓库和SVN。\" class=\"headerlink\" title=\"7.maven私有仓库和SVN。\"></a>7.maven私有仓库和SVN。</h2><p>8.nginx安装<a href=\"https://www.cnblogs.com/wyd168/p/6636529.html\">https://www.cnblogs.com/wyd168/p/6636529.html</a></p>"},{"title":"cloud-restart","date":"2019-03-13T11:50:13.000Z","id":"cloud-restart","_content":"\n今天遇到腾讯云服务器控制台连上就断开的问题。和腾讯云沟通后反馈可能是由于cpu长时间负载过高引起的。\n\n![云服务器重启时需要启动的服务 - 第1张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/5-2.png?resize=640%2C111)\n\n登陆服务器后查看状态，发现进程：dblaunch的cpu负载高达200%。最后定位问题发生在lampp配置和权限的问题。注释掉下面这两行重启即可。\n\n![云服务器重启时需要启动的服务 - 第2张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/51.png?resize=640%2C388)\n\n## 正好记录下重启服务器时需要启动的服务，以免遗漏。\n\n1.lampp\n\n2.redis\n\n3./usr/local/server下需要启动的服务\n\n4.maven仓库\n","source":"_posts/cloud-restart.md","raw":"---\ntitle: cloud-restart\ndate: 2019-03-13 19:50:13\ntags:\n  - 笔记\nid: cloud-restart\ncategories:\n  - 笔记\n---\n\n今天遇到腾讯云服务器控制台连上就断开的问题。和腾讯云沟通后反馈可能是由于cpu长时间负载过高引起的。\n\n![云服务器重启时需要启动的服务 - 第1张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/5-2.png?resize=640%2C111)\n\n登陆服务器后查看状态，发现进程：dblaunch的cpu负载高达200%。最后定位问题发生在lampp配置和权限的问题。注释掉下面这两行重启即可。\n\n![云服务器重启时需要启动的服务 - 第2张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/51.png?resize=640%2C388)\n\n## 正好记录下重启服务器时需要启动的服务，以免遗漏。\n\n1.lampp\n\n2.redis\n\n3./usr/local/server下需要启动的服务\n\n4.maven仓库\n","slug":"cloud-restart","published":1,"updated":"2021-09-01T11:50:41.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lji0001hcmn9qlr0xeo","content":"<p>今天遇到腾讯云服务器控制台连上就断开的问题。和腾讯云沟通后反馈可能是由于cpu长时间负载过高引起的。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/5-2.png?resize=640,111\" alt=\"云服务器重启时需要启动的服务 - 第1张  | 张嘎\"></p>\n<p>登陆服务器后查看状态，发现进程：dblaunch的cpu负载高达200%。最后定位问题发生在lampp配置和权限的问题。注释掉下面这两行重启即可。</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/51.png?resize=640,388\" alt=\"云服务器重启时需要启动的服务 - 第2张  | 张嘎\"></p>\n<h2 id=\"正好记录下重启服务器时需要启动的服务，以免遗漏。\"><a href=\"#正好记录下重启服务器时需要启动的服务，以免遗漏。\" class=\"headerlink\" title=\"正好记录下重启服务器时需要启动的服务，以免遗漏。\"></a>正好记录下重启服务器时需要启动的服务，以免遗漏。</h2><p>1.lampp</p>\n<p>2.redis</p>\n<p>3./usr/local/server下需要启动的服务</p>\n<p>4.maven仓库</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天遇到腾讯云服务器控制台连上就断开的问题。和腾讯云沟通后反馈可能是由于cpu长时间负载过高引起的。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/5-2.png?resize=640,111\" alt=\"云服务器重启时需要启动的服务 - 第1张  | 张嘎\"></p>\n<p>登陆服务器后查看状态，发现进程：dblaunch的cpu负载高达200%。最后定位问题发生在lampp配置和权限的问题。注释掉下面这两行重启即可。</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/51.png?resize=640,388\" alt=\"云服务器重启时需要启动的服务 - 第2张  | 张嘎\"></p>\n<h2 id=\"正好记录下重启服务器时需要启动的服务，以免遗漏。\"><a href=\"#正好记录下重启服务器时需要启动的服务，以免遗漏。\" class=\"headerlink\" title=\"正好记录下重启服务器时需要启动的服务，以免遗漏。\"></a>正好记录下重启服务器时需要启动的服务，以免遗漏。</h2><p>1.lampp</p>\n<p>2.redis</p>\n<p>3./usr/local/server下需要启动的服务</p>\n<p>4.maven仓库</p>\n"},{"title":"云服务器被挖矿病毒感染！","date":"2019-03-26T11:51:40.000Z","id":"cloud-ver","_content":"\n#### **记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。**\n\n一、3月13号发现服务器ssh连接困难，连上就掉线，根本无法操作，用top指令查看发现有进程名为：dblaunch高负载，占满cpu。没多想，联系腾讯云处理，最后给出的建议：做好快照，重启机器。腾讯帮忙注释掉了启动脚本中lampp中mysql的bin环境变量，现在来看，这个操作没任务作用。重启完后机器恢复正常，也就没再进一步追踪。\n\n![云服务器被挖矿病毒感染！ - 第1张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1-3.png?resize=640%2C111)\n\n二、3月15号，公司下周去美国，需要搭建对外服务器在美国登陆，就部署到我的腾讯云服务器，由于我明天去日本的飞机，赶忙晚上部署服务器完毕，测试无恙，一切正常。\n\n三、3月16号，在日本凌晨3点钟， 同事反应游戏服务器连不上，登陆ssh后台发现根本连不上， 再次联系腾讯云，最后还是强制重启解决，噩梦开始，由于人在日本，只能通过手机操作，没有别的办法，只能每天早上起床后第一件事就是重启机器，以保障美国方能正常展示游戏。\n\n![云服务器被挖矿病毒感染！ - 第2张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2-2.png?resize=640%2C436)\n\n四、回国后开始排查问题，发现进程sustse跑满cpu，网上查看后才知道是被挖矿病毒感染，第一次服务器被病毒感染的经历。随后开始了各种尝试，试图删尽病毒，病毒的urlget地址为：http://107.174.47.156/mr.sh。在经过了各种对文件夹加权限，删除病毒文件及各种定时任务后，最后发现还是徒劳，不知道从什么地方病毒还是再次出现，腾讯官方给出的建议也是重装系统，因为你永远也保证不了病毒被删除干净，在这样的机器上继续使用的话，自己的内容越多，文件丢失的成本和风险越大，最后只能重装系统，重新部署环境。\n\n五、经此一役和挖矿病毒的斗争，或者说被虐也好，教训就是，做好服务器的快照备份，数据无价，万一真的丢失了恢复不了，那是真崩了。还好这次没什么重大损失。\n","source":"_posts/cloud-ver.md","raw":"---\ntitle: 云服务器被挖矿病毒感染！\ndate: 2019-03-26 19:51:40\ntags:\n  - 笔记\nid: cloud-ver\ncategories:\n  - 笔记\n---\n\n#### **记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。**\n\n一、3月13号发现服务器ssh连接困难，连上就掉线，根本无法操作，用top指令查看发现有进程名为：dblaunch高负载，占满cpu。没多想，联系腾讯云处理，最后给出的建议：做好快照，重启机器。腾讯帮忙注释掉了启动脚本中lampp中mysql的bin环境变量，现在来看，这个操作没任务作用。重启完后机器恢复正常，也就没再进一步追踪。\n\n![云服务器被挖矿病毒感染！ - 第1张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1-3.png?resize=640%2C111)\n\n二、3月15号，公司下周去美国，需要搭建对外服务器在美国登陆，就部署到我的腾讯云服务器，由于我明天去日本的飞机，赶忙晚上部署服务器完毕，测试无恙，一切正常。\n\n三、3月16号，在日本凌晨3点钟， 同事反应游戏服务器连不上，登陆ssh后台发现根本连不上， 再次联系腾讯云，最后还是强制重启解决，噩梦开始，由于人在日本，只能通过手机操作，没有别的办法，只能每天早上起床后第一件事就是重启机器，以保障美国方能正常展示游戏。\n\n![云服务器被挖矿病毒感染！ - 第2张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2-2.png?resize=640%2C436)\n\n四、回国后开始排查问题，发现进程sustse跑满cpu，网上查看后才知道是被挖矿病毒感染，第一次服务器被病毒感染的经历。随后开始了各种尝试，试图删尽病毒，病毒的urlget地址为：http://107.174.47.156/mr.sh。在经过了各种对文件夹加权限，删除病毒文件及各种定时任务后，最后发现还是徒劳，不知道从什么地方病毒还是再次出现，腾讯官方给出的建议也是重装系统，因为你永远也保证不了病毒被删除干净，在这样的机器上继续使用的话，自己的内容越多，文件丢失的成本和风险越大，最后只能重装系统，重新部署环境。\n\n五、经此一役和挖矿病毒的斗争，或者说被虐也好，教训就是，做好服务器的快照备份，数据无价，万一真的丢失了恢复不了，那是真崩了。还好这次没什么重大损失。\n","slug":"cloud-ver","published":1,"updated":"2021-09-01T11:52:17.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljj0003hcmn6pbe3qou","content":"<h4 id=\"记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。\"><a href=\"#记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。\" class=\"headerlink\" title=\"记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。\"></a><strong>记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。</strong></h4><p>一、3月13号发现服务器ssh连接困难，连上就掉线，根本无法操作，用top指令查看发现有进程名为：dblaunch高负载，占满cpu。没多想，联系腾讯云处理，最后给出的建议：做好快照，重启机器。腾讯帮忙注释掉了启动脚本中lampp中mysql的bin环境变量，现在来看，这个操作没任务作用。重启完后机器恢复正常，也就没再进一步追踪。</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1-3.png?resize=640,111\" alt=\"云服务器被挖矿病毒感染！ - 第1张  | 张嘎\"></p>\n<p>二、3月15号，公司下周去美国，需要搭建对外服务器在美国登陆，就部署到我的腾讯云服务器，由于我明天去日本的飞机，赶忙晚上部署服务器完毕，测试无恙，一切正常。</p>\n<p>三、3月16号，在日本凌晨3点钟， 同事反应游戏服务器连不上，登陆ssh后台发现根本连不上， 再次联系腾讯云，最后还是强制重启解决，噩梦开始，由于人在日本，只能通过手机操作，没有别的办法，只能每天早上起床后第一件事就是重启机器，以保障美国方能正常展示游戏。</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2-2.png?resize=640,436\" alt=\"云服务器被挖矿病毒感染！ - 第2张  | 张嘎\"></p>\n<p>四、回国后开始排查问题，发现进程sustse跑满cpu，网上查看后才知道是被挖矿病毒感染，第一次服务器被病毒感染的经历。随后开始了各种尝试，试图删尽病毒，病毒的urlget地址为：<a href=\"http://107.174.47.156/mr.sh%E3%80%82%E5%9C%A8%E7%BB%8F%E8%BF%87%E4%BA%86%E5%90%84%E7%A7%8D%E5%AF%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8A%A0%E6%9D%83%E9%99%90%EF%BC%8C%E5%88%A0%E9%99%A4%E7%97%85%E6%AF%92%E6%96%87%E4%BB%B6%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%90%8E%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%91%E7%8E%B0%E8%BF%98%E6%98%AF%E5%BE%92%E5%8A%B3%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E4%BB%8E%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E7%97%85%E6%AF%92%E8%BF%98%E6%98%AF%E5%86%8D%E6%AC%A1%E5%87%BA%E7%8E%B0%EF%BC%8C%E8%85%BE%E8%AE%AF%E5%AE%98%E6%96%B9%E7%BB%99%E5%87%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E4%B9%9F%E6%98%AF%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E6%B0%B8%E8%BF%9C%E4%B9%9F%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BA%86%E7%97%85%E6%AF%92%E8%A2%AB%E5%88%A0%E9%99%A4%E5%B9%B2%E5%87%80%EF%BC%8C%E5%9C%A8%E8%BF%99%E6%A0%B7%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AE%B9%E8%B6%8A%E5%A4%9A%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%88%90%E6%9C%AC%E5%92%8C%E9%A3%8E%E9%99%A9%E8%B6%8A%E5%A4%A7%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%AA%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E3%80%82\">http://107.174.47.156/mr.sh。在经过了各种对文件夹加权限，删除病毒文件及各种定时任务后，最后发现还是徒劳，不知道从什么地方病毒还是再次出现，腾讯官方给出的建议也是重装系统，因为你永远也保证不了病毒被删除干净，在这样的机器上继续使用的话，自己的内容越多，文件丢失的成本和风险越大，最后只能重装系统，重新部署环境。</a></p>\n<p>五、经此一役和挖矿病毒的斗争，或者说被虐也好，教训就是，做好服务器的快照备份，数据无价，万一真的丢失了恢复不了，那是真崩了。还好这次没什么重大损失。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。\"><a href=\"#记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。\" class=\"headerlink\" title=\"记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。\"></a><strong>记录下病毒感染的始末。从发现到折磨，再到最后解决的痛苦过程。总结教训，不能大意，还是得做好快照备份。</strong></h4><p>一、3月13号发现服务器ssh连接困难，连上就掉线，根本无法操作，用top指令查看发现有进程名为：dblaunch高负载，占满cpu。没多想，联系腾讯云处理，最后给出的建议：做好快照，重启机器。腾讯帮忙注释掉了启动脚本中lampp中mysql的bin环境变量，现在来看，这个操作没任务作用。重启完后机器恢复正常，也就没再进一步追踪。</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1-3.png?resize=640,111\" alt=\"云服务器被挖矿病毒感染！ - 第1张  | 张嘎\"></p>\n<p>二、3月15号，公司下周去美国，需要搭建对外服务器在美国登陆，就部署到我的腾讯云服务器，由于我明天去日本的飞机，赶忙晚上部署服务器完毕，测试无恙，一切正常。</p>\n<p>三、3月16号，在日本凌晨3点钟， 同事反应游戏服务器连不上，登陆ssh后台发现根本连不上， 再次联系腾讯云，最后还是强制重启解决，噩梦开始，由于人在日本，只能通过手机操作，没有别的办法，只能每天早上起床后第一件事就是重启机器，以保障美国方能正常展示游戏。</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2-2.png?resize=640,436\" alt=\"云服务器被挖矿病毒感染！ - 第2张  | 张嘎\"></p>\n<p>四、回国后开始排查问题，发现进程sustse跑满cpu，网上查看后才知道是被挖矿病毒感染，第一次服务器被病毒感染的经历。随后开始了各种尝试，试图删尽病毒，病毒的urlget地址为：<a href=\"http://107.174.47.156/mr.sh%E3%80%82%E5%9C%A8%E7%BB%8F%E8%BF%87%E4%BA%86%E5%90%84%E7%A7%8D%E5%AF%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8A%A0%E6%9D%83%E9%99%90%EF%BC%8C%E5%88%A0%E9%99%A4%E7%97%85%E6%AF%92%E6%96%87%E4%BB%B6%E5%8F%8A%E5%90%84%E7%A7%8D%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%90%8E%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%91%E7%8E%B0%E8%BF%98%E6%98%AF%E5%BE%92%E5%8A%B3%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E4%BB%8E%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E7%97%85%E6%AF%92%E8%BF%98%E6%98%AF%E5%86%8D%E6%AC%A1%E5%87%BA%E7%8E%B0%EF%BC%8C%E8%85%BE%E8%AE%AF%E5%AE%98%E6%96%B9%E7%BB%99%E5%87%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E4%B9%9F%E6%98%AF%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E6%B0%B8%E8%BF%9C%E4%B9%9F%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BA%86%E7%97%85%E6%AF%92%E8%A2%AB%E5%88%A0%E9%99%A4%E5%B9%B2%E5%87%80%EF%BC%8C%E5%9C%A8%E8%BF%99%E6%A0%B7%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AE%B9%E8%B6%8A%E5%A4%9A%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%88%90%E6%9C%AC%E5%92%8C%E9%A3%8E%E9%99%A9%E8%B6%8A%E5%A4%A7%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%AA%E8%83%BD%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E3%80%82\">http://107.174.47.156/mr.sh。在经过了各种对文件夹加权限，删除病毒文件及各种定时任务后，最后发现还是徒劳，不知道从什么地方病毒还是再次出现，腾讯官方给出的建议也是重装系统，因为你永远也保证不了病毒被删除干净，在这样的机器上继续使用的话，自己的内容越多，文件丢失的成本和风险越大，最后只能重装系统，重新部署环境。</a></p>\n<p>五、经此一役和挖矿病毒的斗争，或者说被虐也好，教训就是，做好服务器的快照备份，数据无价，万一真的丢失了恢复不了，那是真崩了。还好这次没什么重大损失。</p>\n"},{"title":"游戏笔记，杂项","date":"2018-08-14T03:54:04.000Z","id":"gamenote0","_content":"\n- 圆形内随机，随机半径，再随机角度，出现的结果达不到均匀散落的效果，因为圆内半径小，靠近圆心的面积小，远离圆心的面积大，造成虽然内外随机相同数量，但是视觉上感受外面数量很少。\n\n-  解决办法：\n\n1. 在圆的外切矩形内随机，如果随机到圆外，继续随机，直到随机到圆内。\n2.  使用开方函数，具体：先在[0,1]内随机，然后开方，然后乘以半径，再随机角度，这样角度和半径确定随机的点为位置。\n3.  使用正弦函数。同上：先在[0,PI/2]内随机，然后求正弦值，然后乘以半径，确定半径，再确定角度。 \n\n- 框架改进，周边工具的自动化和友好度提高，从继承层次改为模块化，模块化进一步懒加载，load和init完全分离，互不影响。\n\n","source":"_posts/gamenote0.md","raw":"---\ntitle: 游戏笔记，杂项\ndate: 2018-08-14 11:54:04\ntags:\n  - 笔记\nid: gamenote0\ncategories:\n  - 笔记\n---\n\n- 圆形内随机，随机半径，再随机角度，出现的结果达不到均匀散落的效果，因为圆内半径小，靠近圆心的面积小，远离圆心的面积大，造成虽然内外随机相同数量，但是视觉上感受外面数量很少。\n\n-  解决办法：\n\n1. 在圆的外切矩形内随机，如果随机到圆外，继续随机，直到随机到圆内。\n2.  使用开方函数，具体：先在[0,1]内随机，然后开方，然后乘以半径，再随机角度，这样角度和半径确定随机的点为位置。\n3.  使用正弦函数。同上：先在[0,PI/2]内随机，然后求正弦值，然后乘以半径，确定半径，再确定角度。 \n\n- 框架改进，周边工具的自动化和友好度提高，从继承层次改为模块化，模块化进一步懒加载，load和init完全分离，互不影响。\n\n","slug":"gamenote0","published":1,"updated":"2021-08-27T03:59:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljk0005hcmn09p3dh6p","content":"<ul>\n<li><p>圆形内随机，随机半径，再随机角度，出现的结果达不到均匀散落的效果，因为圆内半径小，靠近圆心的面积小，远离圆心的面积大，造成虽然内外随机相同数量，但是视觉上感受外面数量很少。</p>\n</li>\n<li><p> 解决办法：</p>\n</li>\n</ul>\n<ol>\n<li>在圆的外切矩形内随机，如果随机到圆外，继续随机，直到随机到圆内。</li>\n<li> 使用开方函数，具体：先在[0,1]内随机，然后开方，然后乘以半径，再随机角度，这样角度和半径确定随机的点为位置。</li>\n<li> 使用正弦函数。同上：先在[0,PI/2]内随机，然后求正弦值，然后乘以半径，确定半径，再确定角度。 </li>\n</ol>\n<ul>\n<li>框架改进，周边工具的自动化和友好度提高，从继承层次改为模块化，模块化进一步懒加载，load和init完全分离，互不影响。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>圆形内随机，随机半径，再随机角度，出现的结果达不到均匀散落的效果，因为圆内半径小，靠近圆心的面积小，远离圆心的面积大，造成虽然内外随机相同数量，但是视觉上感受外面数量很少。</p>\n</li>\n<li><p> 解决办法：</p>\n</li>\n</ul>\n<ol>\n<li>在圆的外切矩形内随机，如果随机到圆外，继续随机，直到随机到圆内。</li>\n<li> 使用开方函数，具体：先在[0,1]内随机，然后开方，然后乘以半径，再随机角度，这样角度和半径确定随机的点为位置。</li>\n<li> 使用正弦函数。同上：先在[0,PI/2]内随机，然后求正弦值，然后乘以半径，确定半径，再确定角度。 </li>\n</ol>\n<ul>\n<li>框架改进，周边工具的自动化和友好度提高，从继承层次改为模块化，模块化进一步懒加载，load和init完全分离，互不影响。</li>\n</ul>\n"},{"title":"使用Flutter进行APP开发流程","date":"2018-11-22T11:34:22.000Z","id":"flutter-dev","_content":"\n[![hBsVC6.md.png](https://z3.ax1x.com/2021/09/01/hBsVC6.md.png)](https://imgtu.com/i/hBsVC6)\n\n# 资源加载：\n\n### 1.本地\n\n```\nstatic const String DEFAULT_USER_ICON = 'static/images/logo.png';\nImage.asset(AppICons.DEFAULT_USER_ICON, width: AppICons.USER_ICON_WIDTH, height: AppICons.USER_ICON_HEIGHT),\n```\n\n### 2.iconfont。 https://www.iconfont.cn/\n\n在iconfont网站上传资源。下载到本地，放入项目资源文件夹下。\n\npubspec.yaml中配置。\n\n```\nfonts:\n  - family: myIconFont\n    fonts:\n      - asset: static/font/iconfont.ttf\n```\n\n### 3.UI编辑器。 https://norbert515.github.io/widget_maker/website/\n\nhttps://github.com/Norbert515/flutter_ide\n\n项目中使用：\n\n```\nstatic const String FONT_FAMILY = 'myIconFont';\nstatic const IconData LOGIN_USER = const IconData(0xe652, fontFamily: AppICons.FONT_FAMILY);\niconData: AppICons.LOGIN_USER,\n```\n\n# 原型开发：\n\nhttps://www.xiaopiu.com/\n\n在上面设计开发，然后导出到本地，可以查看里面的资源文件。\n","source":"_posts/flutter-dev.md","raw":"---\ntitle: 使用Flutter进行APP开发流程\ndate: 2018-11-22 19:34:22\ntags:\n  - 笔记\nid: flutter-dev\ncategories:\n  - 笔记\n---\n\n[![hBsVC6.md.png](https://z3.ax1x.com/2021/09/01/hBsVC6.md.png)](https://imgtu.com/i/hBsVC6)\n\n# 资源加载：\n\n### 1.本地\n\n```\nstatic const String DEFAULT_USER_ICON = 'static/images/logo.png';\nImage.asset(AppICons.DEFAULT_USER_ICON, width: AppICons.USER_ICON_WIDTH, height: AppICons.USER_ICON_HEIGHT),\n```\n\n### 2.iconfont。 https://www.iconfont.cn/\n\n在iconfont网站上传资源。下载到本地，放入项目资源文件夹下。\n\npubspec.yaml中配置。\n\n```\nfonts:\n  - family: myIconFont\n    fonts:\n      - asset: static/font/iconfont.ttf\n```\n\n### 3.UI编辑器。 https://norbert515.github.io/widget_maker/website/\n\nhttps://github.com/Norbert515/flutter_ide\n\n项目中使用：\n\n```\nstatic const String FONT_FAMILY = 'myIconFont';\nstatic const IconData LOGIN_USER = const IconData(0xe652, fontFamily: AppICons.FONT_FAMILY);\niconData: AppICons.LOGIN_USER,\n```\n\n# 原型开发：\n\nhttps://www.xiaopiu.com/\n\n在上面设计开发，然后导出到本地，可以查看里面的资源文件。\n","slug":"flutter-dev","published":1,"updated":"2021-09-02T02:03:39.150Z","_id":"ckt1g0ljl0008hcmnhedk6ing","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://imgtu.com/i/hBsVC6\"><img src=\"https://z3.ax1x.com/2021/09/01/hBsVC6.md.png\" alt=\"hBsVC6.md.png\"></a></p>\n<h1 id=\"资源加载：\"><a href=\"#资源加载：\" class=\"headerlink\" title=\"资源加载：\"></a>资源加载：</h1><h3 id=\"1-本地\"><a href=\"#1-本地\" class=\"headerlink\" title=\"1.本地\"></a>1.本地</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const String DEFAULT_USER_ICON = &#x27;static/images/logo.png&#x27;;</span><br><span class=\"line\">Image.asset(AppICons.DEFAULT_USER_ICON, width: AppICons.USER_ICON_WIDTH, height: AppICons.USER_ICON_HEIGHT),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-iconfont。-https-www-iconfont-cn\"><a href=\"#2-iconfont。-https-www-iconfont-cn\" class=\"headerlink\" title=\"2.iconfont。 https://www.iconfont.cn/\"></a>2.iconfont。 <a href=\"https://www.iconfont.cn/\">https://www.iconfont.cn/</a></h3><p>在iconfont网站上传资源。下载到本地，放入项目资源文件夹下。</p>\n<p>pubspec.yaml中配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fonts:</span><br><span class=\"line\">  - family: myIconFont</span><br><span class=\"line\">    fonts:</span><br><span class=\"line\">      - asset: static/font/iconfont.ttf</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-UI编辑器。-https-norbert515-github-io-widget-maker-website\"><a href=\"#3-UI编辑器。-https-norbert515-github-io-widget-maker-website\" class=\"headerlink\" title=\"3.UI编辑器。 https://norbert515.github.io/widget_maker/website/\"></a>3.UI编辑器。 <a href=\"https://norbert515.github.io/widget_maker/website/\">https://norbert515.github.io/widget_maker/website/</a></h3><p><a href=\"https://github.com/Norbert515/flutter_ide\">https://github.com/Norbert515/flutter_ide</a></p>\n<p>项目中使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const String FONT_FAMILY = &#x27;myIconFont&#x27;;</span><br><span class=\"line\">static const IconData LOGIN_USER = const IconData(0xe652, fontFamily: AppICons.FONT_FAMILY);</span><br><span class=\"line\">iconData: AppICons.LOGIN_USER,</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"原型开发：\"><a href=\"#原型开发：\" class=\"headerlink\" title=\"原型开发：\"></a>原型开发：</h1><p><a href=\"https://www.xiaopiu.com/\">https://www.xiaopiu.com/</a></p>\n<p>在上面设计开发，然后导出到本地，可以查看里面的资源文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://imgtu.com/i/hBsVC6\"><img src=\"https://z3.ax1x.com/2021/09/01/hBsVC6.md.png\" alt=\"hBsVC6.md.png\"></a></p>\n<h1 id=\"资源加载：\"><a href=\"#资源加载：\" class=\"headerlink\" title=\"资源加载：\"></a>资源加载：</h1><h3 id=\"1-本地\"><a href=\"#1-本地\" class=\"headerlink\" title=\"1.本地\"></a>1.本地</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const String DEFAULT_USER_ICON = &#x27;static/images/logo.png&#x27;;</span><br><span class=\"line\">Image.asset(AppICons.DEFAULT_USER_ICON, width: AppICons.USER_ICON_WIDTH, height: AppICons.USER_ICON_HEIGHT),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-iconfont。-https-www-iconfont-cn\"><a href=\"#2-iconfont。-https-www-iconfont-cn\" class=\"headerlink\" title=\"2.iconfont。 https://www.iconfont.cn/\"></a>2.iconfont。 <a href=\"https://www.iconfont.cn/\">https://www.iconfont.cn/</a></h3><p>在iconfont网站上传资源。下载到本地，放入项目资源文件夹下。</p>\n<p>pubspec.yaml中配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fonts:</span><br><span class=\"line\">  - family: myIconFont</span><br><span class=\"line\">    fonts:</span><br><span class=\"line\">      - asset: static/font/iconfont.ttf</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-UI编辑器。-https-norbert515-github-io-widget-maker-website\"><a href=\"#3-UI编辑器。-https-norbert515-github-io-widget-maker-website\" class=\"headerlink\" title=\"3.UI编辑器。 https://norbert515.github.io/widget_maker/website/\"></a>3.UI编辑器。 <a href=\"https://norbert515.github.io/widget_maker/website/\">https://norbert515.github.io/widget_maker/website/</a></h3><p><a href=\"https://github.com/Norbert515/flutter_ide\">https://github.com/Norbert515/flutter_ide</a></p>\n<p>项目中使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const String FONT_FAMILY = &#x27;myIconFont&#x27;;</span><br><span class=\"line\">static const IconData LOGIN_USER = const IconData(0xe652, fontFamily: AppICons.FONT_FAMILY);</span><br><span class=\"line\">iconData: AppICons.LOGIN_USER,</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"原型开发：\"><a href=\"#原型开发：\" class=\"headerlink\" title=\"原型开发：\"></a>原型开发：</h1><p><a href=\"https://www.xiaopiu.com/\">https://www.xiaopiu.com/</a></p>\n<p>在上面设计开发，然后导出到本地，可以查看里面的资源文件。</p>\n"},{"title":"常见垃圾收集器的特点","date":"2019-03-31T11:54:08.000Z","id":"gc-charator","_content":"\n#### CMS（Concurrent Mark Sweep）收集器\n\n![常见垃圾收集器的特点 - 第1张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/11.png?resize=640%2C175)\n\n**缺点：**1.CMS收集器对CPU资源非常敏感。并发执行的特性，会对用户线程产生影响。\n2.CMS收集器无法处理浮动垃圾。并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，CMS无法处理他们。\n3.采用标记-清楚算法实现，产生内存碎片。\n\n#### G1（Garbage-First）收集器\n\n![常见垃圾收集器的特点 - 第2张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/12.png?resize=640%2C173)\n\n**特点：**1.并发与并行。\n2.分代收集。\n3.空间整合。标记-整理算法。\n4.可预测的停顿。降低停顿时间是G1和CMS共同的关注点。\n5.G1可以进行垃圾收集的范围包括新生代和老年代。将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。**化整为零的思路，并维护优先队列，使得G1收集器实现可预测的停顿。**\n6.可达性分析时跨Region对象引用的问题，虚拟机维护Remembered Set来避免全堆扫描。\n\n#### ZGC（）收集器\n\n#### 堆外内存导致溢出错误\n\n堆外内存不在垃圾回收的范围内，如果发生内存溢出的情况，也有可能是堆外内存引起的，常见的堆外内存包括：\n1.Direct Memory。可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError: Direct buffer memory。\n2.线程堆栈。可通过-Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread。\n3.Socket缓存区。IOException: Too many open files。\n4.JNI代码。调用本地库，本地库使用的内存也不在堆中。\n5.虚拟机和GC。虚拟机和GC的代码执行也要消耗一定的内存。\n","source":"_posts/gc-charator.md","raw":"---\ntitle: 常见垃圾收集器的特点\ndate: 2019-03-31 19:54:08\ntags:\n  - 笔记\nid: gc-charator\ncategories:\n  - 笔记\n---\n\n#### CMS（Concurrent Mark Sweep）收集器\n\n![常见垃圾收集器的特点 - 第1张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/11.png?resize=640%2C175)\n\n**缺点：**1.CMS收集器对CPU资源非常敏感。并发执行的特性，会对用户线程产生影响。\n2.CMS收集器无法处理浮动垃圾。并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，CMS无法处理他们。\n3.采用标记-清楚算法实现，产生内存碎片。\n\n#### G1（Garbage-First）收集器\n\n![常见垃圾收集器的特点 - 第2张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/12.png?resize=640%2C173)\n\n**特点：**1.并发与并行。\n2.分代收集。\n3.空间整合。标记-整理算法。\n4.可预测的停顿。降低停顿时间是G1和CMS共同的关注点。\n5.G1可以进行垃圾收集的范围包括新生代和老年代。将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。**化整为零的思路，并维护优先队列，使得G1收集器实现可预测的停顿。**\n6.可达性分析时跨Region对象引用的问题，虚拟机维护Remembered Set来避免全堆扫描。\n\n#### ZGC（）收集器\n\n#### 堆外内存导致溢出错误\n\n堆外内存不在垃圾回收的范围内，如果发生内存溢出的情况，也有可能是堆外内存引起的，常见的堆外内存包括：\n1.Direct Memory。可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError: Direct buffer memory。\n2.线程堆栈。可通过-Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread。\n3.Socket缓存区。IOException: Too many open files。\n4.JNI代码。调用本地库，本地库使用的内存也不在堆中。\n5.虚拟机和GC。虚拟机和GC的代码执行也要消耗一定的内存。\n","slug":"gc-charator","published":1,"updated":"2021-09-01T11:54:55.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljm000bhcmn03tyhnfe","content":"<h4 id=\"CMS（Concurrent-Mark-Sweep）收集器\"><a href=\"#CMS（Concurrent-Mark-Sweep）收集器\" class=\"headerlink\" title=\"CMS（Concurrent Mark Sweep）收集器\"></a>CMS（Concurrent Mark Sweep）收集器</h4><p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/11.png?resize=640,175\" alt=\"常见垃圾收集器的特点 - 第1张  | 张嘎\"></p>\n<p><strong>缺点：</strong>1.CMS收集器对CPU资源非常敏感。并发执行的特性，会对用户线程产生影响。<br>2.CMS收集器无法处理浮动垃圾。并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，CMS无法处理他们。<br>3.采用标记-清楚算法实现，产生内存碎片。</p>\n<h4 id=\"G1（Garbage-First）收集器\"><a href=\"#G1（Garbage-First）收集器\" class=\"headerlink\" title=\"G1（Garbage-First）收集器\"></a>G1（Garbage-First）收集器</h4><p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/12.png?resize=640,173\" alt=\"常见垃圾收集器的特点 - 第2张  | 张嘎\"></p>\n<p><strong>特点：</strong>1.并发与并行。<br>2.分代收集。<br>3.空间整合。标记-整理算法。<br>4.可预测的停顿。降低停顿时间是G1和CMS共同的关注点。<br>5.G1可以进行垃圾收集的范围包括新生代和老年代。将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。<strong>化整为零的思路，并维护优先队列，使得G1收集器实现可预测的停顿。</strong><br>6.可达性分析时跨Region对象引用的问题，虚拟机维护Remembered Set来避免全堆扫描。</p>\n<h4 id=\"ZGC（）收集器\"><a href=\"#ZGC（）收集器\" class=\"headerlink\" title=\"ZGC（）收集器\"></a>ZGC（）收集器</h4><h4 id=\"堆外内存导致溢出错误\"><a href=\"#堆外内存导致溢出错误\" class=\"headerlink\" title=\"堆外内存导致溢出错误\"></a>堆外内存导致溢出错误</h4><p>堆外内存不在垃圾回收的范围内，如果发生内存溢出的情况，也有可能是堆外内存引起的，常见的堆外内存包括：<br>1.Direct Memory。可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError: Direct buffer memory。<br>2.线程堆栈。可通过-Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread。<br>3.Socket缓存区。IOException: Too many open files。<br>4.JNI代码。调用本地库，本地库使用的内存也不在堆中。<br>5.虚拟机和GC。虚拟机和GC的代码执行也要消耗一定的内存。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"CMS（Concurrent-Mark-Sweep）收集器\"><a href=\"#CMS（Concurrent-Mark-Sweep）收集器\" class=\"headerlink\" title=\"CMS（Concurrent Mark Sweep）收集器\"></a>CMS（Concurrent Mark Sweep）收集器</h4><p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/11.png?resize=640,175\" alt=\"常见垃圾收集器的特点 - 第1张  | 张嘎\"></p>\n<p><strong>缺点：</strong>1.CMS收集器对CPU资源非常敏感。并发执行的特性，会对用户线程产生影响。<br>2.CMS收集器无法处理浮动垃圾。并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，CMS无法处理他们。<br>3.采用标记-清楚算法实现，产生内存碎片。</p>\n<h4 id=\"G1（Garbage-First）收集器\"><a href=\"#G1（Garbage-First）收集器\" class=\"headerlink\" title=\"G1（Garbage-First）收集器\"></a>G1（Garbage-First）收集器</h4><p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/12.png?resize=640,173\" alt=\"常见垃圾收集器的特点 - 第2张  | 张嘎\"></p>\n<p><strong>特点：</strong>1.并发与并行。<br>2.分代收集。<br>3.空间整合。标记-整理算法。<br>4.可预测的停顿。降低停顿时间是G1和CMS共同的关注点。<br>5.G1可以进行垃圾收集的范围包括新生代和老年代。将整个Java堆划分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。<strong>化整为零的思路，并维护优先队列，使得G1收集器实现可预测的停顿。</strong><br>6.可达性分析时跨Region对象引用的问题，虚拟机维护Remembered Set来避免全堆扫描。</p>\n<h4 id=\"ZGC（）收集器\"><a href=\"#ZGC（）收集器\" class=\"headerlink\" title=\"ZGC（）收集器\"></a>ZGC（）收集器</h4><h4 id=\"堆外内存导致溢出错误\"><a href=\"#堆外内存导致溢出错误\" class=\"headerlink\" title=\"堆外内存导致溢出错误\"></a>堆外内存导致溢出错误</h4><p>堆外内存不在垃圾回收的范围内，如果发生内存溢出的情况，也有可能是堆外内存引起的，常见的堆外内存包括：<br>1.Direct Memory。可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError: Direct buffer memory。<br>2.线程堆栈。可通过-Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread。<br>3.Socket缓存区。IOException: Too many open files。<br>4.JNI代码。调用本地库，本地库使用的内存也不在堆中。<br>5.虚拟机和GC。虚拟机和GC的代码执行也要消耗一定的内存。</p>\n"},{"title":"地理位置信息GeoHash算法及Google S2算法","date":"2018-08-17T03:59:48.000Z","id":"geohash","_content":"\n最近在持续优化服务器3D场景建模的方案，受Redis的GEO启发，现在有一个空间和时间上都比较理想的方案，等实际测试和实现之后再整理完整文档。\n\n[![hMnZuR.md.png](https://z3.ax1x.com/2021/08/27/hMnZuR.md.png)](https://imgtu.com/i/hMnZuR)\n\n先给出两篇不错的算法文章。\n\n非常详细的算法分析：\n\nhttps://halfrost.com/go_spatial_search/\n\nhttps://www.cnblogs.com/LBSer/p/3310455.html\n\nRedis GEO使用：\n\nhttps://www.jianshu.com/p/c9801c4f9f6a\n\n寻路算法：\n\nhttp://gad.qq.com/article/detail/33637\n\nhttps://zerowidth.com/2013/05/05/jump-point-search-explained.html\n\nhttp://qiao.github.io/PathFinding.js/visual/\n\nhttp://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html\n","source":"_posts/geohash.md","raw":"---\ntitle: 地理位置信息GeoHash算法及Google S2算法\ndate: 2018-08-17 11:59:48\ntags:\n  - 笔记\nid: geohash\ncategories:\n  - 笔记\n---\n\n最近在持续优化服务器3D场景建模的方案，受Redis的GEO启发，现在有一个空间和时间上都比较理想的方案，等实际测试和实现之后再整理完整文档。\n\n[![hMnZuR.md.png](https://z3.ax1x.com/2021/08/27/hMnZuR.md.png)](https://imgtu.com/i/hMnZuR)\n\n先给出两篇不错的算法文章。\n\n非常详细的算法分析：\n\nhttps://halfrost.com/go_spatial_search/\n\nhttps://www.cnblogs.com/LBSer/p/3310455.html\n\nRedis GEO使用：\n\nhttps://www.jianshu.com/p/c9801c4f9f6a\n\n寻路算法：\n\nhttp://gad.qq.com/article/detail/33637\n\nhttps://zerowidth.com/2013/05/05/jump-point-search-explained.html\n\nhttp://qiao.github.io/PathFinding.js/visual/\n\nhttp://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html\n","slug":"geohash","published":1,"updated":"2021-08-27T04:05:26.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljn000ehcmnadh80a0i","content":"<p>最近在持续优化服务器3D场景建模的方案，受Redis的GEO启发，现在有一个空间和时间上都比较理想的方案，等实际测试和实现之后再整理完整文档。</p>\n<p><a href=\"https://imgtu.com/i/hMnZuR\"><img src=\"https://z3.ax1x.com/2021/08/27/hMnZuR.md.png\" alt=\"hMnZuR.md.png\"></a></p>\n<p>先给出两篇不错的算法文章。</p>\n<p>非常详细的算法分析：</p>\n<p><a href=\"https://halfrost.com/go_spatial_search/\">https://halfrost.com/go_spatial_search/</a></p>\n<p><a href=\"https://www.cnblogs.com/LBSer/p/3310455.html\">https://www.cnblogs.com/LBSer/p/3310455.html</a></p>\n<p>Redis GEO使用：</p>\n<p><a href=\"https://www.jianshu.com/p/c9801c4f9f6a\">https://www.jianshu.com/p/c9801c4f9f6a</a></p>\n<p>寻路算法：</p>\n<p><a href=\"http://gad.qq.com/article/detail/33637\">http://gad.qq.com/article/detail/33637</a></p>\n<p><a href=\"https://zerowidth.com/2013/05/05/jump-point-search-explained.html\">https://zerowidth.com/2013/05/05/jump-point-search-explained.html</a></p>\n<p><a href=\"http://qiao.github.io/PathFinding.js/visual/\">http://qiao.github.io/PathFinding.js/visual/</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html\">http://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在持续优化服务器3D场景建模的方案，受Redis的GEO启发，现在有一个空间和时间上都比较理想的方案，等实际测试和实现之后再整理完整文档。</p>\n<p><a href=\"https://imgtu.com/i/hMnZuR\"><img src=\"https://z3.ax1x.com/2021/08/27/hMnZuR.md.png\" alt=\"hMnZuR.md.png\"></a></p>\n<p>先给出两篇不错的算法文章。</p>\n<p>非常详细的算法分析：</p>\n<p><a href=\"https://halfrost.com/go_spatial_search/\">https://halfrost.com/go_spatial_search/</a></p>\n<p><a href=\"https://www.cnblogs.com/LBSer/p/3310455.html\">https://www.cnblogs.com/LBSer/p/3310455.html</a></p>\n<p>Redis GEO使用：</p>\n<p><a href=\"https://www.jianshu.com/p/c9801c4f9f6a\">https://www.jianshu.com/p/c9801c4f9f6a</a></p>\n<p>寻路算法：</p>\n<p><a href=\"http://gad.qq.com/article/detail/33637\">http://gad.qq.com/article/detail/33637</a></p>\n<p><a href=\"https://zerowidth.com/2013/05/05/jump-point-search-explained.html\">https://zerowidth.com/2013/05/05/jump-point-search-explained.html</a></p>\n<p><a href=\"http://qiao.github.io/PathFinding.js/visual/\">http://qiao.github.io/PathFinding.js/visual/</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html\">http://blog.sina.com.cn/s/blog_4a5c75d40102wo5l.html</a></p>\n"},{"title":"首届hackathon的一些感想","date":"2018-11-01T11:30:40.000Z","id":"hackathon","_content":"\n很开心我们团队能获得《最佳用户体验奖》。从零开始，全新的团队，30个小时出demo。\n\n[![hBrcBd.jpg](https://z3.ax1x.com/2021/09/01/hBrcBd.jpg)](https://imgtu.com/i/hBrcBd)\n\n后续的一些想法，本身如果局限于旅行方面可能用户群里和内容生成有很大的局限性。\n\n但是一些高度定制的行业，如教育，包括一些特殊产业，还是很有市场的，晚上团队聚餐的时候一起讨论下。\n","source":"_posts/hackathon.md","raw":"---\ntitle: 首届hackathon的一些感想\ndate: 2018-11-01 19:30:40\ntags:\n  - 笔记\nid: hackathon\ncategories:\n  - 笔记\n---\n\n很开心我们团队能获得《最佳用户体验奖》。从零开始，全新的团队，30个小时出demo。\n\n[![hBrcBd.jpg](https://z3.ax1x.com/2021/09/01/hBrcBd.jpg)](https://imgtu.com/i/hBrcBd)\n\n后续的一些想法，本身如果局限于旅行方面可能用户群里和内容生成有很大的局限性。\n\n但是一些高度定制的行业，如教育，包括一些特殊产业，还是很有市场的，晚上团队聚餐的时候一起讨论下。\n","slug":"hackathon","published":1,"updated":"2021-09-01T11:32:17.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljo000hhcmndud45khv","content":"<p>很开心我们团队能获得《最佳用户体验奖》。从零开始，全新的团队，30个小时出demo。</p>\n<p><a href=\"https://imgtu.com/i/hBrcBd\"><img src=\"https://z3.ax1x.com/2021/09/01/hBrcBd.jpg\" alt=\"hBrcBd.jpg\"></a></p>\n<p>后续的一些想法，本身如果局限于旅行方面可能用户群里和内容生成有很大的局限性。</p>\n<p>但是一些高度定制的行业，如教育，包括一些特殊产业，还是很有市场的，晚上团队聚餐的时候一起讨论下。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很开心我们团队能获得《最佳用户体验奖》。从零开始，全新的团队，30个小时出demo。</p>\n<p><a href=\"https://imgtu.com/i/hBrcBd\"><img src=\"https://z3.ax1x.com/2021/09/01/hBrcBd.jpg\" alt=\"hBrcBd.jpg\"></a></p>\n<p>后续的一些想法，本身如果局限于旅行方面可能用户群里和内容生成有很大的局限性。</p>\n<p>但是一些高度定制的行业，如教育，包括一些特殊产业，还是很有市场的，晚上团队聚餐的时候一起讨论下。</p>\n"},{"title":"JAVA HTTPS服务","date":"2019-01-12T11:39:20.000Z","id":"https","_content":"\n## 分自签证书和CA证书两种方式。\n\n# 一、制作一张自签证书（jks格式）\n\n```\n#keytool -genkey -keysize 2048 -validity 3650 -keyalg RSA -dname \"CN=myyiba.com\" -keypass 123456 -storepass 123456 -keystore myyiba.jks\n```\n\nkeytool为JDK提供的生成证书工具\n\n- -keysize 2048 密钥长度2048位（这个长度的密钥目前可认为无法被暴力破解）\n- -validity 3650 证书有效期3650天\n- -keyalg RSA 使用RSA非对称加密算法\n- -dname “CN=myyiba.com” 设置Common Name为myyiba.com，这是我的域名\n- -keypass 123456 密钥的访问密码为123456\n- -storepass 123456 密钥库的访问密码为123456（其实这两个密码也可以设置一样，通常都设置一样，方便记）\n- -keystore myyiba.jks 指定生成的密钥库文件为 myyiba .jks\n\n完了之后就拿到了myyiba.jks这个密钥库文件了，把它放到自己的项目目录下，比如：/usr/local/server/project/resource/myyiba.jks\n\n```\n项目示例：github下HttpServerInitializer\n```\n\n# 在程序初始化的时候生成SSLContext\n\n```\nkeyStore ks = KeyStore.getInstance(\"JKS\");\nInputStream ksInputStream = new FileInputStream(\"/usr/local/server/project/resource/myyiba.jks\");\nks.load(ksInputStream, \"123456\".toCharArray());\nkeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkmf.init(ks, \"123456\".toCharArray());\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(kmf.getKeyManagers(), null, null);\n```\n\n这个过程在整个程序周期只需要做一次，最好try-catch一下，以便检查异常，好了之后保存好sslContext，后面用到。\n\n# 在ChannelInitializer的initChannel中\n\n```\n@Override\nprotected void initChannel(SocketChannel socketChannel) throws Exception {\nSSLEngine sslEngine = sslContext.createSSLEngine();\nsslEngine.setUseClientMode(false); //服务器端模式\nsslEngine.setNeedClientAuth(false); //不需要验证客户端\nsocketChannel.pipeline().addLast(\"ssl\", new SslHandler(sslEngine)); //搞定\n//...\n}\n```\n\n# 二、CA证书\n\n例如微信小程序的服务器，需要CA证书的HTTPS服务，阿里云提供免费的SSL证书，申请证书后，下载tomcat版。解压有后两个文件：xxx.pfx和pfx-password.txt。\n\n[![hBsD5q.md.png](https://z3.ax1x.com/2021/09/01/hBsD5q.md.png)](https://imgtu.com/i/hBsD5q)\n\npfx文件类似上面的自签证书xxx.jks文件。加载证书的密码在\npfx-password.txt文件中。\n\n同上面自签证书一样的方式加载CA证书SSL。项目地址见同一个GitHub项目。\n","source":"_posts/https.md","raw":"---\ntitle: JAVA HTTPS服务\ndate: 2019-01-12 19:39:20\ntags:\n  - 笔记\nid: https\ncategories:\n  - 笔记\n---\n\n## 分自签证书和CA证书两种方式。\n\n# 一、制作一张自签证书（jks格式）\n\n```\n#keytool -genkey -keysize 2048 -validity 3650 -keyalg RSA -dname \"CN=myyiba.com\" -keypass 123456 -storepass 123456 -keystore myyiba.jks\n```\n\nkeytool为JDK提供的生成证书工具\n\n- -keysize 2048 密钥长度2048位（这个长度的密钥目前可认为无法被暴力破解）\n- -validity 3650 证书有效期3650天\n- -keyalg RSA 使用RSA非对称加密算法\n- -dname “CN=myyiba.com” 设置Common Name为myyiba.com，这是我的域名\n- -keypass 123456 密钥的访问密码为123456\n- -storepass 123456 密钥库的访问密码为123456（其实这两个密码也可以设置一样，通常都设置一样，方便记）\n- -keystore myyiba.jks 指定生成的密钥库文件为 myyiba .jks\n\n完了之后就拿到了myyiba.jks这个密钥库文件了，把它放到自己的项目目录下，比如：/usr/local/server/project/resource/myyiba.jks\n\n```\n项目示例：github下HttpServerInitializer\n```\n\n# 在程序初始化的时候生成SSLContext\n\n```\nkeyStore ks = KeyStore.getInstance(\"JKS\");\nInputStream ksInputStream = new FileInputStream(\"/usr/local/server/project/resource/myyiba.jks\");\nks.load(ksInputStream, \"123456\".toCharArray());\nkeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkmf.init(ks, \"123456\".toCharArray());\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(kmf.getKeyManagers(), null, null);\n```\n\n这个过程在整个程序周期只需要做一次，最好try-catch一下，以便检查异常，好了之后保存好sslContext，后面用到。\n\n# 在ChannelInitializer的initChannel中\n\n```\n@Override\nprotected void initChannel(SocketChannel socketChannel) throws Exception {\nSSLEngine sslEngine = sslContext.createSSLEngine();\nsslEngine.setUseClientMode(false); //服务器端模式\nsslEngine.setNeedClientAuth(false); //不需要验证客户端\nsocketChannel.pipeline().addLast(\"ssl\", new SslHandler(sslEngine)); //搞定\n//...\n}\n```\n\n# 二、CA证书\n\n例如微信小程序的服务器，需要CA证书的HTTPS服务，阿里云提供免费的SSL证书，申请证书后，下载tomcat版。解压有后两个文件：xxx.pfx和pfx-password.txt。\n\n[![hBsD5q.md.png](https://z3.ax1x.com/2021/09/01/hBsD5q.md.png)](https://imgtu.com/i/hBsD5q)\n\npfx文件类似上面的自签证书xxx.jks文件。加载证书的密码在\npfx-password.txt文件中。\n\n同上面自签证书一样的方式加载CA证书SSL。项目地址见同一个GitHub项目。\n","slug":"https","published":1,"updated":"2021-09-01T11:40:27.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljr000mhcmn4k7vcoz4","content":"<h2 id=\"分自签证书和CA证书两种方式。\"><a href=\"#分自签证书和CA证书两种方式。\" class=\"headerlink\" title=\"分自签证书和CA证书两种方式。\"></a>分自签证书和CA证书两种方式。</h2><h1 id=\"一、制作一张自签证书（jks格式）\"><a href=\"#一、制作一张自签证书（jks格式）\" class=\"headerlink\" title=\"一、制作一张自签证书（jks格式）\"></a>一、制作一张自签证书（jks格式）</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#keytool -genkey -keysize 2048 -validity 3650 -keyalg RSA -dname &quot;CN=myyiba.com&quot; -keypass 123456 -storepass 123456 -keystore myyiba.jks</span><br></pre></td></tr></table></figure>\n\n<p>keytool为JDK提供的生成证书工具</p>\n<ul>\n<li>-keysize 2048 密钥长度2048位（这个长度的密钥目前可认为无法被暴力破解）</li>\n<li>-validity 3650 证书有效期3650天</li>\n<li>-keyalg RSA 使用RSA非对称加密算法</li>\n<li>-dname “CN=myyiba.com” 设置Common Name为myyiba.com，这是我的域名</li>\n<li>-keypass 123456 密钥的访问密码为123456</li>\n<li>-storepass 123456 密钥库的访问密码为123456（其实这两个密码也可以设置一样，通常都设置一样，方便记）</li>\n<li>-keystore myyiba.jks 指定生成的密钥库文件为 myyiba .jks</li>\n</ul>\n<p>完了之后就拿到了myyiba.jks这个密钥库文件了，把它放到自己的项目目录下，比如：/usr/local/server/project/resource/myyiba.jks</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">项目示例：github下HttpServerInitializer</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"在程序初始化的时候生成SSLContext\"><a href=\"#在程序初始化的时候生成SSLContext\" class=\"headerlink\" title=\"在程序初始化的时候生成SSLContext\"></a>在程序初始化的时候生成SSLContext</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keyStore ks = KeyStore.getInstance(&quot;JKS&quot;);</span><br><span class=\"line\">InputStream ksInputStream = new FileInputStream(&quot;/usr/local/server/project/resource/myyiba.jks&quot;);</span><br><span class=\"line\">ks.load(ksInputStream, &quot;123456&quot;.toCharArray());</span><br><span class=\"line\">keyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class=\"line\">kmf.init(ks, &quot;123456&quot;.toCharArray());</span><br><span class=\"line\">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class=\"line\">sslContext.init(kmf.getKeyManagers(), null, null);</span><br></pre></td></tr></table></figure>\n\n<p>这个过程在整个程序周期只需要做一次，最好try-catch一下，以便检查异常，好了之后保存好sslContext，后面用到。</p>\n<h1 id=\"在ChannelInitializer的initChannel中\"><a href=\"#在ChannelInitializer的initChannel中\" class=\"headerlink\" title=\"在ChannelInitializer的initChannel中\"></a>在ChannelInitializer的initChannel中</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class=\"line\">SSLEngine sslEngine = sslContext.createSSLEngine();</span><br><span class=\"line\">sslEngine.setUseClientMode(false); //服务器端模式</span><br><span class=\"line\">sslEngine.setNeedClientAuth(false); //不需要验证客户端</span><br><span class=\"line\">socketChannel.pipeline().addLast(&quot;ssl&quot;, new SslHandler(sslEngine)); //搞定</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、CA证书\"><a href=\"#二、CA证书\" class=\"headerlink\" title=\"二、CA证书\"></a>二、CA证书</h1><p>例如微信小程序的服务器，需要CA证书的HTTPS服务，阿里云提供免费的SSL证书，申请证书后，下载tomcat版。解压有后两个文件：xxx.pfx和pfx-password.txt。</p>\n<p><a href=\"https://imgtu.com/i/hBsD5q\"><img src=\"https://z3.ax1x.com/2021/09/01/hBsD5q.md.png\" alt=\"hBsD5q.md.png\"></a></p>\n<p>pfx文件类似上面的自签证书xxx.jks文件。加载证书的密码在<br>pfx-password.txt文件中。</p>\n<p>同上面自签证书一样的方式加载CA证书SSL。项目地址见同一个GitHub项目。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"分自签证书和CA证书两种方式。\"><a href=\"#分自签证书和CA证书两种方式。\" class=\"headerlink\" title=\"分自签证书和CA证书两种方式。\"></a>分自签证书和CA证书两种方式。</h2><h1 id=\"一、制作一张自签证书（jks格式）\"><a href=\"#一、制作一张自签证书（jks格式）\" class=\"headerlink\" title=\"一、制作一张自签证书（jks格式）\"></a>一、制作一张自签证书（jks格式）</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#keytool -genkey -keysize 2048 -validity 3650 -keyalg RSA -dname &quot;CN=myyiba.com&quot; -keypass 123456 -storepass 123456 -keystore myyiba.jks</span><br></pre></td></tr></table></figure>\n\n<p>keytool为JDK提供的生成证书工具</p>\n<ul>\n<li>-keysize 2048 密钥长度2048位（这个长度的密钥目前可认为无法被暴力破解）</li>\n<li>-validity 3650 证书有效期3650天</li>\n<li>-keyalg RSA 使用RSA非对称加密算法</li>\n<li>-dname “CN=myyiba.com” 设置Common Name为myyiba.com，这是我的域名</li>\n<li>-keypass 123456 密钥的访问密码为123456</li>\n<li>-storepass 123456 密钥库的访问密码为123456（其实这两个密码也可以设置一样，通常都设置一样，方便记）</li>\n<li>-keystore myyiba.jks 指定生成的密钥库文件为 myyiba .jks</li>\n</ul>\n<p>完了之后就拿到了myyiba.jks这个密钥库文件了，把它放到自己的项目目录下，比如：/usr/local/server/project/resource/myyiba.jks</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">项目示例：github下HttpServerInitializer</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"在程序初始化的时候生成SSLContext\"><a href=\"#在程序初始化的时候生成SSLContext\" class=\"headerlink\" title=\"在程序初始化的时候生成SSLContext\"></a>在程序初始化的时候生成SSLContext</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keyStore ks = KeyStore.getInstance(&quot;JKS&quot;);</span><br><span class=\"line\">InputStream ksInputStream = new FileInputStream(&quot;/usr/local/server/project/resource/myyiba.jks&quot;);</span><br><span class=\"line\">ks.load(ksInputStream, &quot;123456&quot;.toCharArray());</span><br><span class=\"line\">keyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class=\"line\">kmf.init(ks, &quot;123456&quot;.toCharArray());</span><br><span class=\"line\">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class=\"line\">sslContext.init(kmf.getKeyManagers(), null, null);</span><br></pre></td></tr></table></figure>\n\n<p>这个过程在整个程序周期只需要做一次，最好try-catch一下，以便检查异常，好了之后保存好sslContext，后面用到。</p>\n<h1 id=\"在ChannelInitializer的initChannel中\"><a href=\"#在ChannelInitializer的initChannel中\" class=\"headerlink\" title=\"在ChannelInitializer的initChannel中\"></a>在ChannelInitializer的initChannel中</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class=\"line\">SSLEngine sslEngine = sslContext.createSSLEngine();</span><br><span class=\"line\">sslEngine.setUseClientMode(false); //服务器端模式</span><br><span class=\"line\">sslEngine.setNeedClientAuth(false); //不需要验证客户端</span><br><span class=\"line\">socketChannel.pipeline().addLast(&quot;ssl&quot;, new SslHandler(sslEngine)); //搞定</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、CA证书\"><a href=\"#二、CA证书\" class=\"headerlink\" title=\"二、CA证书\"></a>二、CA证书</h1><p>例如微信小程序的服务器，需要CA证书的HTTPS服务，阿里云提供免费的SSL证书，申请证书后，下载tomcat版。解压有后两个文件：xxx.pfx和pfx-password.txt。</p>\n<p><a href=\"https://imgtu.com/i/hBsD5q\"><img src=\"https://z3.ax1x.com/2021/09/01/hBsD5q.md.png\" alt=\"hBsD5q.md.png\"></a></p>\n<p>pfx文件类似上面的自签证书xxx.jks文件。加载证书的密码在<br>pfx-password.txt文件中。</p>\n<p>同上面自签证书一样的方式加载CA证书SSL。项目地址见同一个GitHub项目。</p>\n"},{"title":"JAVA游戏服务器热更","date":"2018-08-07T02:56:02.000Z","id":"java-hot","_content":"\n具体工程详见github:\n\nhttps://github.com/zhangga/HotswapJAVA.git\n\nagentmain和premain方法都只能修改方法体。\n\n[![hKvk5V.md.png](https://z3.ax1x.com/2021/08/27/hKvk5V.md.png)](https://imgtu.com/i/hKvk5V)\n\njrebel可以热更类，新增、删除、修改等。\n\njrebel有eclipse和idea的插件，方便平时开发时，不用重启服务器。\n\n破解版的插件在我的百度云盘里。\n\n","source":"_posts/java-hot.md","raw":"---\ntitle: JAVA游戏服务器热更\ndate: 2018-08-07 10:56:02\ntags:\n  - 笔记\nid: java-hot\ncategories:\n  - 笔记\n---\n\n具体工程详见github:\n\nhttps://github.com/zhangga/HotswapJAVA.git\n\nagentmain和premain方法都只能修改方法体。\n\n[![hKvk5V.md.png](https://z3.ax1x.com/2021/08/27/hKvk5V.md.png)](https://imgtu.com/i/hKvk5V)\n\njrebel可以热更类，新增、删除、修改等。\n\njrebel有eclipse和idea的插件，方便平时开发时，不用重启服务器。\n\n破解版的插件在我的百度云盘里。\n\n","slug":"java-hot","published":1,"updated":"2021-08-27T02:58:45.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljs000ohcmndsby7m8y","content":"<p>具体工程详见github:</p>\n<p><a href=\"https://github.com/zhangga/HotswapJAVA.git\">https://github.com/zhangga/HotswapJAVA.git</a></p>\n<p>agentmain和premain方法都只能修改方法体。</p>\n<p><a href=\"https://imgtu.com/i/hKvk5V\"><img src=\"https://z3.ax1x.com/2021/08/27/hKvk5V.md.png\" alt=\"hKvk5V.md.png\"></a></p>\n<p>jrebel可以热更类，新增、删除、修改等。</p>\n<p>jrebel有eclipse和idea的插件，方便平时开发时，不用重启服务器。</p>\n<p>破解版的插件在我的百度云盘里。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>具体工程详见github:</p>\n<p><a href=\"https://github.com/zhangga/HotswapJAVA.git\">https://github.com/zhangga/HotswapJAVA.git</a></p>\n<p>agentmain和premain方法都只能修改方法体。</p>\n<p><a href=\"https://imgtu.com/i/hKvk5V\"><img src=\"https://z3.ax1x.com/2021/08/27/hKvk5V.md.png\" alt=\"hKvk5V.md.png\"></a></p>\n<p>jrebel可以热更类，新增、删除、修改等。</p>\n<p>jrebel有eclipse和idea的插件，方便平时开发时，不用重启服务器。</p>\n<p>破解版的插件在我的百度云盘里。</p>\n"},{"title":"JVisualVM远程调试","date":"2018-08-01T02:51:44.000Z","id":"jvm-remote","_content":"\n# 一、使用jstatd\n\nlinux下使用 hostname -i  查看hostname对应的IP\n\n确保远程连接使用的ip在列表里，不在的话jvisualvm无法使用ip远程连接。\n\n不在的话vi /etc/hosts  在里面加入。\n\n<!--more-->\n\n进入jdk的bin目录下：/usr/java/jdk1.8/bin/\n\n新建文件jstatd.all.policy\n\n写入内容：\n\ngrant codebase “file:${java.home}/../lib/tools.jar” {\npermission java.security.AllPermission;\n};\n\n编写启动脚本：startJstatd.sh\n\n\\#!/bin/bash\nnohup $JAVA_HOME/bin/jstatd -J-Djava.rmi.server.hostname=172.16.200.82 -p 1099 -J-Djava.security.policy=jstatd.all.policy -J-Dcom.sun.management.jmxremote.authenticate=false -J-Dcom.sun.management.jmxremote.ssl=false -J-Dcom.sun.management.jmxremote.port=1199 &\n\n（-J-Djava.rmi.server.logCalls=true  参数能看到日志输出）\n\n脚本里有jstatd 和 jmx的配置。只要jstatd的配置也OJBK。\n\n确保linux的jstatd端口（默认1099）对外开放，然后使用jvisualvm远程连接即可。\n\n# 二、使用jmx\n\n找到配置文件$JAVA_HOME/jre/lib/management/jmxremote.password.template,复制一份并改名为jmxremote.password,\n\n使用chmod +w jmxremote.password  将文件加入写权限\n\n然后打开jmxremote.passwrod，取消以下两行注释：\n\n\\#monitorRole QED#controlRole R&D monitorRole为用户名 QED为密码 执行：chmod 400 jmxremote.password指令。 JVM启动脚本加入启动参数：JAVA_PARAMS=”$JAVA_PARAMS -Djava.rmi.server.hostname=47.95.10.167 -Dcom.sun.management.jmxremote.port=1199 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true”（可以关闭验证也OJBK）\n\n","source":"_posts/jvm-remote.md","raw":"---\ntitle: JVisualVM远程调试\ndate: 2018-08-01 10:51:44\ntags:\n  - 笔记\nid: jvm-remote\ncategories:\n  - 笔记\n---\n\n# 一、使用jstatd\n\nlinux下使用 hostname -i  查看hostname对应的IP\n\n确保远程连接使用的ip在列表里，不在的话jvisualvm无法使用ip远程连接。\n\n不在的话vi /etc/hosts  在里面加入。\n\n<!--more-->\n\n进入jdk的bin目录下：/usr/java/jdk1.8/bin/\n\n新建文件jstatd.all.policy\n\n写入内容：\n\ngrant codebase “file:${java.home}/../lib/tools.jar” {\npermission java.security.AllPermission;\n};\n\n编写启动脚本：startJstatd.sh\n\n\\#!/bin/bash\nnohup $JAVA_HOME/bin/jstatd -J-Djava.rmi.server.hostname=172.16.200.82 -p 1099 -J-Djava.security.policy=jstatd.all.policy -J-Dcom.sun.management.jmxremote.authenticate=false -J-Dcom.sun.management.jmxremote.ssl=false -J-Dcom.sun.management.jmxremote.port=1199 &\n\n（-J-Djava.rmi.server.logCalls=true  参数能看到日志输出）\n\n脚本里有jstatd 和 jmx的配置。只要jstatd的配置也OJBK。\n\n确保linux的jstatd端口（默认1099）对外开放，然后使用jvisualvm远程连接即可。\n\n# 二、使用jmx\n\n找到配置文件$JAVA_HOME/jre/lib/management/jmxremote.password.template,复制一份并改名为jmxremote.password,\n\n使用chmod +w jmxremote.password  将文件加入写权限\n\n然后打开jmxremote.passwrod，取消以下两行注释：\n\n\\#monitorRole QED#controlRole R&D monitorRole为用户名 QED为密码 执行：chmod 400 jmxremote.password指令。 JVM启动脚本加入启动参数：JAVA_PARAMS=”$JAVA_PARAMS -Djava.rmi.server.hostname=47.95.10.167 -Dcom.sun.management.jmxremote.port=1199 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true”（可以关闭验证也OJBK）\n\n","slug":"jvm-remote","published":1,"updated":"2021-08-27T03:00:21.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljt000rhcmn0y4z1s27","content":"<h1 id=\"一、使用jstatd\"><a href=\"#一、使用jstatd\" class=\"headerlink\" title=\"一、使用jstatd\"></a>一、使用jstatd</h1><p>linux下使用 hostname -i  查看hostname对应的IP</p>\n<p>确保远程连接使用的ip在列表里，不在的话jvisualvm无法使用ip远程连接。</p>\n<p>不在的话vi /etc/hosts  在里面加入。</p>\n<span id=\"more\"></span>\n\n<p>进入jdk的bin目录下：/usr/java/jdk1.8/bin/</p>\n<p>新建文件jstatd.all.policy</p>\n<p>写入内容：</p>\n<p>grant codebase “file:${java.home}/../lib/tools.jar” {<br>permission java.security.AllPermission;<br>};</p>\n<p>编写启动脚本：startJstatd.sh</p>\n<p>#!/bin/bash<br>nohup $JAVA_HOME/bin/jstatd -J-Djava.rmi.server.hostname=172.16.200.82 -p 1099 -J-Djava.security.policy=jstatd.all.policy -J-Dcom.sun.management.jmxremote.authenticate=false -J-Dcom.sun.management.jmxremote.ssl=false -J-Dcom.sun.management.jmxremote.port=1199 &amp;</p>\n<p>（-J-Djava.rmi.server.logCalls=true  参数能看到日志输出）</p>\n<p>脚本里有jstatd 和 jmx的配置。只要jstatd的配置也OJBK。</p>\n<p>确保linux的jstatd端口（默认1099）对外开放，然后使用jvisualvm远程连接即可。</p>\n<h1 id=\"二、使用jmx\"><a href=\"#二、使用jmx\" class=\"headerlink\" title=\"二、使用jmx\"></a>二、使用jmx</h1><p>找到配置文件$JAVA_HOME/jre/lib/management/jmxremote.password.template,复制一份并改名为jmxremote.password,</p>\n<p>使用chmod +w jmxremote.password  将文件加入写权限</p>\n<p>然后打开jmxremote.passwrod，取消以下两行注释：</p>\n<p>#monitorRole QED#controlRole R&amp;D monitorRole为用户名 QED为密码 执行：chmod 400 jmxremote.password指令。 JVM启动脚本加入启动参数：JAVA_PARAMS=”$JAVA_PARAMS -Djava.rmi.server.hostname=47.95.10.167 -Dcom.sun.management.jmxremote.port=1199 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true”（可以关闭验证也OJBK）</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、使用jstatd\"><a href=\"#一、使用jstatd\" class=\"headerlink\" title=\"一、使用jstatd\"></a>一、使用jstatd</h1><p>linux下使用 hostname -i  查看hostname对应的IP</p>\n<p>确保远程连接使用的ip在列表里，不在的话jvisualvm无法使用ip远程连接。</p>\n<p>不在的话vi /etc/hosts  在里面加入。</p>","more":"<p>进入jdk的bin目录下：/usr/java/jdk1.8/bin/</p>\n<p>新建文件jstatd.all.policy</p>\n<p>写入内容：</p>\n<p>grant codebase “file:${java.home}/../lib/tools.jar” {<br>permission java.security.AllPermission;<br>};</p>\n<p>编写启动脚本：startJstatd.sh</p>\n<p>#!/bin/bash<br>nohup $JAVA_HOME/bin/jstatd -J-Djava.rmi.server.hostname=172.16.200.82 -p 1099 -J-Djava.security.policy=jstatd.all.policy -J-Dcom.sun.management.jmxremote.authenticate=false -J-Dcom.sun.management.jmxremote.ssl=false -J-Dcom.sun.management.jmxremote.port=1199 &amp;</p>\n<p>（-J-Djava.rmi.server.logCalls=true  参数能看到日志输出）</p>\n<p>脚本里有jstatd 和 jmx的配置。只要jstatd的配置也OJBK。</p>\n<p>确保linux的jstatd端口（默认1099）对外开放，然后使用jvisualvm远程连接即可。</p>\n<h1 id=\"二、使用jmx\"><a href=\"#二、使用jmx\" class=\"headerlink\" title=\"二、使用jmx\"></a>二、使用jmx</h1><p>找到配置文件$JAVA_HOME/jre/lib/management/jmxremote.password.template,复制一份并改名为jmxremote.password,</p>\n<p>使用chmod +w jmxremote.password  将文件加入写权限</p>\n<p>然后打开jmxremote.passwrod，取消以下两行注释：</p>\n<p>#monitorRole QED#controlRole R&amp;D monitorRole为用户名 QED为密码 执行：chmod 400 jmxremote.password指令。 JVM启动脚本加入启动参数：JAVA_PARAMS=”$JAVA_PARAMS -Djava.rmi.server.hostname=47.95.10.167 -Dcom.sun.management.jmxremote.port=1199 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true”（可以关闭验证也OJBK）</p>"},{"title":"自己动手写JVM","date":"2019-02-27T11:40:56.000Z","id":"jvm-self","_content":"\n根据《自己动手写Java虚拟机》一书\n\n![自己动手写JVM - 第1张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/cover-300x179.png?resize=300%2C179)\n\n## 实现的go代码在GitHub中：[QJvm](https://github.com/zhangga/QJvm)\n\n## 可视化查看class文件的工具：[查看class工具](https://github.com/zxh0/classpy)，启动类：ClasspyApp。书籍自身代码：[代码](https://github.com/zxh0/jvmgo-book)\n\n \n\n# Class文件解析：\n\n![自己动手写JVM - 第2张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/22.png?resize=640%2C484)\n\n如上图所示：\n\n常量池解析：\n\n1.读取16位的常量池大小cp_count。\n\n2.索引从1到cp_count-1，依次读取常量信息。\n\n3.常量信息有tag(8bit)表示常量类型。不同的类型读取数据方式不同。\n\n// 常量池类型\n\nconst (\n\n  CONSTANT_Class = 7\n\n  CONSTANT_Fieldref = 9\n\n  CONSTANT_Methodref = 10\n\n  CONSTANT_InterfaceMethodref = 11\n\n  CONSTANT_String = 8\n\n  CONSTANT_Integer = 3\n\n  CONSTANT_Float = 4\n\n  CONSTANT_Long = 5\n\n  CONSTANT_Double = 6\n\n  CONSTANT_NameAndType = 12\n\n  CONSTANT_Utf8 = 1\n\n  CONSTANT_MethodHandle = 15\n\n  CONSTANT_MethodType = 16\n\n  CONSTANT_InvokeDynamic = 18\n\n)\n\n![自己动手写JVM - 第3张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/23.png?resize=640%2C490)\n\n常量池类型可分为下面几大类：\n\n| 类型         | 说明             | 具体代表类型           | class存储格式                                                |\n| ------------ | ---------------- | ---------------------- | ------------------------------------------------------------ |\n| numeric      | 数值型           | int/float/double等     | tag(8bit)+数值(具体类型决定)                                 |\n| string       | 指向字符串       | string                 | tag(8bit)+指向utf8字符串的索引(16bit)                        |\n| utf8         | 字符串           | string                 | tag(8bit)+length(16b)+bytes(length)                          |\n| class        | 类信息           | class                  | tag(8bit)+指向utf8字符串的索引(16bit)                        |\n| name&type    | 名字和描述(参数) | 字段、方法的名称和描述 | tag(8bit)+指向name字符串索引(16bit)+指向描述字符串的索引(16bit) |\n| member       | 成员信息         | 字段、方法、接口信息等 | tag(8bit)+指向class索引(16bit)+指向name&type的索引(16bit)    |\n| methodType   | 方法描述         | 方法                   | tag(8bit)+指向描述字符串的索引(16bit)                        |\n| methodHandle | 方法句柄         | 方法句柄               | tag(8bit)+refKind(8b)+指向引用ref的索引(16b)                 |\n| dynamic      | 动态调用         | Lambda表达式           | tag(8bit)+指定启动方法的索引(16b指向属性表)+指向name&type的索引(16b) |\n\n# 动态调用：CONSTANT_InvokeDynamic_info\n\n为了更好的支持[动态类型语言](http://en.wikipedia.org/wiki/Dynamic_typing#DYNAMIC)，[Java7](https://www.baidu.com/s?wd=Java7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)通过[JSR292](https://jcp.org/en/jsr/detail?id=292)给JVM增加了一条新的字节码指令：invokedynamic。Java8的Lambda表达式。\n\n以下面代码为例：\n\n![自己动手写JVM - 第4张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/24.png?resize=640%2C239)\n\n使用javap -v -p指令反编译生成的class文件，找到main方法，可以看到生成了一条indy指令\n\n![自己动手写JVM - 第5张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/25.png?resize=640%2C223)\n\n指向常量池索引为#2，查看常量池可知，确实是一个CONSTANT_InvokeDynamic_info\n\nCONSTANT_InvokeDynamic_info {\n\n  u1 tag;\n\n  u2 bootstrap_method_attr_index;\n\n  u2 name_and_type_index;\n\n}\n\n![自己动手写JVM - 第6张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/26.png?resize=640%2C89)\n\n可以看到有两个参数即我们上面表中总结的参数分别为：\n\n指定启动方法的索引(16b指向属性表)+指向name&type的索引(16b)\n\n先看name&type\n\n![自己动手写JVM - 第7张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/35.png?resize=640%2C125)\n\n它描述的是这样的一个方法：\n\nRunnable run() {…}\n\n再看bootstrap_method_attr_index\n\n[JVM规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21)规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定**有且仅有一个**BootstrapMethods属性。BootstrapMethods属性是个变长的表，结构如下所示：\n\nBootstrapMethods_attribute {\nu2 attribute_name_index;\nu4 attribute_length;\nu2 num_bootstrap_methods;\n{   u2 bootstrap_method_ref;\nu2 num_bootstrap_arguments;\nu2 bootstrap_arguments[num_bootstrap_arguments];\n} bootstrap_methods[num_bootstrap_methods];\n}\n每一个BootstrapMethod都包含一个bootstrap_method_ref和n个bootstrap_arguments。bootstrap_method_ref是个常量池索引，指向一个CONSTANT_MethodHandle_info。而每一个bootstrap_argument也都是常量池索引，可以指向下面这些结构：\n\n- CONSTANT_String_info\n- CONSTANT_Class_info\n- CONSTANT_Integer_info\n- CONSTANT_Long_info\n- CONSTANT_Float_info\n- CONSTANT_Double_info\n- CONSTANT_MethodHandle_info\n- CONSTANT_MethodType_info\n\n本例中的启动方法反编译图：\n\n![自己动手写JVM - 第8张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/28.png?resize=640%2C132)\n\n确实存在一个BootstrapMethods表，这个表中只有一个BootstrapMethod，它的bootstrap_method_ref是常量池#23，有三个bootstrap_arguments，分别指向常量池#24，#25，#24：\n\n![自己动手写JVM - 第9张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/30.png?resize=640%2C76)\n\n## CONSTANT_MethodHandle_info\n\n[CONSTANT_MethodHandle_info](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8)结构包含两项信息，其结构参考上面表格。\n\n \n\nreference_kind是一个1到9之间的整数，具体含义可以参考[JVM规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5)。reference_index是常量池索引，但具体索引的是什么类型的常量，需要看reference_kind：\n\n| constant_pool entry              | reference_kind                                               |\n| -------------------------------- | ------------------------------------------------------------ |\n| CONSTANT_Fieldref_info           | 1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField), or 4 (REF_putStatic) |\n| CONSTANT_Methodref_info          | 5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial), or 8 (REF_newInvokeSpecial) |\n| CONSTANT_InterfaceMethodref_info | 9 (REF_invokeInterface)                                      |\n\n通过观察常量池#23（上图中可以看到）可以看到，它的reference_kind是6（REF_invokeStatic），reference_index是#29，正好是个CONSTANT_Methodref_info：\n\n![自己动手写JVM - 第10张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/32.png?resize=640%2C130)\n\n引用的是java.lang.invoke.LambdaMetafactory类的静态方法metafactory()。\n\n引用关系图：\n\n![自己动手写JVM - 第11张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/33.png?resize=640%2C545)\n\nJVM如何执行indy指令\n前面从class文件的角度，分析了indy指令。下面让我们看看JVM是如何执行indy指令的。\n\n- 每一个indy指令出现的地方，都叫做一个dynamic call site（动态调用点）\n- 根据indy指令的操作数，可以找到一个call site specifier（调用点说明符），根据前面的分析，这个说明符其实就常量池里的CONSTANT_InvokeDynamic_info\n- JVM解析（resolve）调用点说明符，得到下面三种信息：\n\n1.一个MethodHandle，指向**bootstrap method**（启动方法）\n\n2.方法名和方法描述，表示动态调用的方法\n\n3.其他提供给启动方法的参数\n\n- 接着JVM调用启动方法，并把上一步提到的信息通过参数传给启动方法\n- 启动方法必须返回一个**CallSite**对象，并且，这个CallSite对象将永久和这个动态调用点关联\n- 调用跟CallSite关联的MethodHandle指向的方法\n\n \n\n下面是一张示意图，画出了关键点：\n\n![自己动手写JVM - 第12张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/31-1.png?resize=640%2C227)\n\n接着回到我们上面的常量池解析，注意ConstantLongInfo和ConstantDoubleInfo在常量池占两个位置。至此常量池解析完成。\n\n接着class文件中存放的是类访问标识。\n\n然后是类，超类，接口信息。都是常量池索引。\n\n然后字段表和方法表，这俩读取方式一样，以方法表为例：\n\n1.读取16位的方法个数，member_count\n\n2.依次读取member_count个方法信息：\n\n访问标识(16bit)、名称索引(16bit指向常量池)、描述符索引(16bit指向常量池)、读取方法关联的属性表。\n\n最后读取class文件的属性表Attributes。\n\n1.读取16位的属性个数，attributes_count\n\n2.依次读取attributes_count个属性信息：\n\n属性名索引(指向常量池的UTF8)、属性长度(32bit)，\n\n根据属性名和长度新建JVM实现的属性实例。\n\nJava虚拟机规范预定义了23种属性，可分为三组。\n\n一、Java虚拟机必须的，5种。\n\n二、Java类库必须的，12种。\n\n三、提供给工具使用的，6种。可选的。\n\n例：Code、ConstantValue、Exceptions、LineNumberTable、LocalVariableTable、SourceFile、Synthetic等\n\n至此class文件解析完成。\n\n \n\n# 线程启动：\n\n从启动类中查找main方法。方法名：main、方法描述符：([Ljava/lang/String;)V\n\n即：Void main(String[] xxx) {…}\n\n解释并执行main方法。\n\n线程Thread：\n\n// 线程\n\ntype Thread struct {\n\n  pc int\n\n  stack *Stack  // 线程的帧栈\n\n}\n\n \n\n// jvm栈\n\ntype Stack struct {\n\n  maxSize uint  // 最大大小\n\n  size uint      // 当前大小\n\n  _top *Frame  // 栈结构\n\n}\n\n \n\n// 帧\n\ntype Frame struct {\n\n  lower *Frame  // 下一个帧，栈结构。\n\n  localVars LocalVars // 局部变量表\n\n  operandStack *OperandStack  // 操作数栈\n\n  thread *Thread // 所属线程\n\n  nextPC int // the next instruction after the call\n\n}\n\n根据main()方法的CodeAttribute(属性表，名称Code，存储方法执行的字节码信息)，获取其中的最大局部变量大小、最大操作数栈大小，新建Frame实例，将Frame实例压入当前线程的执行帧栈。\n\nJVM会循环不停的从线程的帧栈中弹出帧Frame，执行Frame：\n\n1.1获取frame要执行的指令编号NextPC\n\n1.2将NextPC设置到thread的pc\n\n2.1解码code，根据pc从CodeAttribute中的code(byte[]结构)解码\n\n2.2先获取8bit操作指令，根据指令新建指令实例。\n\n共分为11类：常量（constants）指令、加载（loads）指令、存储（stores）指令、\n操作数栈（stack）指令、数学（math）指令、转换（conversions）指令、比\n较（comparisons）指令、控制（control）指令、引用（references）指令、\n扩展（extended）指令和保留（reserved）指令。\n\n如：iconst_0，istore_1，iload_1，iinc{}，if_icmple，_goto，swap，i2b等。\n\n2.3从属性表的code获取操作数，不同的指令具体实现。\n\n如if_icmpeq指令，如果比较值相等则跳转，其中的跳转地址需要在方法属性表code中获取，读取code(byte[]结构)的下16位为跳转的偏移地址。\n\n2.4设置frame的NextPC为code的pc，即记录code读取到哪个位置。\n\n2.5执行指令实例，不同的指令具体实现。\n\n如if_icmpeq指令，从帧的操作数栈中，弹出两个int值，比较两个值，如果相等，则设置帧frame的NextPC为 当前线程的pc + 偏移量（步骤2.3从code属性表中读取）。\n\n重复1.1执行\n\n上面是一个帧Frame完整的执行流程。\n\n### **上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。**\n\n## 完整流程：\n\n1.解析环境变量\n2.类加载器\n3.解析主类名\n4.加载主类\n加载类流程：内存中是否已加载该类，没有的话加载类\n一、解析：\n读取class文件字节码，解析\n生成虚拟机可用的类数据，放入方法区。类数据：类基本信息、常量池、字段、方法、父类、接口、静态变量等信息。\n加载类的时候会递归加载类的父类和接口。\n二、链接：\n1验证\n2准备\n计算实例字段的个数\n计算静态字段的个数\n分配并初始化静态变量，设置常量的值（字段信息里有常量指向的常量池的索引）\n\n5.主类加载完成后，找到主入口方法main\n6.解释执行main方法\n\n## 方法的调用过程：\n\n## invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\n\n 类初始化\n\n \n\n \n\n# 笔记：\n\n1.搜索class文件\n\n1.hello world为例，加载前需要加载超类**java.lang.Object**，在调用main()方法前，虚拟机需要准备好参数数组，加载**java.lang.String**和**java.lang.String[]**，打印需要加载**java.lang.System**类。\n\n2.类路径：启动类路径（bootstrap classpath）jre\\lib、\n\n扩展类路径（extension classpath） jre\\lib\\ext、\n\n用户类路径（user classpath）-classpath或-cp指定，使用系统分隔符指定多个路径。\n\n2.解析class文件\n\n1.class文件的基本数据单位是字节，数据在class文件中以大端(big-endian)方式存储。\n\n","source":"_posts/jvm-self.md","raw":"---\ntitle: 自己动手写JVM\ndate: 2019-02-27 19:40:56\ntags:\n  - 笔记\nid: jvm-self\ncategories:\n  - 笔记\n---\n\n根据《自己动手写Java虚拟机》一书\n\n![自己动手写JVM - 第1张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/cover-300x179.png?resize=300%2C179)\n\n## 实现的go代码在GitHub中：[QJvm](https://github.com/zhangga/QJvm)\n\n## 可视化查看class文件的工具：[查看class工具](https://github.com/zxh0/classpy)，启动类：ClasspyApp。书籍自身代码：[代码](https://github.com/zxh0/jvmgo-book)\n\n \n\n# Class文件解析：\n\n![自己动手写JVM - 第2张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/22.png?resize=640%2C484)\n\n如上图所示：\n\n常量池解析：\n\n1.读取16位的常量池大小cp_count。\n\n2.索引从1到cp_count-1，依次读取常量信息。\n\n3.常量信息有tag(8bit)表示常量类型。不同的类型读取数据方式不同。\n\n// 常量池类型\n\nconst (\n\n  CONSTANT_Class = 7\n\n  CONSTANT_Fieldref = 9\n\n  CONSTANT_Methodref = 10\n\n  CONSTANT_InterfaceMethodref = 11\n\n  CONSTANT_String = 8\n\n  CONSTANT_Integer = 3\n\n  CONSTANT_Float = 4\n\n  CONSTANT_Long = 5\n\n  CONSTANT_Double = 6\n\n  CONSTANT_NameAndType = 12\n\n  CONSTANT_Utf8 = 1\n\n  CONSTANT_MethodHandle = 15\n\n  CONSTANT_MethodType = 16\n\n  CONSTANT_InvokeDynamic = 18\n\n)\n\n![自己动手写JVM - 第3张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/23.png?resize=640%2C490)\n\n常量池类型可分为下面几大类：\n\n| 类型         | 说明             | 具体代表类型           | class存储格式                                                |\n| ------------ | ---------------- | ---------------------- | ------------------------------------------------------------ |\n| numeric      | 数值型           | int/float/double等     | tag(8bit)+数值(具体类型决定)                                 |\n| string       | 指向字符串       | string                 | tag(8bit)+指向utf8字符串的索引(16bit)                        |\n| utf8         | 字符串           | string                 | tag(8bit)+length(16b)+bytes(length)                          |\n| class        | 类信息           | class                  | tag(8bit)+指向utf8字符串的索引(16bit)                        |\n| name&type    | 名字和描述(参数) | 字段、方法的名称和描述 | tag(8bit)+指向name字符串索引(16bit)+指向描述字符串的索引(16bit) |\n| member       | 成员信息         | 字段、方法、接口信息等 | tag(8bit)+指向class索引(16bit)+指向name&type的索引(16bit)    |\n| methodType   | 方法描述         | 方法                   | tag(8bit)+指向描述字符串的索引(16bit)                        |\n| methodHandle | 方法句柄         | 方法句柄               | tag(8bit)+refKind(8b)+指向引用ref的索引(16b)                 |\n| dynamic      | 动态调用         | Lambda表达式           | tag(8bit)+指定启动方法的索引(16b指向属性表)+指向name&type的索引(16b) |\n\n# 动态调用：CONSTANT_InvokeDynamic_info\n\n为了更好的支持[动态类型语言](http://en.wikipedia.org/wiki/Dynamic_typing#DYNAMIC)，[Java7](https://www.baidu.com/s?wd=Java7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)通过[JSR292](https://jcp.org/en/jsr/detail?id=292)给JVM增加了一条新的字节码指令：invokedynamic。Java8的Lambda表达式。\n\n以下面代码为例：\n\n![自己动手写JVM - 第4张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/24.png?resize=640%2C239)\n\n使用javap -v -p指令反编译生成的class文件，找到main方法，可以看到生成了一条indy指令\n\n![自己动手写JVM - 第5张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/25.png?resize=640%2C223)\n\n指向常量池索引为#2，查看常量池可知，确实是一个CONSTANT_InvokeDynamic_info\n\nCONSTANT_InvokeDynamic_info {\n\n  u1 tag;\n\n  u2 bootstrap_method_attr_index;\n\n  u2 name_and_type_index;\n\n}\n\n![自己动手写JVM - 第6张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/26.png?resize=640%2C89)\n\n可以看到有两个参数即我们上面表中总结的参数分别为：\n\n指定启动方法的索引(16b指向属性表)+指向name&type的索引(16b)\n\n先看name&type\n\n![自己动手写JVM - 第7张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/35.png?resize=640%2C125)\n\n它描述的是这样的一个方法：\n\nRunnable run() {…}\n\n再看bootstrap_method_attr_index\n\n[JVM规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21)规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定**有且仅有一个**BootstrapMethods属性。BootstrapMethods属性是个变长的表，结构如下所示：\n\nBootstrapMethods_attribute {\nu2 attribute_name_index;\nu4 attribute_length;\nu2 num_bootstrap_methods;\n{   u2 bootstrap_method_ref;\nu2 num_bootstrap_arguments;\nu2 bootstrap_arguments[num_bootstrap_arguments];\n} bootstrap_methods[num_bootstrap_methods];\n}\n每一个BootstrapMethod都包含一个bootstrap_method_ref和n个bootstrap_arguments。bootstrap_method_ref是个常量池索引，指向一个CONSTANT_MethodHandle_info。而每一个bootstrap_argument也都是常量池索引，可以指向下面这些结构：\n\n- CONSTANT_String_info\n- CONSTANT_Class_info\n- CONSTANT_Integer_info\n- CONSTANT_Long_info\n- CONSTANT_Float_info\n- CONSTANT_Double_info\n- CONSTANT_MethodHandle_info\n- CONSTANT_MethodType_info\n\n本例中的启动方法反编译图：\n\n![自己动手写JVM - 第8张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/28.png?resize=640%2C132)\n\n确实存在一个BootstrapMethods表，这个表中只有一个BootstrapMethod，它的bootstrap_method_ref是常量池#23，有三个bootstrap_arguments，分别指向常量池#24，#25，#24：\n\n![自己动手写JVM - 第9张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/30.png?resize=640%2C76)\n\n## CONSTANT_MethodHandle_info\n\n[CONSTANT_MethodHandle_info](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8)结构包含两项信息，其结构参考上面表格。\n\n \n\nreference_kind是一个1到9之间的整数，具体含义可以参考[JVM规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5)。reference_index是常量池索引，但具体索引的是什么类型的常量，需要看reference_kind：\n\n| constant_pool entry              | reference_kind                                               |\n| -------------------------------- | ------------------------------------------------------------ |\n| CONSTANT_Fieldref_info           | 1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField), or 4 (REF_putStatic) |\n| CONSTANT_Methodref_info          | 5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial), or 8 (REF_newInvokeSpecial) |\n| CONSTANT_InterfaceMethodref_info | 9 (REF_invokeInterface)                                      |\n\n通过观察常量池#23（上图中可以看到）可以看到，它的reference_kind是6（REF_invokeStatic），reference_index是#29，正好是个CONSTANT_Methodref_info：\n\n![自己动手写JVM - 第10张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/32.png?resize=640%2C130)\n\n引用的是java.lang.invoke.LambdaMetafactory类的静态方法metafactory()。\n\n引用关系图：\n\n![自己动手写JVM - 第11张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/33.png?resize=640%2C545)\n\nJVM如何执行indy指令\n前面从class文件的角度，分析了indy指令。下面让我们看看JVM是如何执行indy指令的。\n\n- 每一个indy指令出现的地方，都叫做一个dynamic call site（动态调用点）\n- 根据indy指令的操作数，可以找到一个call site specifier（调用点说明符），根据前面的分析，这个说明符其实就常量池里的CONSTANT_InvokeDynamic_info\n- JVM解析（resolve）调用点说明符，得到下面三种信息：\n\n1.一个MethodHandle，指向**bootstrap method**（启动方法）\n\n2.方法名和方法描述，表示动态调用的方法\n\n3.其他提供给启动方法的参数\n\n- 接着JVM调用启动方法，并把上一步提到的信息通过参数传给启动方法\n- 启动方法必须返回一个**CallSite**对象，并且，这个CallSite对象将永久和这个动态调用点关联\n- 调用跟CallSite关联的MethodHandle指向的方法\n\n \n\n下面是一张示意图，画出了关键点：\n\n![自己动手写JVM - 第12张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/31-1.png?resize=640%2C227)\n\n接着回到我们上面的常量池解析，注意ConstantLongInfo和ConstantDoubleInfo在常量池占两个位置。至此常量池解析完成。\n\n接着class文件中存放的是类访问标识。\n\n然后是类，超类，接口信息。都是常量池索引。\n\n然后字段表和方法表，这俩读取方式一样，以方法表为例：\n\n1.读取16位的方法个数，member_count\n\n2.依次读取member_count个方法信息：\n\n访问标识(16bit)、名称索引(16bit指向常量池)、描述符索引(16bit指向常量池)、读取方法关联的属性表。\n\n最后读取class文件的属性表Attributes。\n\n1.读取16位的属性个数，attributes_count\n\n2.依次读取attributes_count个属性信息：\n\n属性名索引(指向常量池的UTF8)、属性长度(32bit)，\n\n根据属性名和长度新建JVM实现的属性实例。\n\nJava虚拟机规范预定义了23种属性，可分为三组。\n\n一、Java虚拟机必须的，5种。\n\n二、Java类库必须的，12种。\n\n三、提供给工具使用的，6种。可选的。\n\n例：Code、ConstantValue、Exceptions、LineNumberTable、LocalVariableTable、SourceFile、Synthetic等\n\n至此class文件解析完成。\n\n \n\n# 线程启动：\n\n从启动类中查找main方法。方法名：main、方法描述符：([Ljava/lang/String;)V\n\n即：Void main(String[] xxx) {…}\n\n解释并执行main方法。\n\n线程Thread：\n\n// 线程\n\ntype Thread struct {\n\n  pc int\n\n  stack *Stack  // 线程的帧栈\n\n}\n\n \n\n// jvm栈\n\ntype Stack struct {\n\n  maxSize uint  // 最大大小\n\n  size uint      // 当前大小\n\n  _top *Frame  // 栈结构\n\n}\n\n \n\n// 帧\n\ntype Frame struct {\n\n  lower *Frame  // 下一个帧，栈结构。\n\n  localVars LocalVars // 局部变量表\n\n  operandStack *OperandStack  // 操作数栈\n\n  thread *Thread // 所属线程\n\n  nextPC int // the next instruction after the call\n\n}\n\n根据main()方法的CodeAttribute(属性表，名称Code，存储方法执行的字节码信息)，获取其中的最大局部变量大小、最大操作数栈大小，新建Frame实例，将Frame实例压入当前线程的执行帧栈。\n\nJVM会循环不停的从线程的帧栈中弹出帧Frame，执行Frame：\n\n1.1获取frame要执行的指令编号NextPC\n\n1.2将NextPC设置到thread的pc\n\n2.1解码code，根据pc从CodeAttribute中的code(byte[]结构)解码\n\n2.2先获取8bit操作指令，根据指令新建指令实例。\n\n共分为11类：常量（constants）指令、加载（loads）指令、存储（stores）指令、\n操作数栈（stack）指令、数学（math）指令、转换（conversions）指令、比\n较（comparisons）指令、控制（control）指令、引用（references）指令、\n扩展（extended）指令和保留（reserved）指令。\n\n如：iconst_0，istore_1，iload_1，iinc{}，if_icmple，_goto，swap，i2b等。\n\n2.3从属性表的code获取操作数，不同的指令具体实现。\n\n如if_icmpeq指令，如果比较值相等则跳转，其中的跳转地址需要在方法属性表code中获取，读取code(byte[]结构)的下16位为跳转的偏移地址。\n\n2.4设置frame的NextPC为code的pc，即记录code读取到哪个位置。\n\n2.5执行指令实例，不同的指令具体实现。\n\n如if_icmpeq指令，从帧的操作数栈中，弹出两个int值，比较两个值，如果相等，则设置帧frame的NextPC为 当前线程的pc + 偏移量（步骤2.3从code属性表中读取）。\n\n重复1.1执行\n\n上面是一个帧Frame完整的执行流程。\n\n### **上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。**\n\n## 完整流程：\n\n1.解析环境变量\n2.类加载器\n3.解析主类名\n4.加载主类\n加载类流程：内存中是否已加载该类，没有的话加载类\n一、解析：\n读取class文件字节码，解析\n生成虚拟机可用的类数据，放入方法区。类数据：类基本信息、常量池、字段、方法、父类、接口、静态变量等信息。\n加载类的时候会递归加载类的父类和接口。\n二、链接：\n1验证\n2准备\n计算实例字段的个数\n计算静态字段的个数\n分配并初始化静态变量，设置常量的值（字段信息里有常量指向的常量池的索引）\n\n5.主类加载完成后，找到主入口方法main\n6.解释执行main方法\n\n## 方法的调用过程：\n\n## invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\n\n 类初始化\n\n \n\n \n\n# 笔记：\n\n1.搜索class文件\n\n1.hello world为例，加载前需要加载超类**java.lang.Object**，在调用main()方法前，虚拟机需要准备好参数数组，加载**java.lang.String**和**java.lang.String[]**，打印需要加载**java.lang.System**类。\n\n2.类路径：启动类路径（bootstrap classpath）jre\\lib、\n\n扩展类路径（extension classpath） jre\\lib\\ext、\n\n用户类路径（user classpath）-classpath或-cp指定，使用系统分隔符指定多个路径。\n\n2.解析class文件\n\n1.class文件的基本数据单位是字节，数据在class文件中以大端(big-endian)方式存储。\n\n","slug":"jvm-self","published":1,"updated":"2021-09-01T11:43:11.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lju000thcmn64bufrtl","content":"<p>根据《自己动手写Java虚拟机》一书</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/cover-300x179.png?resize=300,179\" alt=\"自己动手写JVM - 第1张  | 张嘎\"></p>\n<h2 id=\"实现的go代码在GitHub中：QJvm\"><a href=\"#实现的go代码在GitHub中：QJvm\" class=\"headerlink\" title=\"实现的go代码在GitHub中：QJvm\"></a>实现的go代码在GitHub中：<a href=\"https://github.com/zhangga/QJvm\">QJvm</a></h2><h2 id=\"可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码\"><a href=\"#可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码\" class=\"headerlink\" title=\"可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码\"></a>可视化查看class文件的工具：<a href=\"https://github.com/zxh0/classpy\">查看class工具</a>，启动类：ClasspyApp。书籍自身代码：<a href=\"https://github.com/zxh0/jvmgo-book\">代码</a></h2><h1 id=\"Class文件解析：\"><a href=\"#Class文件解析：\" class=\"headerlink\" title=\"Class文件解析：\"></a>Class文件解析：</h1><p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/22.png?resize=640,484\" alt=\"自己动手写JVM - 第2张  | 张嘎\"></p>\n<p>如上图所示：</p>\n<p>常量池解析：</p>\n<p>1.读取16位的常量池大小cp_count。</p>\n<p>2.索引从1到cp_count-1，依次读取常量信息。</p>\n<p>3.常量信息有tag(8bit)表示常量类型。不同的类型读取数据方式不同。</p>\n<p>// 常量池类型</p>\n<p>const (</p>\n<p>  CONSTANT_Class = 7</p>\n<p>  CONSTANT_Fieldref = 9</p>\n<p>  CONSTANT_Methodref = 10</p>\n<p>  CONSTANT_InterfaceMethodref = 11</p>\n<p>  CONSTANT_String = 8</p>\n<p>  CONSTANT_Integer = 3</p>\n<p>  CONSTANT_Float = 4</p>\n<p>  CONSTANT_Long = 5</p>\n<p>  CONSTANT_Double = 6</p>\n<p>  CONSTANT_NameAndType = 12</p>\n<p>  CONSTANT_Utf8 = 1</p>\n<p>  CONSTANT_MethodHandle = 15</p>\n<p>  CONSTANT_MethodType = 16</p>\n<p>  CONSTANT_InvokeDynamic = 18</p>\n<p>)</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/23.png?resize=640,490\" alt=\"自己动手写JVM - 第3张  | 张嘎\"></p>\n<p>常量池类型可分为下面几大类：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>具体代表类型</th>\n<th>class存储格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>numeric</td>\n<td>数值型</td>\n<td>int/float/double等</td>\n<td>tag(8bit)+数值(具体类型决定)</td>\n</tr>\n<tr>\n<td>string</td>\n<td>指向字符串</td>\n<td>string</td>\n<td>tag(8bit)+指向utf8字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>utf8</td>\n<td>字符串</td>\n<td>string</td>\n<td>tag(8bit)+length(16b)+bytes(length)</td>\n</tr>\n<tr>\n<td>class</td>\n<td>类信息</td>\n<td>class</td>\n<td>tag(8bit)+指向utf8字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>name&amp;type</td>\n<td>名字和描述(参数)</td>\n<td>字段、方法的名称和描述</td>\n<td>tag(8bit)+指向name字符串索引(16bit)+指向描述字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>member</td>\n<td>成员信息</td>\n<td>字段、方法、接口信息等</td>\n<td>tag(8bit)+指向class索引(16bit)+指向name&amp;type的索引(16bit)</td>\n</tr>\n<tr>\n<td>methodType</td>\n<td>方法描述</td>\n<td>方法</td>\n<td>tag(8bit)+指向描述字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>methodHandle</td>\n<td>方法句柄</td>\n<td>方法句柄</td>\n<td>tag(8bit)+refKind(8b)+指向引用ref的索引(16b)</td>\n</tr>\n<tr>\n<td>dynamic</td>\n<td>动态调用</td>\n<td>Lambda表达式</td>\n<td>tag(8bit)+指定启动方法的索引(16b指向属性表)+指向name&amp;type的索引(16b)</td>\n</tr>\n</tbody></table>\n<h1 id=\"动态调用：CONSTANT-InvokeDynamic-info\"><a href=\"#动态调用：CONSTANT-InvokeDynamic-info\" class=\"headerlink\" title=\"动态调用：CONSTANT_InvokeDynamic_info\"></a>动态调用：CONSTANT_InvokeDynamic_info</h1><p>为了更好的支持<a href=\"http://en.wikipedia.org/wiki/Dynamic_typing#DYNAMIC\">动态类型语言</a>，<a href=\"https://www.baidu.com/s?wd=Java7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd\">Java7</a>通过<a href=\"https://jcp.org/en/jsr/detail?id=292\">JSR292</a>给JVM增加了一条新的字节码指令：invokedynamic。Java8的Lambda表达式。</p>\n<p>以下面代码为例：</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/24.png?resize=640,239\" alt=\"自己动手写JVM - 第4张  | 张嘎\"></p>\n<p>使用javap -v -p指令反编译生成的class文件，找到main方法，可以看到生成了一条indy指令</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/25.png?resize=640,223\" alt=\"自己动手写JVM - 第5张  | 张嘎\"></p>\n<p>指向常量池索引为#2，查看常量池可知，确实是一个CONSTANT_InvokeDynamic_info</p>\n<p>CONSTANT_InvokeDynamic_info {</p>\n<p>  u1 tag;</p>\n<p>  u2 bootstrap_method_attr_index;</p>\n<p>  u2 name_and_type_index;</p>\n<p>}</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/26.png?resize=640,89\" alt=\"自己动手写JVM - 第6张  | 张嘎\"></p>\n<p>可以看到有两个参数即我们上面表中总结的参数分别为：</p>\n<p>指定启动方法的索引(16b指向属性表)+指向name&amp;type的索引(16b)</p>\n<p>先看name&amp;type</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/35.png?resize=640,125\" alt=\"自己动手写JVM - 第7张  | 张嘎\"></p>\n<p>它描述的是这样的一个方法：</p>\n<p>Runnable run() {…}</p>\n<p>再看bootstrap_method_attr_index</p>\n<p><a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21\">JVM规范</a>规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定<strong>有且仅有一个</strong>BootstrapMethods属性。BootstrapMethods属性是个变长的表，结构如下所示：</p>\n<p>BootstrapMethods_attribute {<br>u2 attribute_name_index;<br>u4 attribute_length;<br>u2 num_bootstrap_methods;<br>{   u2 bootstrap_method_ref;<br>u2 num_bootstrap_arguments;<br>u2 bootstrap_arguments[num_bootstrap_arguments];<br>} bootstrap_methods[num_bootstrap_methods];<br>}<br>每一个BootstrapMethod都包含一个bootstrap_method_ref和n个bootstrap_arguments。bootstrap_method_ref是个常量池索引，指向一个CONSTANT_MethodHandle_info。而每一个bootstrap_argument也都是常量池索引，可以指向下面这些结构：</p>\n<ul>\n<li>CONSTANT_String_info</li>\n<li>CONSTANT_Class_info</li>\n<li>CONSTANT_Integer_info</li>\n<li>CONSTANT_Long_info</li>\n<li>CONSTANT_Float_info</li>\n<li>CONSTANT_Double_info</li>\n<li>CONSTANT_MethodHandle_info</li>\n<li>CONSTANT_MethodType_info</li>\n</ul>\n<p>本例中的启动方法反编译图：</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/28.png?resize=640,132\" alt=\"自己动手写JVM - 第8张  | 张嘎\"></p>\n<p>确实存在一个BootstrapMethods表，这个表中只有一个BootstrapMethod，它的bootstrap_method_ref是常量池#23，有三个bootstrap_arguments，分别指向常量池#24，#25，#24：</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/30.png?resize=640,76\" alt=\"自己动手写JVM - 第9张  | 张嘎\"></p>\n<h2 id=\"CONSTANT-MethodHandle-info\"><a href=\"#CONSTANT-MethodHandle-info\" class=\"headerlink\" title=\"CONSTANT_MethodHandle_info\"></a>CONSTANT_MethodHandle_info</h2><p><a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8\">CONSTANT_MethodHandle_info</a>结构包含两项信息，其结构参考上面表格。</p>\n<p>reference_kind是一个1到9之间的整数，具体含义可以参考<a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5\">JVM规范</a>。reference_index是常量池索引，但具体索引的是什么类型的常量，需要看reference_kind：</p>\n<table>\n<thead>\n<tr>\n<th>constant_pool entry</th>\n<th>reference_kind</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONSTANT_Fieldref_info</td>\n<td>1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField), or 4 (REF_putStatic)</td>\n</tr>\n<tr>\n<td>CONSTANT_Methodref_info</td>\n<td>5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial), or 8 (REF_newInvokeSpecial)</td>\n</tr>\n<tr>\n<td>CONSTANT_InterfaceMethodref_info</td>\n<td>9 (REF_invokeInterface)</td>\n</tr>\n</tbody></table>\n<p>通过观察常量池#23（上图中可以看到）可以看到，它的reference_kind是6（REF_invokeStatic），reference_index是#29，正好是个CONSTANT_Methodref_info：</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/32.png?resize=640,130\" alt=\"自己动手写JVM - 第10张  | 张嘎\"></p>\n<p>引用的是java.lang.invoke.LambdaMetafactory类的静态方法metafactory()。</p>\n<p>引用关系图：</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/33.png?resize=640,545\" alt=\"自己动手写JVM - 第11张  | 张嘎\"></p>\n<p>JVM如何执行indy指令<br>前面从class文件的角度，分析了indy指令。下面让我们看看JVM是如何执行indy指令的。</p>\n<ul>\n<li>每一个indy指令出现的地方，都叫做一个dynamic call site（动态调用点）</li>\n<li>根据indy指令的操作数，可以找到一个call site specifier（调用点说明符），根据前面的分析，这个说明符其实就常量池里的CONSTANT_InvokeDynamic_info</li>\n<li>JVM解析（resolve）调用点说明符，得到下面三种信息：</li>\n</ul>\n<p>1.一个MethodHandle，指向<strong>bootstrap method</strong>（启动方法）</p>\n<p>2.方法名和方法描述，表示动态调用的方法</p>\n<p>3.其他提供给启动方法的参数</p>\n<ul>\n<li>接着JVM调用启动方法，并把上一步提到的信息通过参数传给启动方法</li>\n<li>启动方法必须返回一个<strong>CallSite</strong>对象，并且，这个CallSite对象将永久和这个动态调用点关联</li>\n<li>调用跟CallSite关联的MethodHandle指向的方法</li>\n</ul>\n<p>下面是一张示意图，画出了关键点：</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/31-1.png?resize=640,227\" alt=\"自己动手写JVM - 第12张  | 张嘎\"></p>\n<p>接着回到我们上面的常量池解析，注意ConstantLongInfo和ConstantDoubleInfo在常量池占两个位置。至此常量池解析完成。</p>\n<p>接着class文件中存放的是类访问标识。</p>\n<p>然后是类，超类，接口信息。都是常量池索引。</p>\n<p>然后字段表和方法表，这俩读取方式一样，以方法表为例：</p>\n<p>1.读取16位的方法个数，member_count</p>\n<p>2.依次读取member_count个方法信息：</p>\n<p>访问标识(16bit)、名称索引(16bit指向常量池)、描述符索引(16bit指向常量池)、读取方法关联的属性表。</p>\n<p>最后读取class文件的属性表Attributes。</p>\n<p>1.读取16位的属性个数，attributes_count</p>\n<p>2.依次读取attributes_count个属性信息：</p>\n<p>属性名索引(指向常量池的UTF8)、属性长度(32bit)，</p>\n<p>根据属性名和长度新建JVM实现的属性实例。</p>\n<p>Java虚拟机规范预定义了23种属性，可分为三组。</p>\n<p>一、Java虚拟机必须的，5种。</p>\n<p>二、Java类库必须的，12种。</p>\n<p>三、提供给工具使用的，6种。可选的。</p>\n<p>例：Code、ConstantValue、Exceptions、LineNumberTable、LocalVariableTable、SourceFile、Synthetic等</p>\n<p>至此class文件解析完成。</p>\n<h1 id=\"线程启动：\"><a href=\"#线程启动：\" class=\"headerlink\" title=\"线程启动：\"></a>线程启动：</h1><p>从启动类中查找main方法。方法名：main、方法描述符：([Ljava/lang/String;)V</p>\n<p>即：Void main(String[] xxx) {…}</p>\n<p>解释并执行main方法。</p>\n<p>线程Thread：</p>\n<p>// 线程</p>\n<p>type Thread struct {</p>\n<p>  pc int</p>\n<p>  stack *Stack  // 线程的帧栈</p>\n<p>}</p>\n<p>// jvm栈</p>\n<p>type Stack struct {</p>\n<p>  maxSize uint  // 最大大小</p>\n<p>  size uint      // 当前大小</p>\n<p>  _top *Frame  // 栈结构</p>\n<p>}</p>\n<p>// 帧</p>\n<p>type Frame struct {</p>\n<p>  lower *Frame  // 下一个帧，栈结构。</p>\n<p>  localVars LocalVars // 局部变量表</p>\n<p>  operandStack *OperandStack  // 操作数栈</p>\n<p>  thread *Thread // 所属线程</p>\n<p>  nextPC int // the next instruction after the call</p>\n<p>}</p>\n<p>根据main()方法的CodeAttribute(属性表，名称Code，存储方法执行的字节码信息)，获取其中的最大局部变量大小、最大操作数栈大小，新建Frame实例，将Frame实例压入当前线程的执行帧栈。</p>\n<p>JVM会循环不停的从线程的帧栈中弹出帧Frame，执行Frame：</p>\n<p>1.1获取frame要执行的指令编号NextPC</p>\n<p>1.2将NextPC设置到thread的pc</p>\n<p>2.1解码code，根据pc从CodeAttribute中的code(byte[]结构)解码</p>\n<p>2.2先获取8bit操作指令，根据指令新建指令实例。</p>\n<p>共分为11类：常量（constants）指令、加载（loads）指令、存储（stores）指令、<br>操作数栈（stack）指令、数学（math）指令、转换（conversions）指令、比<br>较（comparisons）指令、控制（control）指令、引用（references）指令、<br>扩展（extended）指令和保留（reserved）指令。</p>\n<p>如：iconst_0，istore_1，iload_1，iinc{}，if_icmple，_goto，swap，i2b等。</p>\n<p>2.3从属性表的code获取操作数，不同的指令具体实现。</p>\n<p>如if_icmpeq指令，如果比较值相等则跳转，其中的跳转地址需要在方法属性表code中获取，读取code(byte[]结构)的下16位为跳转的偏移地址。</p>\n<p>2.4设置frame的NextPC为code的pc，即记录code读取到哪个位置。</p>\n<p>2.5执行指令实例，不同的指令具体实现。</p>\n<p>如if_icmpeq指令，从帧的操作数栈中，弹出两个int值，比较两个值，如果相等，则设置帧frame的NextPC为 当前线程的pc + 偏移量（步骤2.3从code属性表中读取）。</p>\n<p>重复1.1执行</p>\n<p>上面是一个帧Frame完整的执行流程。</p>\n<h3 id=\"上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。\"><a href=\"#上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。\" class=\"headerlink\" title=\"上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。\"></a><strong>上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。</strong></h3><h2 id=\"完整流程：\"><a href=\"#完整流程：\" class=\"headerlink\" title=\"完整流程：\"></a>完整流程：</h2><p>1.解析环境变量<br>2.类加载器<br>3.解析主类名<br>4.加载主类<br>加载类流程：内存中是否已加载该类，没有的话加载类<br>一、解析：<br>读取class文件字节码，解析<br>生成虚拟机可用的类数据，放入方法区。类数据：类基本信息、常量池、字段、方法、父类、接口、静态变量等信息。<br>加载类的时候会递归加载类的父类和接口。<br>二、链接：<br>1验证<br>2准备<br>计算实例字段的个数<br>计算静态字段的个数<br>分配并初始化静态变量，设置常量的值（字段信息里有常量指向的常量池的索引）</p>\n<p>5.主类加载完成后，找到主入口方法main<br>6.解释执行main方法</p>\n<h2 id=\"方法的调用过程：\"><a href=\"#方法的调用过程：\" class=\"headerlink\" title=\"方法的调用过程：\"></a>方法的调用过程：</h2><h2 id=\"invokeinterface-invokespecial-invokestatic-invokevirtual-1-创建帧（帧的主要组成是Method），将帧推入栈顶，-2-将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。-3-主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。-4-return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\"><a href=\"#invokeinterface-invokespecial-invokestatic-invokevirtual-1-创建帧（帧的主要组成是Method），将帧推入栈顶，-2-将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。-3-主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。-4-return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\" class=\"headerlink\" title=\"invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\"></a>invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。</h2><p> 类初始化</p>\n<h1 id=\"笔记：\"><a href=\"#笔记：\" class=\"headerlink\" title=\"笔记：\"></a>笔记：</h1><p>1.搜索class文件</p>\n<p>1.hello world为例，加载前需要加载超类<strong>java.lang.Object</strong>，在调用main()方法前，虚拟机需要准备好参数数组，加载<strong>java.lang.String</strong>和<strong>java.lang.String[]<strong>，打印需要加载</strong>java.lang.System</strong>类。</p>\n<p>2.类路径：启动类路径（bootstrap classpath）jre\\lib、</p>\n<p>扩展类路径（extension classpath） jre\\lib\\ext、</p>\n<p>用户类路径（user classpath）-classpath或-cp指定，使用系统分隔符指定多个路径。</p>\n<p>2.解析class文件</p>\n<p>1.class文件的基本数据单位是字节，数据在class文件中以大端(big-endian)方式存储。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>根据《自己动手写Java虚拟机》一书</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/cover-300x179.png?resize=300,179\" alt=\"自己动手写JVM - 第1张  | 张嘎\"></p>\n<h2 id=\"实现的go代码在GitHub中：QJvm\"><a href=\"#实现的go代码在GitHub中：QJvm\" class=\"headerlink\" title=\"实现的go代码在GitHub中：QJvm\"></a>实现的go代码在GitHub中：<a href=\"https://github.com/zhangga/QJvm\">QJvm</a></h2><h2 id=\"可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码\"><a href=\"#可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码\" class=\"headerlink\" title=\"可视化查看class文件的工具：查看class工具，启动类：ClasspyApp。书籍自身代码：代码\"></a>可视化查看class文件的工具：<a href=\"https://github.com/zxh0/classpy\">查看class工具</a>，启动类：ClasspyApp。书籍自身代码：<a href=\"https://github.com/zxh0/jvmgo-book\">代码</a></h2><h1 id=\"Class文件解析：\"><a href=\"#Class文件解析：\" class=\"headerlink\" title=\"Class文件解析：\"></a>Class文件解析：</h1><p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/22.png?resize=640,484\" alt=\"自己动手写JVM - 第2张  | 张嘎\"></p>\n<p>如上图所示：</p>\n<p>常量池解析：</p>\n<p>1.读取16位的常量池大小cp_count。</p>\n<p>2.索引从1到cp_count-1，依次读取常量信息。</p>\n<p>3.常量信息有tag(8bit)表示常量类型。不同的类型读取数据方式不同。</p>\n<p>// 常量池类型</p>\n<p>const (</p>\n<p>  CONSTANT_Class = 7</p>\n<p>  CONSTANT_Fieldref = 9</p>\n<p>  CONSTANT_Methodref = 10</p>\n<p>  CONSTANT_InterfaceMethodref = 11</p>\n<p>  CONSTANT_String = 8</p>\n<p>  CONSTANT_Integer = 3</p>\n<p>  CONSTANT_Float = 4</p>\n<p>  CONSTANT_Long = 5</p>\n<p>  CONSTANT_Double = 6</p>\n<p>  CONSTANT_NameAndType = 12</p>\n<p>  CONSTANT_Utf8 = 1</p>\n<p>  CONSTANT_MethodHandle = 15</p>\n<p>  CONSTANT_MethodType = 16</p>\n<p>  CONSTANT_InvokeDynamic = 18</p>\n<p>)</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/23.png?resize=640,490\" alt=\"自己动手写JVM - 第3张  | 张嘎\"></p>\n<p>常量池类型可分为下面几大类：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>具体代表类型</th>\n<th>class存储格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>numeric</td>\n<td>数值型</td>\n<td>int/float/double等</td>\n<td>tag(8bit)+数值(具体类型决定)</td>\n</tr>\n<tr>\n<td>string</td>\n<td>指向字符串</td>\n<td>string</td>\n<td>tag(8bit)+指向utf8字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>utf8</td>\n<td>字符串</td>\n<td>string</td>\n<td>tag(8bit)+length(16b)+bytes(length)</td>\n</tr>\n<tr>\n<td>class</td>\n<td>类信息</td>\n<td>class</td>\n<td>tag(8bit)+指向utf8字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>name&amp;type</td>\n<td>名字和描述(参数)</td>\n<td>字段、方法的名称和描述</td>\n<td>tag(8bit)+指向name字符串索引(16bit)+指向描述字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>member</td>\n<td>成员信息</td>\n<td>字段、方法、接口信息等</td>\n<td>tag(8bit)+指向class索引(16bit)+指向name&amp;type的索引(16bit)</td>\n</tr>\n<tr>\n<td>methodType</td>\n<td>方法描述</td>\n<td>方法</td>\n<td>tag(8bit)+指向描述字符串的索引(16bit)</td>\n</tr>\n<tr>\n<td>methodHandle</td>\n<td>方法句柄</td>\n<td>方法句柄</td>\n<td>tag(8bit)+refKind(8b)+指向引用ref的索引(16b)</td>\n</tr>\n<tr>\n<td>dynamic</td>\n<td>动态调用</td>\n<td>Lambda表达式</td>\n<td>tag(8bit)+指定启动方法的索引(16b指向属性表)+指向name&amp;type的索引(16b)</td>\n</tr>\n</tbody></table>\n<h1 id=\"动态调用：CONSTANT-InvokeDynamic-info\"><a href=\"#动态调用：CONSTANT-InvokeDynamic-info\" class=\"headerlink\" title=\"动态调用：CONSTANT_InvokeDynamic_info\"></a>动态调用：CONSTANT_InvokeDynamic_info</h1><p>为了更好的支持<a href=\"http://en.wikipedia.org/wiki/Dynamic_typing#DYNAMIC\">动态类型语言</a>，<a href=\"https://www.baidu.com/s?wd=Java7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd\">Java7</a>通过<a href=\"https://jcp.org/en/jsr/detail?id=292\">JSR292</a>给JVM增加了一条新的字节码指令：invokedynamic。Java8的Lambda表达式。</p>\n<p>以下面代码为例：</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/24.png?resize=640,239\" alt=\"自己动手写JVM - 第4张  | 张嘎\"></p>\n<p>使用javap -v -p指令反编译生成的class文件，找到main方法，可以看到生成了一条indy指令</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/25.png?resize=640,223\" alt=\"自己动手写JVM - 第5张  | 张嘎\"></p>\n<p>指向常量池索引为#2，查看常量池可知，确实是一个CONSTANT_InvokeDynamic_info</p>\n<p>CONSTANT_InvokeDynamic_info {</p>\n<p>  u1 tag;</p>\n<p>  u2 bootstrap_method_attr_index;</p>\n<p>  u2 name_and_type_index;</p>\n<p>}</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/26.png?resize=640,89\" alt=\"自己动手写JVM - 第6张  | 张嘎\"></p>\n<p>可以看到有两个参数即我们上面表中总结的参数分别为：</p>\n<p>指定启动方法的索引(16b指向属性表)+指向name&amp;type的索引(16b)</p>\n<p>先看name&amp;type</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/35.png?resize=640,125\" alt=\"自己动手写JVM - 第7张  | 张嘎\"></p>\n<p>它描述的是这样的一个方法：</p>\n<p>Runnable run() {…}</p>\n<p>再看bootstrap_method_attr_index</p>\n<p><a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21\">JVM规范</a>规定，如果类的常量池中存在CONSTANT_InvokeDynamic_info的话，那么attributes表中就必定<strong>有且仅有一个</strong>BootstrapMethods属性。BootstrapMethods属性是个变长的表，结构如下所示：</p>\n<p>BootstrapMethods_attribute {<br>u2 attribute_name_index;<br>u4 attribute_length;<br>u2 num_bootstrap_methods;<br>{   u2 bootstrap_method_ref;<br>u2 num_bootstrap_arguments;<br>u2 bootstrap_arguments[num_bootstrap_arguments];<br>} bootstrap_methods[num_bootstrap_methods];<br>}<br>每一个BootstrapMethod都包含一个bootstrap_method_ref和n个bootstrap_arguments。bootstrap_method_ref是个常量池索引，指向一个CONSTANT_MethodHandle_info。而每一个bootstrap_argument也都是常量池索引，可以指向下面这些结构：</p>\n<ul>\n<li>CONSTANT_String_info</li>\n<li>CONSTANT_Class_info</li>\n<li>CONSTANT_Integer_info</li>\n<li>CONSTANT_Long_info</li>\n<li>CONSTANT_Float_info</li>\n<li>CONSTANT_Double_info</li>\n<li>CONSTANT_MethodHandle_info</li>\n<li>CONSTANT_MethodType_info</li>\n</ul>\n<p>本例中的启动方法反编译图：</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/28.png?resize=640,132\" alt=\"自己动手写JVM - 第8张  | 张嘎\"></p>\n<p>确实存在一个BootstrapMethods表，这个表中只有一个BootstrapMethod，它的bootstrap_method_ref是常量池#23，有三个bootstrap_arguments，分别指向常量池#24，#25，#24：</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/30.png?resize=640,76\" alt=\"自己动手写JVM - 第9张  | 张嘎\"></p>\n<h2 id=\"CONSTANT-MethodHandle-info\"><a href=\"#CONSTANT-MethodHandle-info\" class=\"headerlink\" title=\"CONSTANT_MethodHandle_info\"></a>CONSTANT_MethodHandle_info</h2><p><a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8\">CONSTANT_MethodHandle_info</a>结构包含两项信息，其结构参考上面表格。</p>\n<p>reference_kind是一个1到9之间的整数，具体含义可以参考<a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.5\">JVM规范</a>。reference_index是常量池索引，但具体索引的是什么类型的常量，需要看reference_kind：</p>\n<table>\n<thead>\n<tr>\n<th>constant_pool entry</th>\n<th>reference_kind</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONSTANT_Fieldref_info</td>\n<td>1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField), or 4 (REF_putStatic)</td>\n</tr>\n<tr>\n<td>CONSTANT_Methodref_info</td>\n<td>5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial), or 8 (REF_newInvokeSpecial)</td>\n</tr>\n<tr>\n<td>CONSTANT_InterfaceMethodref_info</td>\n<td>9 (REF_invokeInterface)</td>\n</tr>\n</tbody></table>\n<p>通过观察常量池#23（上图中可以看到）可以看到，它的reference_kind是6（REF_invokeStatic），reference_index是#29，正好是个CONSTANT_Methodref_info：</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/32.png?resize=640,130\" alt=\"自己动手写JVM - 第10张  | 张嘎\"></p>\n<p>引用的是java.lang.invoke.LambdaMetafactory类的静态方法metafactory()。</p>\n<p>引用关系图：</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/33.png?resize=640,545\" alt=\"自己动手写JVM - 第11张  | 张嘎\"></p>\n<p>JVM如何执行indy指令<br>前面从class文件的角度，分析了indy指令。下面让我们看看JVM是如何执行indy指令的。</p>\n<ul>\n<li>每一个indy指令出现的地方，都叫做一个dynamic call site（动态调用点）</li>\n<li>根据indy指令的操作数，可以找到一个call site specifier（调用点说明符），根据前面的分析，这个说明符其实就常量池里的CONSTANT_InvokeDynamic_info</li>\n<li>JVM解析（resolve）调用点说明符，得到下面三种信息：</li>\n</ul>\n<p>1.一个MethodHandle，指向<strong>bootstrap method</strong>（启动方法）</p>\n<p>2.方法名和方法描述，表示动态调用的方法</p>\n<p>3.其他提供给启动方法的参数</p>\n<ul>\n<li>接着JVM调用启动方法，并把上一步提到的信息通过参数传给启动方法</li>\n<li>启动方法必须返回一个<strong>CallSite</strong>对象，并且，这个CallSite对象将永久和这个动态调用点关联</li>\n<li>调用跟CallSite关联的MethodHandle指向的方法</li>\n</ul>\n<p>下面是一张示意图，画出了关键点：</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/31-1.png?resize=640,227\" alt=\"自己动手写JVM - 第12张  | 张嘎\"></p>\n<p>接着回到我们上面的常量池解析，注意ConstantLongInfo和ConstantDoubleInfo在常量池占两个位置。至此常量池解析完成。</p>\n<p>接着class文件中存放的是类访问标识。</p>\n<p>然后是类，超类，接口信息。都是常量池索引。</p>\n<p>然后字段表和方法表，这俩读取方式一样，以方法表为例：</p>\n<p>1.读取16位的方法个数，member_count</p>\n<p>2.依次读取member_count个方法信息：</p>\n<p>访问标识(16bit)、名称索引(16bit指向常量池)、描述符索引(16bit指向常量池)、读取方法关联的属性表。</p>\n<p>最后读取class文件的属性表Attributes。</p>\n<p>1.读取16位的属性个数，attributes_count</p>\n<p>2.依次读取attributes_count个属性信息：</p>\n<p>属性名索引(指向常量池的UTF8)、属性长度(32bit)，</p>\n<p>根据属性名和长度新建JVM实现的属性实例。</p>\n<p>Java虚拟机规范预定义了23种属性，可分为三组。</p>\n<p>一、Java虚拟机必须的，5种。</p>\n<p>二、Java类库必须的，12种。</p>\n<p>三、提供给工具使用的，6种。可选的。</p>\n<p>例：Code、ConstantValue、Exceptions、LineNumberTable、LocalVariableTable、SourceFile、Synthetic等</p>\n<p>至此class文件解析完成。</p>\n<h1 id=\"线程启动：\"><a href=\"#线程启动：\" class=\"headerlink\" title=\"线程启动：\"></a>线程启动：</h1><p>从启动类中查找main方法。方法名：main、方法描述符：([Ljava/lang/String;)V</p>\n<p>即：Void main(String[] xxx) {…}</p>\n<p>解释并执行main方法。</p>\n<p>线程Thread：</p>\n<p>// 线程</p>\n<p>type Thread struct {</p>\n<p>  pc int</p>\n<p>  stack *Stack  // 线程的帧栈</p>\n<p>}</p>\n<p>// jvm栈</p>\n<p>type Stack struct {</p>\n<p>  maxSize uint  // 最大大小</p>\n<p>  size uint      // 当前大小</p>\n<p>  _top *Frame  // 栈结构</p>\n<p>}</p>\n<p>// 帧</p>\n<p>type Frame struct {</p>\n<p>  lower *Frame  // 下一个帧，栈结构。</p>\n<p>  localVars LocalVars // 局部变量表</p>\n<p>  operandStack *OperandStack  // 操作数栈</p>\n<p>  thread *Thread // 所属线程</p>\n<p>  nextPC int // the next instruction after the call</p>\n<p>}</p>\n<p>根据main()方法的CodeAttribute(属性表，名称Code，存储方法执行的字节码信息)，获取其中的最大局部变量大小、最大操作数栈大小，新建Frame实例，将Frame实例压入当前线程的执行帧栈。</p>\n<p>JVM会循环不停的从线程的帧栈中弹出帧Frame，执行Frame：</p>\n<p>1.1获取frame要执行的指令编号NextPC</p>\n<p>1.2将NextPC设置到thread的pc</p>\n<p>2.1解码code，根据pc从CodeAttribute中的code(byte[]结构)解码</p>\n<p>2.2先获取8bit操作指令，根据指令新建指令实例。</p>\n<p>共分为11类：常量（constants）指令、加载（loads）指令、存储（stores）指令、<br>操作数栈（stack）指令、数学（math）指令、转换（conversions）指令、比<br>较（comparisons）指令、控制（control）指令、引用（references）指令、<br>扩展（extended）指令和保留（reserved）指令。</p>\n<p>如：iconst_0，istore_1，iload_1，iinc{}，if_icmple，_goto，swap，i2b等。</p>\n<p>2.3从属性表的code获取操作数，不同的指令具体实现。</p>\n<p>如if_icmpeq指令，如果比较值相等则跳转，其中的跳转地址需要在方法属性表code中获取，读取code(byte[]结构)的下16位为跳转的偏移地址。</p>\n<p>2.4设置frame的NextPC为code的pc，即记录code读取到哪个位置。</p>\n<p>2.5执行指令实例，不同的指令具体实现。</p>\n<p>如if_icmpeq指令，从帧的操作数栈中，弹出两个int值，比较两个值，如果相等，则设置帧frame的NextPC为 当前线程的pc + 偏移量（步骤2.3从code属性表中读取）。</p>\n<p>重复1.1执行</p>\n<p>上面是一个帧Frame完整的执行流程。</p>\n<h3 id=\"上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。\"><a href=\"#上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。\" class=\"headerlink\" title=\"上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。\"></a><strong>上面描述了一个简易的JVM执行流程，由线程驱动，不停的从线程的帧栈中弹出帧，执行帧：循环不停的从方法的属性表中获取code，解析成指令，执行指令，指令的执行需要操作帧frame的局部变量，操作数栈以及属性表。</strong></h3><h2 id=\"完整流程：\"><a href=\"#完整流程：\" class=\"headerlink\" title=\"完整流程：\"></a>完整流程：</h2><p>1.解析环境变量<br>2.类加载器<br>3.解析主类名<br>4.加载主类<br>加载类流程：内存中是否已加载该类，没有的话加载类<br>一、解析：<br>读取class文件字节码，解析<br>生成虚拟机可用的类数据，放入方法区。类数据：类基本信息、常量池、字段、方法、父类、接口、静态变量等信息。<br>加载类的时候会递归加载类的父类和接口。<br>二、链接：<br>1验证<br>2准备<br>计算实例字段的个数<br>计算静态字段的个数<br>分配并初始化静态变量，设置常量的值（字段信息里有常量指向的常量池的索引）</p>\n<p>5.主类加载完成后，找到主入口方法main<br>6.解释执行main方法</p>\n<h2 id=\"方法的调用过程：\"><a href=\"#方法的调用过程：\" class=\"headerlink\" title=\"方法的调用过程：\"></a>方法的调用过程：</h2><h2 id=\"invokeinterface-invokespecial-invokestatic-invokevirtual-1-创建帧（帧的主要组成是Method），将帧推入栈顶，-2-将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。-3-主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。-4-return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\"><a href=\"#invokeinterface-invokespecial-invokestatic-invokevirtual-1-创建帧（帧的主要组成是Method），将帧推入栈顶，-2-将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。-3-主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。-4-return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\" class=\"headerlink\" title=\"invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。\"></a>invokeinterface invokespecial invokestatic invokevirtual 1.创建帧（帧的主要组成是Method），将帧推入栈顶， 2.将要传递的参数（实例方法会多传this），从调用者的操作数栈中弹出，放进被调用方法帧的局部变量表中。 3.主looper中，会不停的执行当前帧，这样调用的方法帧即会被执行。 4.return系列指令会把当前帧从栈中弹出，使得下一帧得以执行，从而实现方法的返回。</h2><p> 类初始化</p>\n<h1 id=\"笔记：\"><a href=\"#笔记：\" class=\"headerlink\" title=\"笔记：\"></a>笔记：</h1><p>1.搜索class文件</p>\n<p>1.hello world为例，加载前需要加载超类<strong>java.lang.Object</strong>，在调用main()方法前，虚拟机需要准备好参数数组，加载<strong>java.lang.String</strong>和<strong>java.lang.String[]<strong>，打印需要加载</strong>java.lang.System</strong>类。</p>\n<p>2.类路径：启动类路径（bootstrap classpath）jre\\lib、</p>\n<p>扩展类路径（extension classpath） jre\\lib\\ext、</p>\n<p>用户类路径（user classpath）-classpath或-cp指定，使用系统分隔符指定多个路径。</p>\n<p>2.解析class文件</p>\n<p>1.class文件的基本数据单位是字节，数据在class文件中以大端(big-endian)方式存储。</p>\n"},{"title":"IDEA+MAVEN+GIT项目管理","date":"2018-08-04T02:53:23.000Z","id":"mvn-git","_content":"\n## 安装maven\n\n下载地址：http://maven.apache.org/download.cgi#\n\n解压到D盘Maven文件夹下：\n\n在Maven文件夹下新建一个Repository文件夹，用作仓库。\n\n修改D:\\Maven\\apache-maven-3.6.0\\conf下settings.xml文件：\n\n添加：\n\n```\n<localRepository>D:\\Maven\\Repository</localRepository>\n```\n\n<!--more-->\n\n在mirrors下添加阿里云远程镜像，速度贼快：\n\n<!– 阿里云仓库 –>\n<mirror>\n<id>alimaven</id>\n<mirrorOf>central</mirrorOf>\n<name>aliyun maven</name>\n<url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\n</mirror>\n\n<mirror>\n<id>alimaven</id>\n<name>aliyun maven</name>\n<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n<mirrorOf>central</mirrorOf>\n</mirror>\n\n在profiles下添加，修改jdk为11：\n\n<profile>\n<id>jdk-11</id>\n<activation>\n<activeByDefault>true</activeByDefault>\n<jdk>11</jdk>\n</activation>\n<properties>\n<maven.compiler.source>11</maven.compiler.source>\n<maven.compiler.target>11</maven.compiler.target>\n<maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>\n</properties>\n</profile>\n\n添加环境变量：\nM2_HOME\nD:\\Maven\\apache-maven-3.6.0\nPath\n%M2_HOME%\\bin;\n\n## idea建立maven\n\n在settings里面：\n\n![IDEA+MAVEN+GIT项目管理 - 第1张  | 张嘎](https://img-blog.csdn.net/20170818231853882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV5YW9xaWFveWFvZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 安装git\n\ngit下载地址 ：https://gitforwindows.org/\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n安装完成后，还需要最后一步设置，在命令行输入：\n\n$ git config –global user.name “Your Name”\n$ git config –global user.email “email@example.com”\n\n具体过程请参见：\n[廖雪峰Git安装](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000)\n\n## git clone远程项目\n\n在“Git Bash”命令行里输入：ssh-keygen -t rsa -C “your.email@example.com” -b 4096\n\n会在本地用户目录下的.ssh文件夹下生成id_rsa和id_rsa.pub文件，\n\n将id_rsa.pub公钥文件加入到远程git/Setttings/SSH Keys里面。\n\n右键菜单“Git GUI”\n\n## 码云\n\n码云是目前国内比较好的代码托管平台。\n码云官方教程如下：\n[码云教程](http://git.mydoc.io/?t=153739)\n安装好插件后可以将之前建立的项目托管到码云上。\n\n","source":"_posts/mvn-git.md","raw":"---\ntitle: IDEA+MAVEN+GIT项目管理\ndate: 2018-08-04 10:53:23\ntags:\n  - 笔记\nid: mvn-git\ncategories:\n  - 笔记\n---\n\n## 安装maven\n\n下载地址：http://maven.apache.org/download.cgi#\n\n解压到D盘Maven文件夹下：\n\n在Maven文件夹下新建一个Repository文件夹，用作仓库。\n\n修改D:\\Maven\\apache-maven-3.6.0\\conf下settings.xml文件：\n\n添加：\n\n```\n<localRepository>D:\\Maven\\Repository</localRepository>\n```\n\n<!--more-->\n\n在mirrors下添加阿里云远程镜像，速度贼快：\n\n<!– 阿里云仓库 –>\n<mirror>\n<id>alimaven</id>\n<mirrorOf>central</mirrorOf>\n<name>aliyun maven</name>\n<url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\n</mirror>\n\n<mirror>\n<id>alimaven</id>\n<name>aliyun maven</name>\n<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n<mirrorOf>central</mirrorOf>\n</mirror>\n\n在profiles下添加，修改jdk为11：\n\n<profile>\n<id>jdk-11</id>\n<activation>\n<activeByDefault>true</activeByDefault>\n<jdk>11</jdk>\n</activation>\n<properties>\n<maven.compiler.source>11</maven.compiler.source>\n<maven.compiler.target>11</maven.compiler.target>\n<maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>\n</properties>\n</profile>\n\n添加环境变量：\nM2_HOME\nD:\\Maven\\apache-maven-3.6.0\nPath\n%M2_HOME%\\bin;\n\n## idea建立maven\n\n在settings里面：\n\n![IDEA+MAVEN+GIT项目管理 - 第1张  | 张嘎](https://img-blog.csdn.net/20170818231853882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV5YW9xaWFveWFvZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 安装git\n\ngit下载地址 ：https://gitforwindows.org/\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n安装完成后，还需要最后一步设置，在命令行输入：\n\n$ git config –global user.name “Your Name”\n$ git config –global user.email “email@example.com”\n\n具体过程请参见：\n[廖雪峰Git安装](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000)\n\n## git clone远程项目\n\n在“Git Bash”命令行里输入：ssh-keygen -t rsa -C “your.email@example.com” -b 4096\n\n会在本地用户目录下的.ssh文件夹下生成id_rsa和id_rsa.pub文件，\n\n将id_rsa.pub公钥文件加入到远程git/Setttings/SSH Keys里面。\n\n右键菜单“Git GUI”\n\n## 码云\n\n码云是目前国内比较好的代码托管平台。\n码云官方教程如下：\n[码云教程](http://git.mydoc.io/?t=153739)\n安装好插件后可以将之前建立的项目托管到码云上。\n\n","slug":"mvn-git","published":1,"updated":"2021-08-27T03:00:13.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljv000whcmnctkq73ki","content":"<h2 id=\"安装maven\"><a href=\"#安装maven\" class=\"headerlink\" title=\"安装maven\"></a>安装maven</h2><p>下载地址：<a href=\"http://maven.apache.org/download.cgi#\">http://maven.apache.org/download.cgi#</a></p>\n<p>解压到D盘Maven文件夹下：</p>\n<p>在Maven文件夹下新建一个Repository文件夹，用作仓库。</p>\n<p>修改D:\\Maven\\apache-maven-3.6.0\\conf下settings.xml文件：</p>\n<p>添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;localRepository&gt;D:\\Maven\\Repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>在mirrors下添加阿里云远程镜像，速度贼快：</p>\n<p>&lt;!– 阿里云仓库 –&gt;<br><mirror><br><id>alimaven</id><br><mirrorOf>central</mirrorOf><br><name>aliyun maven</name><br><url><a href=\"http://maven.aliyun.com/nexus/content/repositories/central/\">http://maven.aliyun.com/nexus/content/repositories/central/</a></url><br></mirror></p>\n<mirror>\n<id>alimaven</id>\n<name>aliyun maven</name>\n<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n<mirrorOf>central</mirrorOf>\n</mirror>\n\n<p>在profiles下添加，修改jdk为11：</p>\n<profile>\n<id>jdk-11</id>\n<activation>\n<activeByDefault>true</activeByDefault>\n<jdk>11</jdk>\n</activation>\n<properties>\n<maven.compiler.source>11</maven.compiler.source>\n<maven.compiler.target>11</maven.compiler.target>\n<maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>\n</properties>\n</profile>\n\n<p>添加环境变量：<br>M2_HOME<br>D:\\Maven\\apache-maven-3.6.0<br>Path<br>%M2_HOME%\\bin;</p>\n<h2 id=\"idea建立maven\"><a href=\"#idea建立maven\" class=\"headerlink\" title=\"idea建立maven\"></a>idea建立maven</h2><p>在settings里面：</p>\n<p><img src=\"https://img-blog.csdn.net/20170818231853882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV5YW9xaWFveWFvZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"IDEA+MAVEN+GIT项目管理 - 第1张  | 张嘎\"></p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>git下载地址 ：<a href=\"https://gitforwindows.org/\">https://gitforwindows.org/</a><br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p>\n<p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href=\"mailto:&#101;&#x6d;&#97;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;\">&#101;&#x6d;&#97;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a>”</p>\n<p>具体过程请参见：<br><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000\">廖雪峰Git安装</a></p>\n<h2 id=\"git-clone远程项目\"><a href=\"#git-clone远程项目\" class=\"headerlink\" title=\"git clone远程项目\"></a>git clone远程项目</h2><p>在“Git Bash”命令行里输入：ssh-keygen -t rsa -C “<a href=\"mailto:&#x79;&#111;&#117;&#x72;&#x2e;&#101;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;\">&#x79;&#111;&#117;&#x72;&#x2e;&#101;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;</a>” -b 4096</p>\n<p>会在本地用户目录下的.ssh文件夹下生成id_rsa和id_rsa.pub文件，</p>\n<p>将id_rsa.pub公钥文件加入到远程git/Setttings/SSH Keys里面。</p>\n<p>右键菜单“Git GUI”</p>\n<h2 id=\"码云\"><a href=\"#码云\" class=\"headerlink\" title=\"码云\"></a>码云</h2><p>码云是目前国内比较好的代码托管平台。<br>码云官方教程如下：<br><a href=\"http://git.mydoc.io/?t=153739\">码云教程</a><br>安装好插件后可以将之前建立的项目托管到码云上。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"安装maven\"><a href=\"#安装maven\" class=\"headerlink\" title=\"安装maven\"></a>安装maven</h2><p>下载地址：<a href=\"http://maven.apache.org/download.cgi#\">http://maven.apache.org/download.cgi#</a></p>\n<p>解压到D盘Maven文件夹下：</p>\n<p>在Maven文件夹下新建一个Repository文件夹，用作仓库。</p>\n<p>修改D:\\Maven\\apache-maven-3.6.0\\conf下settings.xml文件：</p>\n<p>添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;localRepository&gt;D:\\Maven\\Repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>","more":"<p>在mirrors下添加阿里云远程镜像，速度贼快：</p>\n<p>&lt;!– 阿里云仓库 –&gt;<br><mirror><br><id>alimaven</id><br><mirrorOf>central</mirrorOf><br><name>aliyun maven</name><br><url><a href=\"http://maven.aliyun.com/nexus/content/repositories/central/\">http://maven.aliyun.com/nexus/content/repositories/central/</a></url><br></mirror></p>\n<mirror>\n<id>alimaven</id>\n<name>aliyun maven</name>\n<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n<mirrorOf>central</mirrorOf>\n</mirror>\n\n<p>在profiles下添加，修改jdk为11：</p>\n<profile>\n<id>jdk-11</id>\n<activation>\n<activeByDefault>true</activeByDefault>\n<jdk>11</jdk>\n</activation>\n<properties>\n<maven.compiler.source>11</maven.compiler.source>\n<maven.compiler.target>11</maven.compiler.target>\n<maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>\n</properties>\n</profile>\n\n<p>添加环境变量：<br>M2_HOME<br>D:\\Maven\\apache-maven-3.6.0<br>Path<br>%M2_HOME%\\bin;</p>\n<h2 id=\"idea建立maven\"><a href=\"#idea建立maven\" class=\"headerlink\" title=\"idea建立maven\"></a>idea建立maven</h2><p>在settings里面：</p>\n<p><img src=\"https://img-blog.csdn.net/20170818231853882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHV5YW9xaWFveWFvZ2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"IDEA+MAVEN+GIT项目管理 - 第1张  | 张嘎\"></p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>git下载地址 ：<a href=\"https://gitforwindows.org/\">https://gitforwindows.org/</a><br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p>\n<p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href=\"mailto:&#101;&#x6d;&#97;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;\">&#101;&#x6d;&#97;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a>”</p>\n<p>具体过程请参见：<br><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000\">廖雪峰Git安装</a></p>\n<h2 id=\"git-clone远程项目\"><a href=\"#git-clone远程项目\" class=\"headerlink\" title=\"git clone远程项目\"></a>git clone远程项目</h2><p>在“Git Bash”命令行里输入：ssh-keygen -t rsa -C “<a href=\"mailto:&#x79;&#111;&#117;&#x72;&#x2e;&#101;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;\">&#x79;&#111;&#117;&#x72;&#x2e;&#101;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;</a>” -b 4096</p>\n<p>会在本地用户目录下的.ssh文件夹下生成id_rsa和id_rsa.pub文件，</p>\n<p>将id_rsa.pub公钥文件加入到远程git/Setttings/SSH Keys里面。</p>\n<p>右键菜单“Git GUI”</p>\n<h2 id=\"码云\"><a href=\"#码云\" class=\"headerlink\" title=\"码云\"></a>码云</h2><p>码云是目前国内比较好的代码托管平台。<br>码云官方教程如下：<br><a href=\"http://git.mydoc.io/?t=153739\">码云教程</a><br>安装好插件后可以将之前建立的项目托管到码云上。</p>"},{"title":"Nexus搭建开发组的私有仓库","date":"2018-11-10T11:33:23.000Z","id":"nexus","_content":"\n**目录**\n\n- [一、私有仓库的价值](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label0)\n- 二、准备工作\n  - 2.1、安装Java编译环境\n    - [2.1.1、安装](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0)\n    - [2.1.2、验证](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0)\n    - [2.1.3、设置环境变量](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0)\n  - [2.2、虚拟机访问互联网](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_1)\n- 三、安装Nexus\n  - [3.1、下载nexus](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_0)\n  - [3.2、部署](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_1)\n  - 3.3、系统服务\n    - [3.3.1、编辑系统服务文件](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2)\n    - [3.3.2、设置为自启动服务](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2)\n- 四、设置Nexus\n  - [4.1、浏览器登录](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_0)\n  - [4.2、进入管理界面](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_1)\n  - [4.3、增加新的代理源](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_2)\n  - [4.3、设置私用仓库可重复发布](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_3)\n- 五、安装maven并设置私用仓库\n  - [5.1、下载安装](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_0)\n  - [5.2、设置环境变量](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_1)\n  - [5.3、测试](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_2)\n  - [5.4、配置](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_3)\n\n**正文**[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n![Nexus搭建开发组的私有仓库 - 第1张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-1024x495.png?resize=640%2C309)\n\n# 一、私有仓库的价值\n\n　　开发Java应用系统，用到Maven、sbt和 Gradle等构建工具，在构建过程中一般需要从互联网下载依赖库，构建私有仓库就是为了在开发组或者部门内共用，从而节省整体的下载成本和构建成本。下面先以Maven为例说明。\n\n　　Maven是一个强大的构建工具，一般用于Java项目。Maven项目基于对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。\n\nMaven的Java项目一般需要下载第三方组件，下载后构成本地仓库，为了减少网络对构建项目的影响，一般会构建私服仓库，代理第三方库。Nexus就是构建私服仓库的优秀软件。\n\n![Nexus搭建开发组的私有仓库 - 第2张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220431849-1095286350.png?w=640&ssl=1)\n\n图 1 三层仓库架构[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 二、准备工作\n\n## 2.1、安装Java编译环境\n\nJava编译环境包括核心的JDK和编译工具，因为Java的编译工具有很多种，而开源项目作者的随意性很高，常用的工具有maven，gradle,sbt，ant等等，本文关注Maven。\n\n因为Oracle不再维护Java1.7，所以采用Java 1.8作为编译核心.\n\n### 2.1.1、安装\n\n操作系统采用Centos7.4\n\n```\nyum install java-1.8.0-openjdk-devel java-1.8.0-openjdk java-1.8.0-openjdk-headless -y\n```\n\n### 2.1.2、验证\n\n查看jdk版本号\n\n![Nexus搭建开发组的私有仓库 - 第3张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\njava -version\nPicked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true\nopenjdk version \"1.8.0_131\"\nOpenJDK Runtime Environment (build 1.8.0_131-b12)\nOpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)\n```\n\n![Nexus搭建开发组的私有仓库 - 第4张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n### 2.1.3、设置环境变量\n\n```\nvi ~/.bashrc\n```\n\n增加\n\n```\nexport JAVA_HOME=/usr/lib/jvm/java\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:$JRE_HOME/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n即刻生效\n\n```\nsource ~/.bashrc\n```\n\n## 2.2、虚拟机访问互联网\n\n```\nvi /etc/sysconfig/network-scripts/ifcfg-ens32\n```\n\n注：环境不同网卡名会不同\n\n增加天津联通的DNS（注：作者在天津，请按个人本地的运行商做相应修改）\n\n```\nDNS1=202.99.96.68\nDNS2=202.99.104.68\n```\n\n在实际测试中感觉天津电信的DNS更加靠谱，访问一些特殊网站返回的IP能够顺利访问，大家根据实践选择吧\n\n```\nDNS1=219.150.32.132\nDNS2=219.146.0.130\n```\n\n重新启动网络\n\n```\nsystemctl restart network\n```\n\n测试\n\n```\nping www.163.com\nPING 163.xdwscache.ourglb0.com (42.81.9.47) 56(84) bytes of data.\n64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=1 ttl=128 time=9.66 ms\n64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=2 ttl=128 time=10.4 ms…\n```\n\n[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 三、安装Nexus\n\n## 3.1、下载nexus\n\n从官方网站现在最新3.X版\n\nhttps://www.sonatype.com/download-oss-sonatype\n\n下载（2018年3月）最新版nexus-3.9.0-01-unix.tar.gz （）\n\n## 3.2、部署\n\n先规划存储私有仓库的目录，作者本机的/opt目录空间较多，所以以/opt为例\n\n```\ncd /opt/scm\ntar -xf ~/download/nexus-3.9.0-01-unix.tar.gz -C .\n```\n\n生成两个目录\n\n```\nnexus-3.9.0-01\nsonatype-work\n```\n\n## 3.3、系统服务\n\n### 3.3.1、编辑系统服务文件\n\n![Nexus搭建开发组的私有仓库 - 第5张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\nvi /etc/systemd/system/nexus.service\n\n[Unit]\nDescription=nexus service\nAfter=network.target\n\n[Service]Type=forking\nLimitNOFILE=65536\nExecStart=/opt/scm/nexus-3.9.0-01/bin/nexus start\nExecStop=/opt/scm/nexus-3.9.0-01/bin/nexus stop\nUser=ansible\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\n```\n\n![Nexus搭建开发组的私有仓库 - 第6张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n### 3.3.2、设置为自启动服务\n\n```\nsudo systemctl  daemon-reload\nsudo systemctl start nexus.service\nsudo systemctl status nexus.service\nsudo systemctl enable nexus.service\n```\n\n启动报错：1./etc/systemd/system/nexus.service文件的user不对\n2.修改/opt/scm/nexus/bin/nexus 启动的JAVA_HOME 如：INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/java/jdk1.8/\n\n[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 四、设置Nexus\n\n## 4.1、浏览器登录\n\nhttp://192.168.154.11:8081/\n\n![Nexus搭建开发组的私有仓库 - 第7张  | 张嘎](https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220256240-534211558.png?w=640&ssl=1)\n\n用户名的密码为：admin admin123\n\n## 4.2、进入管理界面\n\n![Nexus搭建开发组的私有仓库 - 第8张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220317318-1530787694.png?w=640&ssl=1)\n\n## 4.3、增加新的代理源\n\n![Nexus搭建开发组的私有仓库 - 第9张  | 张嘎](https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220331802-1557956595.png?w=640&ssl=1)\n\n设置名称和URL\n\n![Nexus搭建开发组的私有仓库 - 第10张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220342224-1667350164.png?w=640&ssl=1)\n\nCache统一设置为200天 288000\n\n![Nexus搭建开发组的私有仓库 - 第11张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220350271-1209294422.png?w=640&ssl=1)\n\n 逐个增加常用代理\n\n![Nexus搭建开发组的私有仓库 - 第12张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\n1. aliyun\nhttp://maven.aliyun.com/nexus/content/groups/public\n2. apache_snapshot\nhttps://repository.apache.org/content/repositories/snapshots/\n3. apache_release\nhttps://repository.apache.org/content/repositories/releases/\n4. atlassian\nhttps://maven.atlassian.com/content/repositories/atlassian-public/\n5. central.maven.org\nhttp://central.maven.org/maven2/\n6. datanucleus\nhttp://www.datanucleus.org/downloads/maven2\n7. maven-central （安装后自带，仅需设置Cache有效期即可）\nhttps://repo1.maven.org/maven2/\n8. nexus.axiomalaska.com\nhttp://nexus.axiomalaska.com/nexus/content/repositories/public\n9. oss.sonatype.org\nhttps://oss.sonatype.org/content/repositories/snapshots\n10.pentaho\nhttps://public.nexus.pentaho.org/content/groups/omni/\n```\n\n![Nexus搭建开发组的私有仓库 - 第13张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n再次强调，在\n\nHow long (in minutes) to cache metadata before rechecking the remote repository.处\n\n统一设置为\n\n288000 即200天，当然可以设置为更长的时间\n\n设置maven-public\n\n将这些代理加入Group\n\n![Nexus搭建开发组的私有仓库 - 第14张  | 张嘎](https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220400959-1653481781.png?w=640&ssl=1)\n\n## 4.3、设置私用仓库可重复发布\n\n　　Nexus安装后自带maven-releases，maven-snapshots两个仓库，用于将生成的jar包发布在这两个仓库中，在实际开发中需要将maven-releases设置为可以重复发布。\n\n　　maven-releases\n\n![Nexus搭建开发组的私有仓库 - 第15张  | 张嘎](https://i0.wp.com/images2018.cnblogs.com/blog/1082089/201803/1082089-20180317135112096-935379506.png?w=640&ssl=1)\n\n　　注：maven-snapshots缺省是可以重新部署的。[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 五、安装maven并设置私用仓库\n\n## 5.1、下载安装\n\n从maven官网下载3.5.0 http://maven.apache.org/download.cgi\n\n```\ncd tools\ntar -xf ../download/apache-maven-3.5.0-bin.tar.gz –C .\n```\n\n## 5.2、设置环境变量\n\nvi ~/.bashrc\n\n增加\n\n```\nexport PATH=/home/ansible/tools/apache-maven-3.5.0/bin:$PATH\n```\n\n即刻生效\n\nsource ~/.bashrc\n\n## 5.3、测试\n\n![Nexus搭建开发组的私有仓库 - 第16张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\nmvn -v\n\nPicked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true\nApache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)\nMaven home: /home/ansible/tools/apache-maven-3.5.0\nJava version: 1.8.0_102, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"3.10.0-514.el7.x86_64\", arch: \"amd64\", family: \"unix\"\n```\n\n## 5.4、配置\n\nvi ~/tools/apache-maven-3.5.0/conf/settings.xml（本地服务器可以使用localhost，开发组其他服务器则修改为对应Nexus服务器的域名或者IP地址）\n\n![Nexus搭建开发组的私有仓库 - 第17张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\n<settings>\n  <pluginGroups>  \n     <pluginGroup>org.sonatype.plugins</pluginGroup>  \n  </pluginGroups> \n  <mirrors>\n    <mirror>\n      <id>nexus</id>\n      <mirrorOf>*</mirrorOf>\n      <url>http://localhost:8081/repository/maven-public/</url>\n    </mirror>\n  </mirrors>\n  <profiles>\n    <profile>\n      <id>nexus</id>\n      <!--Enable snapshots for the built in central repo to direct -->\n      <!--all requests to nexus via the mirror -->\n      <repositories>\n        <repository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </repository>\n      </repositories>\n     <pluginRepositories>\n        <pluginRepository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </pluginRepository>\n      </pluginRepositories>\n    </profile>\n  </profiles>\n  <activeProfiles>\n    <!--make the profile active all the time -->\n    <activeProfile>nexus</activeProfile>\n  </activeProfiles>\n  <servers>\n    <server>\n      <id>nexus</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n  </servers>\n</settings>\n```\n\n","source":"_posts/nexus.md","raw":"---\ntitle: Nexus搭建开发组的私有仓库\ndate: 2018-11-10 19:33:23\ntags:\n  - 笔记\nid: nexus\ncategories:\n  - 笔记\n---\n\n**目录**\n\n- [一、私有仓库的价值](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label0)\n- 二、准备工作\n  - 2.1、安装Java编译环境\n    - [2.1.1、安装](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0)\n    - [2.1.2、验证](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0)\n    - [2.1.3、设置环境变量](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0)\n  - [2.2、虚拟机访问互联网](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_1)\n- 三、安装Nexus\n  - [3.1、下载nexus](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_0)\n  - [3.2、部署](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_1)\n  - 3.3、系统服务\n    - [3.3.1、编辑系统服务文件](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2)\n    - [3.3.2、设置为自启动服务](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2)\n- 四、设置Nexus\n  - [4.1、浏览器登录](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_0)\n  - [4.2、进入管理界面](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_1)\n  - [4.3、增加新的代理源](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_2)\n  - [4.3、设置私用仓库可重复发布](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_3)\n- 五、安装maven并设置私用仓库\n  - [5.1、下载安装](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_0)\n  - [5.2、设置环境变量](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_1)\n  - [5.3、测试](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_2)\n  - [5.4、配置](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_3)\n\n**正文**[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n![Nexus搭建开发组的私有仓库 - 第1张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-1024x495.png?resize=640%2C309)\n\n# 一、私有仓库的价值\n\n　　开发Java应用系统，用到Maven、sbt和 Gradle等构建工具，在构建过程中一般需要从互联网下载依赖库，构建私有仓库就是为了在开发组或者部门内共用，从而节省整体的下载成本和构建成本。下面先以Maven为例说明。\n\n　　Maven是一个强大的构建工具，一般用于Java项目。Maven项目基于对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。\n\nMaven的Java项目一般需要下载第三方组件，下载后构成本地仓库，为了减少网络对构建项目的影响，一般会构建私服仓库，代理第三方库。Nexus就是构建私服仓库的优秀软件。\n\n![Nexus搭建开发组的私有仓库 - 第2张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220431849-1095286350.png?w=640&ssl=1)\n\n图 1 三层仓库架构[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 二、准备工作\n\n## 2.1、安装Java编译环境\n\nJava编译环境包括核心的JDK和编译工具，因为Java的编译工具有很多种，而开源项目作者的随意性很高，常用的工具有maven，gradle,sbt，ant等等，本文关注Maven。\n\n因为Oracle不再维护Java1.7，所以采用Java 1.8作为编译核心.\n\n### 2.1.1、安装\n\n操作系统采用Centos7.4\n\n```\nyum install java-1.8.0-openjdk-devel java-1.8.0-openjdk java-1.8.0-openjdk-headless -y\n```\n\n### 2.1.2、验证\n\n查看jdk版本号\n\n![Nexus搭建开发组的私有仓库 - 第3张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\njava -version\nPicked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true\nopenjdk version \"1.8.0_131\"\nOpenJDK Runtime Environment (build 1.8.0_131-b12)\nOpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)\n```\n\n![Nexus搭建开发组的私有仓库 - 第4张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n### 2.1.3、设置环境变量\n\n```\nvi ~/.bashrc\n```\n\n增加\n\n```\nexport JAVA_HOME=/usr/lib/jvm/java\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:$JRE_HOME/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n\n即刻生效\n\n```\nsource ~/.bashrc\n```\n\n## 2.2、虚拟机访问互联网\n\n```\nvi /etc/sysconfig/network-scripts/ifcfg-ens32\n```\n\n注：环境不同网卡名会不同\n\n增加天津联通的DNS（注：作者在天津，请按个人本地的运行商做相应修改）\n\n```\nDNS1=202.99.96.68\nDNS2=202.99.104.68\n```\n\n在实际测试中感觉天津电信的DNS更加靠谱，访问一些特殊网站返回的IP能够顺利访问，大家根据实践选择吧\n\n```\nDNS1=219.150.32.132\nDNS2=219.146.0.130\n```\n\n重新启动网络\n\n```\nsystemctl restart network\n```\n\n测试\n\n```\nping www.163.com\nPING 163.xdwscache.ourglb0.com (42.81.9.47) 56(84) bytes of data.\n64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=1 ttl=128 time=9.66 ms\n64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=2 ttl=128 time=10.4 ms…\n```\n\n[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 三、安装Nexus\n\n## 3.1、下载nexus\n\n从官方网站现在最新3.X版\n\nhttps://www.sonatype.com/download-oss-sonatype\n\n下载（2018年3月）最新版nexus-3.9.0-01-unix.tar.gz （）\n\n## 3.2、部署\n\n先规划存储私有仓库的目录，作者本机的/opt目录空间较多，所以以/opt为例\n\n```\ncd /opt/scm\ntar -xf ~/download/nexus-3.9.0-01-unix.tar.gz -C .\n```\n\n生成两个目录\n\n```\nnexus-3.9.0-01\nsonatype-work\n```\n\n## 3.3、系统服务\n\n### 3.3.1、编辑系统服务文件\n\n![Nexus搭建开发组的私有仓库 - 第5张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\nvi /etc/systemd/system/nexus.service\n\n[Unit]\nDescription=nexus service\nAfter=network.target\n\n[Service]Type=forking\nLimitNOFILE=65536\nExecStart=/opt/scm/nexus-3.9.0-01/bin/nexus start\nExecStop=/opt/scm/nexus-3.9.0-01/bin/nexus stop\nUser=ansible\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\n```\n\n![Nexus搭建开发组的私有仓库 - 第6张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n### 3.3.2、设置为自启动服务\n\n```\nsudo systemctl  daemon-reload\nsudo systemctl start nexus.service\nsudo systemctl status nexus.service\nsudo systemctl enable nexus.service\n```\n\n启动报错：1./etc/systemd/system/nexus.service文件的user不对\n2.修改/opt/scm/nexus/bin/nexus 启动的JAVA_HOME 如：INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/java/jdk1.8/\n\n[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 四、设置Nexus\n\n## 4.1、浏览器登录\n\nhttp://192.168.154.11:8081/\n\n![Nexus搭建开发组的私有仓库 - 第7张  | 张嘎](https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220256240-534211558.png?w=640&ssl=1)\n\n用户名的密码为：admin admin123\n\n## 4.2、进入管理界面\n\n![Nexus搭建开发组的私有仓库 - 第8张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220317318-1530787694.png?w=640&ssl=1)\n\n## 4.3、增加新的代理源\n\n![Nexus搭建开发组的私有仓库 - 第9张  | 张嘎](https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220331802-1557956595.png?w=640&ssl=1)\n\n设置名称和URL\n\n![Nexus搭建开发组的私有仓库 - 第10张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220342224-1667350164.png?w=640&ssl=1)\n\nCache统一设置为200天 288000\n\n![Nexus搭建开发组的私有仓库 - 第11张  | 张嘎](https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220350271-1209294422.png?w=640&ssl=1)\n\n 逐个增加常用代理\n\n![Nexus搭建开发组的私有仓库 - 第12张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\n1. aliyun\nhttp://maven.aliyun.com/nexus/content/groups/public\n2. apache_snapshot\nhttps://repository.apache.org/content/repositories/snapshots/\n3. apache_release\nhttps://repository.apache.org/content/repositories/releases/\n4. atlassian\nhttps://maven.atlassian.com/content/repositories/atlassian-public/\n5. central.maven.org\nhttp://central.maven.org/maven2/\n6. datanucleus\nhttp://www.datanucleus.org/downloads/maven2\n7. maven-central （安装后自带，仅需设置Cache有效期即可）\nhttps://repo1.maven.org/maven2/\n8. nexus.axiomalaska.com\nhttp://nexus.axiomalaska.com/nexus/content/repositories/public\n9. oss.sonatype.org\nhttps://oss.sonatype.org/content/repositories/snapshots\n10.pentaho\nhttps://public.nexus.pentaho.org/content/groups/omni/\n```\n\n![Nexus搭建开发组的私有仓库 - 第13张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n再次强调，在\n\nHow long (in minutes) to cache metadata before rechecking the remote repository.处\n\n统一设置为\n\n288000 即200天，当然可以设置为更长的时间\n\n设置maven-public\n\n将这些代理加入Group\n\n![Nexus搭建开发组的私有仓库 - 第14张  | 张嘎](https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220400959-1653481781.png?w=640&ssl=1)\n\n## 4.3、设置私用仓库可重复发布\n\n　　Nexus安装后自带maven-releases，maven-snapshots两个仓库，用于将生成的jar包发布在这两个仓库中，在实际开发中需要将maven-releases设置为可以重复发布。\n\n　　maven-releases\n\n![Nexus搭建开发组的私有仓库 - 第15张  | 张嘎](https://i0.wp.com/images2018.cnblogs.com/blog/1082089/201803/1082089-20180317135112096-935379506.png?w=640&ssl=1)\n\n　　注：maven-snapshots缺省是可以重新部署的。[回到顶部](https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop)\n\n# 五、安装maven并设置私用仓库\n\n## 5.1、下载安装\n\n从maven官网下载3.5.0 http://maven.apache.org/download.cgi\n\n```\ncd tools\ntar -xf ../download/apache-maven-3.5.0-bin.tar.gz –C .\n```\n\n## 5.2、设置环境变量\n\nvi ~/.bashrc\n\n增加\n\n```\nexport PATH=/home/ansible/tools/apache-maven-3.5.0/bin:$PATH\n```\n\n即刻生效\n\nsource ~/.bashrc\n\n## 5.3、测试\n\n![Nexus搭建开发组的私有仓库 - 第16张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\nmvn -v\n\nPicked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true\nApache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)\nMaven home: /home/ansible/tools/apache-maven-3.5.0\nJava version: 1.8.0_102, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"3.10.0-514.el7.x86_64\", arch: \"amd64\", family: \"unix\"\n```\n\n## 5.4、配置\n\nvi ~/tools/apache-maven-3.5.0/conf/settings.xml（本地服务器可以使用localhost，开发组其他服务器则修改为对应Nexus服务器的域名或者IP地址）\n\n![Nexus搭建开发组的私有仓库 - 第17张  | 张嘎](https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1)\n\n```\n<settings>\n  <pluginGroups>  \n     <pluginGroup>org.sonatype.plugins</pluginGroup>  \n  </pluginGroups> \n  <mirrors>\n    <mirror>\n      <id>nexus</id>\n      <mirrorOf>*</mirrorOf>\n      <url>http://localhost:8081/repository/maven-public/</url>\n    </mirror>\n  </mirrors>\n  <profiles>\n    <profile>\n      <id>nexus</id>\n      <!--Enable snapshots for the built in central repo to direct -->\n      <!--all requests to nexus via the mirror -->\n      <repositories>\n        <repository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </repository>\n      </repositories>\n     <pluginRepositories>\n        <pluginRepository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </pluginRepository>\n      </pluginRepositories>\n    </profile>\n  </profiles>\n  <activeProfiles>\n    <!--make the profile active all the time -->\n    <activeProfile>nexus</activeProfile>\n  </activeProfiles>\n  <servers>\n    <server>\n      <id>nexus</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n  </servers>\n</settings>\n```\n\n","slug":"nexus","published":1,"updated":"2021-09-01T11:34:03.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0ljx000zhcmnfxmb3hgd","content":"<p><strong>目录</strong></p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label0\">一、私有仓库的价值</a></li>\n<li>二、准备工作<ul>\n<li>2.1、安装Java编译环境<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0\">2.1.1、安装</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0\">2.1.2、验证</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0\">2.1.3、设置环境变量</a></li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_1\">2.2、虚拟机访问互联网</a></li>\n</ul>\n</li>\n<li>三、安装Nexus<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_0\">3.1、下载nexus</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_1\">3.2、部署</a></li>\n<li>3.3、系统服务<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2\">3.3.1、编辑系统服务文件</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2\">3.3.2、设置为自启动服务</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>四、设置Nexus<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_0\">4.1、浏览器登录</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_1\">4.2、进入管理界面</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_2\">4.3、增加新的代理源</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_3\">4.3、设置私用仓库可重复发布</a></li>\n</ul>\n</li>\n<li>五、安装maven并设置私用仓库<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_0\">5.1、下载安装</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_1\">5.2、设置环境变量</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_2\">5.3、测试</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_3\">5.4、配置</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>正文</strong><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-1024x495.png?resize=640,309\" alt=\"Nexus搭建开发组的私有仓库 - 第1张  | 张嘎\"></p>\n<h1 id=\"一、私有仓库的价值\"><a href=\"#一、私有仓库的价值\" class=\"headerlink\" title=\"一、私有仓库的价值\"></a>一、私有仓库的价值</h1><p>　　开发Java应用系统，用到Maven、sbt和 Gradle等构建工具，在构建过程中一般需要从互联网下载依赖库，构建私有仓库就是为了在开发组或者部门内共用，从而节省整体的下载成本和构建成本。下面先以Maven为例说明。</p>\n<p>　　Maven是一个强大的构建工具，一般用于Java项目。Maven项目基于对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。</p>\n<p>Maven的Java项目一般需要下载第三方组件，下载后构成本地仓库，为了减少网络对构建项目的影响，一般会构建私服仓库，代理第三方库。Nexus就是构建私服仓库的优秀软件。</p>\n<p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220431849-1095286350.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第2张  | 张嘎\"></p>\n<p>图 1 三层仓库架构<a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"二、准备工作\"><a href=\"#二、准备工作\" class=\"headerlink\" title=\"二、准备工作\"></a>二、准备工作</h1><h2 id=\"2-1、安装Java编译环境\"><a href=\"#2-1、安装Java编译环境\" class=\"headerlink\" title=\"2.1、安装Java编译环境\"></a>2.1、安装Java编译环境</h2><p>Java编译环境包括核心的JDK和编译工具，因为Java的编译工具有很多种，而开源项目作者的随意性很高，常用的工具有maven，gradle,sbt，ant等等，本文关注Maven。</p>\n<p>因为Oracle不再维护Java1.7，所以采用Java 1.8作为编译核心.</p>\n<h3 id=\"2-1-1、安装\"><a href=\"#2-1-1、安装\" class=\"headerlink\" title=\"2.1.1、安装\"></a>2.1.1、安装</h3><p>操作系统采用Centos7.4</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install java-1.8.0-openjdk-devel java-1.8.0-openjdk java-1.8.0-openjdk-headless -y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2、验证\"><a href=\"#2-1-2、验证\" class=\"headerlink\" title=\"2.1.2、验证\"></a>2.1.2、验证</h3><p>查看jdk版本号</p>\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第3张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br><span class=\"line\">Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true</span><br><span class=\"line\">openjdk version &quot;1.8.0_131&quot;</span><br><span class=\"line\">OpenJDK Runtime Environment (build 1.8.0_131-b12)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第4张  | 张嘎\"></p>\n<h3 id=\"2-1-3、设置环境变量\"><a href=\"#2-1-3、设置环境变量\" class=\"headerlink\" title=\"2.1.3、设置环境变量\"></a>2.1.3、设置环境变量</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/lib/jvm/java</span><br><span class=\"line\">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class=\"line\">export CLASSPATH=.:$JRE_HOME/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class=\"line\">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>即刻生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2、虚拟机访问互联网\"><a href=\"#2-2、虚拟机访问互联网\" class=\"headerlink\" title=\"2.2、虚拟机访问互联网\"></a>2.2、虚拟机访问互联网</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/sysconfig/network-scripts/ifcfg-ens32</span><br></pre></td></tr></table></figure>\n\n<p>注：环境不同网卡名会不同</p>\n<p>增加天津联通的DNS（注：作者在天津，请按个人本地的运行商做相应修改）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS1=202.99.96.68</span><br><span class=\"line\">DNS2=202.99.104.68</span><br></pre></td></tr></table></figure>\n\n<p>在实际测试中感觉天津电信的DNS更加靠谱，访问一些特殊网站返回的IP能够顺利访问，大家根据实践选择吧</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS1=219.150.32.132</span><br><span class=\"line\">DNS2=219.146.0.130</span><br></pre></td></tr></table></figure>\n\n<p>重新启动网络</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping www.163.com</span><br><span class=\"line\">PING 163.xdwscache.ourglb0.com (42.81.9.47) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=1 ttl=128 time=9.66 ms</span><br><span class=\"line\">64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=2 ttl=128 time=10.4 ms…</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"三、安装Nexus\"><a href=\"#三、安装Nexus\" class=\"headerlink\" title=\"三、安装Nexus\"></a>三、安装Nexus</h1><h2 id=\"3-1、下载nexus\"><a href=\"#3-1、下载nexus\" class=\"headerlink\" title=\"3.1、下载nexus\"></a>3.1、下载nexus</h2><p>从官方网站现在最新3.X版</p>\n<p><a href=\"https://www.sonatype.com/download-oss-sonatype\">https://www.sonatype.com/download-oss-sonatype</a></p>\n<p>下载（2018年3月）最新版nexus-3.9.0-01-unix.tar.gz （）</p>\n<h2 id=\"3-2、部署\"><a href=\"#3-2、部署\" class=\"headerlink\" title=\"3.2、部署\"></a>3.2、部署</h2><p>先规划存储私有仓库的目录，作者本机的/opt目录空间较多，所以以/opt为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /opt/scm</span><br><span class=\"line\">tar -xf ~/download/nexus-3.9.0-01-unix.tar.gz -C .</span><br></pre></td></tr></table></figure>\n\n<p>生成两个目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nexus-3.9.0-01</span><br><span class=\"line\">sonatype-work</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3、系统服务\"><a href=\"#3-3、系统服务\" class=\"headerlink\" title=\"3.3、系统服务\"></a>3.3、系统服务</h2><h3 id=\"3-3-1、编辑系统服务文件\"><a href=\"#3-3-1、编辑系统服务文件\" class=\"headerlink\" title=\"3.3.1、编辑系统服务文件\"></a>3.3.1、编辑系统服务文件</h3><p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第5张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/systemd/system/nexus.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=nexus service</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]Type=forking</span><br><span class=\"line\">LimitNOFILE=65536</span><br><span class=\"line\">ExecStart=/opt/scm/nexus-3.9.0-01/bin/nexus start</span><br><span class=\"line\">ExecStop=/opt/scm/nexus-3.9.0-01/bin/nexus stop</span><br><span class=\"line\">User=ansible</span><br><span class=\"line\">Restart=on-abort</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第6张  | 张嘎\"></p>\n<h3 id=\"3-3-2、设置为自启动服务\"><a href=\"#3-3-2、设置为自启动服务\" class=\"headerlink\" title=\"3.3.2、设置为自启动服务\"></a>3.3.2、设置为自启动服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl  daemon-reload</span><br><span class=\"line\">sudo systemctl start nexus.service</span><br><span class=\"line\">sudo systemctl status nexus.service</span><br><span class=\"line\">sudo systemctl enable nexus.service</span><br></pre></td></tr></table></figure>\n\n<p>启动报错：1./etc/systemd/system/nexus.service文件的user不对<br>2.修改/opt/scm/nexus/bin/nexus 启动的JAVA_HOME 如：INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/java/jdk1.8/</p>\n<p><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"四、设置Nexus\"><a href=\"#四、设置Nexus\" class=\"headerlink\" title=\"四、设置Nexus\"></a>四、设置Nexus</h1><h2 id=\"4-1、浏览器登录\"><a href=\"#4-1、浏览器登录\" class=\"headerlink\" title=\"4.1、浏览器登录\"></a>4.1、浏览器登录</h2><p><a href=\"http://192.168.154.11:8081/\">http://192.168.154.11:8081/</a></p>\n<p><img src=\"https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220256240-534211558.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第7张  | 张嘎\"></p>\n<p>用户名的密码为：admin admin123</p>\n<h2 id=\"4-2、进入管理界面\"><a href=\"#4-2、进入管理界面\" class=\"headerlink\" title=\"4.2、进入管理界面\"></a>4.2、进入管理界面</h2><p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220317318-1530787694.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第8张  | 张嘎\"></p>\n<h2 id=\"4-3、增加新的代理源\"><a href=\"#4-3、增加新的代理源\" class=\"headerlink\" title=\"4.3、增加新的代理源\"></a>4.3、增加新的代理源</h2><p><img src=\"https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220331802-1557956595.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第9张  | 张嘎\"></p>\n<p>设置名称和URL</p>\n<p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220342224-1667350164.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第10张  | 张嘎\"></p>\n<p>Cache统一设置为200天 288000</p>\n<p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220350271-1209294422.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第11张  | 张嘎\"></p>\n<p> 逐个增加常用代理</p>\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第12张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. aliyun</span><br><span class=\"line\">http://maven.aliyun.com/nexus/content/groups/public</span><br><span class=\"line\">2. apache_snapshot</span><br><span class=\"line\">https://repository.apache.org/content/repositories/snapshots/</span><br><span class=\"line\">3. apache_release</span><br><span class=\"line\">https://repository.apache.org/content/repositories/releases/</span><br><span class=\"line\">4. atlassian</span><br><span class=\"line\">https://maven.atlassian.com/content/repositories/atlassian-public/</span><br><span class=\"line\">5. central.maven.org</span><br><span class=\"line\">http://central.maven.org/maven2/</span><br><span class=\"line\">6. datanucleus</span><br><span class=\"line\">http://www.datanucleus.org/downloads/maven2</span><br><span class=\"line\">7. maven-central （安装后自带，仅需设置Cache有效期即可）</span><br><span class=\"line\">https://repo1.maven.org/maven2/</span><br><span class=\"line\">8. nexus.axiomalaska.com</span><br><span class=\"line\">http://nexus.axiomalaska.com/nexus/content/repositories/public</span><br><span class=\"line\">9. oss.sonatype.org</span><br><span class=\"line\">https://oss.sonatype.org/content/repositories/snapshots</span><br><span class=\"line\">10.pentaho</span><br><span class=\"line\">https://public.nexus.pentaho.org/content/groups/omni/</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第13张  | 张嘎\"></p>\n<p>再次强调，在</p>\n<p>How long (in minutes) to cache metadata before rechecking the remote repository.处</p>\n<p>统一设置为</p>\n<p>288000 即200天，当然可以设置为更长的时间</p>\n<p>设置maven-public</p>\n<p>将这些代理加入Group</p>\n<p><img src=\"https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220400959-1653481781.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第14张  | 张嘎\"></p>\n<h2 id=\"4-3、设置私用仓库可重复发布\"><a href=\"#4-3、设置私用仓库可重复发布\" class=\"headerlink\" title=\"4.3、设置私用仓库可重复发布\"></a>4.3、设置私用仓库可重复发布</h2><p>　　Nexus安装后自带maven-releases，maven-snapshots两个仓库，用于将生成的jar包发布在这两个仓库中，在实际开发中需要将maven-releases设置为可以重复发布。</p>\n<p>　　maven-releases</p>\n<p><img src=\"https://i0.wp.com/images2018.cnblogs.com/blog/1082089/201803/1082089-20180317135112096-935379506.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第15张  | 张嘎\"></p>\n<p>　　注：maven-snapshots缺省是可以重新部署的。<a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"五、安装maven并设置私用仓库\"><a href=\"#五、安装maven并设置私用仓库\" class=\"headerlink\" title=\"五、安装maven并设置私用仓库\"></a>五、安装maven并设置私用仓库</h1><h2 id=\"5-1、下载安装\"><a href=\"#5-1、下载安装\" class=\"headerlink\" title=\"5.1、下载安装\"></a>5.1、下载安装</h2><p>从maven官网下载3.5.0 <a href=\"http://maven.apache.org/download.cgi\">http://maven.apache.org/download.cgi</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd tools</span><br><span class=\"line\">tar -xf ../download/apache-maven-3.5.0-bin.tar.gz –C .</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2、设置环境变量\"><a href=\"#5-2、设置环境变量\" class=\"headerlink\" title=\"5.2、设置环境变量\"></a>5.2、设置环境变量</h2><p>vi ~/.bashrc</p>\n<p>增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=/home/ansible/tools/apache-maven-3.5.0/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>即刻生效</p>\n<p>source ~/.bashrc</p>\n<h2 id=\"5-3、测试\"><a href=\"#5-3、测试\" class=\"headerlink\" title=\"5.3、测试\"></a>5.3、测试</h2><p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第16张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -v</span><br><span class=\"line\"></span><br><span class=\"line\">Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true</span><br><span class=\"line\">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class=\"line\">Maven home: /home/ansible/tools/apache-maven-3.5.0</span><br><span class=\"line\">Java version: 1.8.0_102, vendor: Oracle Corporation</span><br><span class=\"line\">Java home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64/jre</span><br><span class=\"line\">Default locale: en_US, platform encoding: UTF-8</span><br><span class=\"line\">OS name: &quot;linux&quot;, version: &quot;3.10.0-514.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4、配置\"><a href=\"#5-4、配置\" class=\"headerlink\" title=\"5.4、配置\"></a>5.4、配置</h2><p>vi ~/tools/apache-maven-3.5.0/conf/settings.xml（本地服务器可以使用localhost，开发组其他服务器则修改为对应Nexus服务器的域名或者IP地址）</p>\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第17张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;settings&gt;</span><br><span class=\"line\">  &lt;pluginGroups&gt;  </span><br><span class=\"line\">     &lt;pluginGroup&gt;org.sonatype.plugins&lt;/pluginGroup&gt;  </span><br><span class=\"line\">  &lt;/pluginGroups&gt; </span><br><span class=\"line\">  &lt;mirrors&gt;</span><br><span class=\"line\">    &lt;mirror&gt;</span><br><span class=\"line\">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class=\"line\">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class=\"line\">      &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;</span><br><span class=\"line\">    &lt;/mirror&gt;</span><br><span class=\"line\">  &lt;/mirrors&gt;</span><br><span class=\"line\">  &lt;profiles&gt;</span><br><span class=\"line\">    &lt;profile&gt;</span><br><span class=\"line\">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class=\"line\">      &lt;!--Enable snapshots for the built in central repo to direct --&gt;</span><br><span class=\"line\">      &lt;!--all requests to nexus via the mirror --&gt;</span><br><span class=\"line\">      &lt;repositories&gt;</span><br><span class=\"line\">        &lt;repository&gt;</span><br><span class=\"line\">          &lt;id&gt;central&lt;/id&gt;</span><br><span class=\"line\">          &lt;url&gt;http://central&lt;/url&gt;</span><br><span class=\"line\">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class=\"line\">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class=\"line\">        &lt;/repository&gt;</span><br><span class=\"line\">      &lt;/repositories&gt;</span><br><span class=\"line\">     &lt;pluginRepositories&gt;</span><br><span class=\"line\">        &lt;pluginRepository&gt;</span><br><span class=\"line\">          &lt;id&gt;central&lt;/id&gt;</span><br><span class=\"line\">          &lt;url&gt;http://central&lt;/url&gt;</span><br><span class=\"line\">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class=\"line\">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class=\"line\">        &lt;/pluginRepository&gt;</span><br><span class=\"line\">      &lt;/pluginRepositories&gt;</span><br><span class=\"line\">    &lt;/profile&gt;</span><br><span class=\"line\">  &lt;/profiles&gt;</span><br><span class=\"line\">  &lt;activeProfiles&gt;</span><br><span class=\"line\">    &lt;!--make the profile active all the time --&gt;</span><br><span class=\"line\">    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;</span><br><span class=\"line\">  &lt;/activeProfiles&gt;</span><br><span class=\"line\">  &lt;servers&gt;</span><br><span class=\"line\">    &lt;server&gt;</span><br><span class=\"line\">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class=\"line\">      &lt;username&gt;admin&lt;/username&gt;</span><br><span class=\"line\">      &lt;password&gt;admin123&lt;/password&gt;</span><br><span class=\"line\">    &lt;/server&gt;</span><br><span class=\"line\">  &lt;/servers&gt;</span><br><span class=\"line\">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>目录</strong></p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label0\">一、私有仓库的价值</a></li>\n<li>二、准备工作<ul>\n<li>2.1、安装Java编译环境<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0\">2.1.1、安装</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0\">2.1.2、验证</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_0\">2.1.3、设置环境变量</a></li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label1_1\">2.2、虚拟机访问互联网</a></li>\n</ul>\n</li>\n<li>三、安装Nexus<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_0\">3.1、下载nexus</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_1\">3.2、部署</a></li>\n<li>3.3、系统服务<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2\">3.3.1、编辑系统服务文件</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label2_2\">3.3.2、设置为自启动服务</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>四、设置Nexus<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_0\">4.1、浏览器登录</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_1\">4.2、进入管理界面</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_2\">4.3、增加新的代理源</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label3_3\">4.3、设置私用仓库可重复发布</a></li>\n</ul>\n</li>\n<li>五、安装maven并设置私用仓库<ul>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_0\">5.1、下载安装</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_1\">5.2、设置环境变量</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_2\">5.3、测试</a></li>\n<li><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_label4_3\">5.4、配置</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>正文</strong><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-1024x495.png?resize=640,309\" alt=\"Nexus搭建开发组的私有仓库 - 第1张  | 张嘎\"></p>\n<h1 id=\"一、私有仓库的价值\"><a href=\"#一、私有仓库的价值\" class=\"headerlink\" title=\"一、私有仓库的价值\"></a>一、私有仓库的价值</h1><p>　　开发Java应用系统，用到Maven、sbt和 Gradle等构建工具，在构建过程中一般需要从互联网下载依赖库，构建私有仓库就是为了在开发组或者部门内共用，从而节省整体的下载成本和构建成本。下面先以Maven为例说明。</p>\n<p>　　Maven是一个强大的构建工具，一般用于Java项目。Maven项目基于对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。</p>\n<p>Maven的Java项目一般需要下载第三方组件，下载后构成本地仓库，为了减少网络对构建项目的影响，一般会构建私服仓库，代理第三方库。Nexus就是构建私服仓库的优秀软件。</p>\n<p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220431849-1095286350.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第2张  | 张嘎\"></p>\n<p>图 1 三层仓库架构<a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"二、准备工作\"><a href=\"#二、准备工作\" class=\"headerlink\" title=\"二、准备工作\"></a>二、准备工作</h1><h2 id=\"2-1、安装Java编译环境\"><a href=\"#2-1、安装Java编译环境\" class=\"headerlink\" title=\"2.1、安装Java编译环境\"></a>2.1、安装Java编译环境</h2><p>Java编译环境包括核心的JDK和编译工具，因为Java的编译工具有很多种，而开源项目作者的随意性很高，常用的工具有maven，gradle,sbt，ant等等，本文关注Maven。</p>\n<p>因为Oracle不再维护Java1.7，所以采用Java 1.8作为编译核心.</p>\n<h3 id=\"2-1-1、安装\"><a href=\"#2-1-1、安装\" class=\"headerlink\" title=\"2.1.1、安装\"></a>2.1.1、安装</h3><p>操作系统采用Centos7.4</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install java-1.8.0-openjdk-devel java-1.8.0-openjdk java-1.8.0-openjdk-headless -y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2、验证\"><a href=\"#2-1-2、验证\" class=\"headerlink\" title=\"2.1.2、验证\"></a>2.1.2、验证</h3><p>查看jdk版本号</p>\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第3张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br><span class=\"line\">Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true</span><br><span class=\"line\">openjdk version &quot;1.8.0_131&quot;</span><br><span class=\"line\">OpenJDK Runtime Environment (build 1.8.0_131-b12)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第4张  | 张嘎\"></p>\n<h3 id=\"2-1-3、设置环境变量\"><a href=\"#2-1-3、设置环境变量\" class=\"headerlink\" title=\"2.1.3、设置环境变量\"></a>2.1.3、设置环境变量</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/usr/lib/jvm/java</span><br><span class=\"line\">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class=\"line\">export CLASSPATH=.:$JRE_HOME/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class=\"line\">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>即刻生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2、虚拟机访问互联网\"><a href=\"#2-2、虚拟机访问互联网\" class=\"headerlink\" title=\"2.2、虚拟机访问互联网\"></a>2.2、虚拟机访问互联网</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/sysconfig/network-scripts/ifcfg-ens32</span><br></pre></td></tr></table></figure>\n\n<p>注：环境不同网卡名会不同</p>\n<p>增加天津联通的DNS（注：作者在天津，请按个人本地的运行商做相应修改）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS1=202.99.96.68</span><br><span class=\"line\">DNS2=202.99.104.68</span><br></pre></td></tr></table></figure>\n\n<p>在实际测试中感觉天津电信的DNS更加靠谱，访问一些特殊网站返回的IP能够顺利访问，大家根据实践选择吧</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS1=219.150.32.132</span><br><span class=\"line\">DNS2=219.146.0.130</span><br></pre></td></tr></table></figure>\n\n<p>重新启动网络</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping www.163.com</span><br><span class=\"line\">PING 163.xdwscache.ourglb0.com (42.81.9.47) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=1 ttl=128 time=9.66 ms</span><br><span class=\"line\">64 bytes from 42.81.9.47 (42.81.9.47): icmp_seq=2 ttl=128 time=10.4 ms…</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"三、安装Nexus\"><a href=\"#三、安装Nexus\" class=\"headerlink\" title=\"三、安装Nexus\"></a>三、安装Nexus</h1><h2 id=\"3-1、下载nexus\"><a href=\"#3-1、下载nexus\" class=\"headerlink\" title=\"3.1、下载nexus\"></a>3.1、下载nexus</h2><p>从官方网站现在最新3.X版</p>\n<p><a href=\"https://www.sonatype.com/download-oss-sonatype\">https://www.sonatype.com/download-oss-sonatype</a></p>\n<p>下载（2018年3月）最新版nexus-3.9.0-01-unix.tar.gz （）</p>\n<h2 id=\"3-2、部署\"><a href=\"#3-2、部署\" class=\"headerlink\" title=\"3.2、部署\"></a>3.2、部署</h2><p>先规划存储私有仓库的目录，作者本机的/opt目录空间较多，所以以/opt为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /opt/scm</span><br><span class=\"line\">tar -xf ~/download/nexus-3.9.0-01-unix.tar.gz -C .</span><br></pre></td></tr></table></figure>\n\n<p>生成两个目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nexus-3.9.0-01</span><br><span class=\"line\">sonatype-work</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3、系统服务\"><a href=\"#3-3、系统服务\" class=\"headerlink\" title=\"3.3、系统服务\"></a>3.3、系统服务</h2><h3 id=\"3-3-1、编辑系统服务文件\"><a href=\"#3-3-1、编辑系统服务文件\" class=\"headerlink\" title=\"3.3.1、编辑系统服务文件\"></a>3.3.1、编辑系统服务文件</h3><p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第5张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/systemd/system/nexus.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=nexus service</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]Type=forking</span><br><span class=\"line\">LimitNOFILE=65536</span><br><span class=\"line\">ExecStart=/opt/scm/nexus-3.9.0-01/bin/nexus start</span><br><span class=\"line\">ExecStop=/opt/scm/nexus-3.9.0-01/bin/nexus stop</span><br><span class=\"line\">User=ansible</span><br><span class=\"line\">Restart=on-abort</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第6张  | 张嘎\"></p>\n<h3 id=\"3-3-2、设置为自启动服务\"><a href=\"#3-3-2、设置为自启动服务\" class=\"headerlink\" title=\"3.3.2、设置为自启动服务\"></a>3.3.2、设置为自启动服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl  daemon-reload</span><br><span class=\"line\">sudo systemctl start nexus.service</span><br><span class=\"line\">sudo systemctl status nexus.service</span><br><span class=\"line\">sudo systemctl enable nexus.service</span><br></pre></td></tr></table></figure>\n\n<p>启动报错：1./etc/systemd/system/nexus.service文件的user不对<br>2.修改/opt/scm/nexus/bin/nexus 启动的JAVA_HOME 如：INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/java/jdk1.8/</p>\n<p><a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"四、设置Nexus\"><a href=\"#四、设置Nexus\" class=\"headerlink\" title=\"四、设置Nexus\"></a>四、设置Nexus</h1><h2 id=\"4-1、浏览器登录\"><a href=\"#4-1、浏览器登录\" class=\"headerlink\" title=\"4.1、浏览器登录\"></a>4.1、浏览器登录</h2><p><a href=\"http://192.168.154.11:8081/\">http://192.168.154.11:8081/</a></p>\n<p><img src=\"https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220256240-534211558.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第7张  | 张嘎\"></p>\n<p>用户名的密码为：admin admin123</p>\n<h2 id=\"4-2、进入管理界面\"><a href=\"#4-2、进入管理界面\" class=\"headerlink\" title=\"4.2、进入管理界面\"></a>4.2、进入管理界面</h2><p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220317318-1530787694.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第8张  | 张嘎\"></p>\n<h2 id=\"4-3、增加新的代理源\"><a href=\"#4-3、增加新的代理源\" class=\"headerlink\" title=\"4.3、增加新的代理源\"></a>4.3、增加新的代理源</h2><p><img src=\"https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220331802-1557956595.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第9张  | 张嘎\"></p>\n<p>设置名称和URL</p>\n<p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220342224-1667350164.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第10张  | 张嘎\"></p>\n<p>Cache统一设置为200天 288000</p>\n<p><img src=\"https://i1.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220350271-1209294422.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第11张  | 张嘎\"></p>\n<p> 逐个增加常用代理</p>\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第12张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. aliyun</span><br><span class=\"line\">http://maven.aliyun.com/nexus/content/groups/public</span><br><span class=\"line\">2. apache_snapshot</span><br><span class=\"line\">https://repository.apache.org/content/repositories/snapshots/</span><br><span class=\"line\">3. apache_release</span><br><span class=\"line\">https://repository.apache.org/content/repositories/releases/</span><br><span class=\"line\">4. atlassian</span><br><span class=\"line\">https://maven.atlassian.com/content/repositories/atlassian-public/</span><br><span class=\"line\">5. central.maven.org</span><br><span class=\"line\">http://central.maven.org/maven2/</span><br><span class=\"line\">6. datanucleus</span><br><span class=\"line\">http://www.datanucleus.org/downloads/maven2</span><br><span class=\"line\">7. maven-central （安装后自带，仅需设置Cache有效期即可）</span><br><span class=\"line\">https://repo1.maven.org/maven2/</span><br><span class=\"line\">8. nexus.axiomalaska.com</span><br><span class=\"line\">http://nexus.axiomalaska.com/nexus/content/repositories/public</span><br><span class=\"line\">9. oss.sonatype.org</span><br><span class=\"line\">https://oss.sonatype.org/content/repositories/snapshots</span><br><span class=\"line\">10.pentaho</span><br><span class=\"line\">https://public.nexus.pentaho.org/content/groups/omni/</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第13张  | 张嘎\"></p>\n<p>再次强调，在</p>\n<p>How long (in minutes) to cache metadata before rechecking the remote repository.处</p>\n<p>统一设置为</p>\n<p>288000 即200天，当然可以设置为更长的时间</p>\n<p>设置maven-public</p>\n<p>将这些代理加入Group</p>\n<p><img src=\"https://i0.wp.com/images2017.cnblogs.com/blog/1082089/201710/1082089-20171022220400959-1653481781.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第14张  | 张嘎\"></p>\n<h2 id=\"4-3、设置私用仓库可重复发布\"><a href=\"#4-3、设置私用仓库可重复发布\" class=\"headerlink\" title=\"4.3、设置私用仓库可重复发布\"></a>4.3、设置私用仓库可重复发布</h2><p>　　Nexus安装后自带maven-releases，maven-snapshots两个仓库，用于将生成的jar包发布在这两个仓库中，在实际开发中需要将maven-releases设置为可以重复发布。</p>\n<p>　　maven-releases</p>\n<p><img src=\"https://i0.wp.com/images2018.cnblogs.com/blog/1082089/201803/1082089-20180317135112096-935379506.png?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第15张  | 张嘎\"></p>\n<p>　　注：maven-snapshots缺省是可以重新部署的。<a href=\"https://www.cnblogs.com/fanzhenyong/p/7709434.html#_labelTop\">回到顶部</a></p>\n<h1 id=\"五、安装maven并设置私用仓库\"><a href=\"#五、安装maven并设置私用仓库\" class=\"headerlink\" title=\"五、安装maven并设置私用仓库\"></a>五、安装maven并设置私用仓库</h1><h2 id=\"5-1、下载安装\"><a href=\"#5-1、下载安装\" class=\"headerlink\" title=\"5.1、下载安装\"></a>5.1、下载安装</h2><p>从maven官网下载3.5.0 <a href=\"http://maven.apache.org/download.cgi\">http://maven.apache.org/download.cgi</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd tools</span><br><span class=\"line\">tar -xf ../download/apache-maven-3.5.0-bin.tar.gz –C .</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2、设置环境变量\"><a href=\"#5-2、设置环境变量\" class=\"headerlink\" title=\"5.2、设置环境变量\"></a>5.2、设置环境变量</h2><p>vi ~/.bashrc</p>\n<p>增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=/home/ansible/tools/apache-maven-3.5.0/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>即刻生效</p>\n<p>source ~/.bashrc</p>\n<h2 id=\"5-3、测试\"><a href=\"#5-3、测试\" class=\"headerlink\" title=\"5.3、测试\"></a>5.3、测试</h2><p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第16张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -v</span><br><span class=\"line\"></span><br><span class=\"line\">Picked up _JAVA_OPTIONS: -Xmx2048m -XX:MaxMetaspaceSize=512m -Djava.awt.headless=true</span><br><span class=\"line\">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class=\"line\">Maven home: /home/ansible/tools/apache-maven-3.5.0</span><br><span class=\"line\">Java version: 1.8.0_102, vendor: Oracle Corporation</span><br><span class=\"line\">Java home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64/jre</span><br><span class=\"line\">Default locale: en_US, platform encoding: UTF-8</span><br><span class=\"line\">OS name: &quot;linux&quot;, version: &quot;3.10.0-514.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4、配置\"><a href=\"#5-4、配置\" class=\"headerlink\" title=\"5.4、配置\"></a>5.4、配置</h2><p>vi ~/tools/apache-maven-3.5.0/conf/settings.xml（本地服务器可以使用localhost，开发组其他服务器则修改为对应Nexus服务器的域名或者IP地址）</p>\n<p><img src=\"https://i0.wp.com/common.cnblogs.com/images/copycode.gif?w=640&ssl=1\" alt=\"Nexus搭建开发组的私有仓库 - 第17张  | 张嘎\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;settings&gt;</span><br><span class=\"line\">  &lt;pluginGroups&gt;  </span><br><span class=\"line\">     &lt;pluginGroup&gt;org.sonatype.plugins&lt;/pluginGroup&gt;  </span><br><span class=\"line\">  &lt;/pluginGroups&gt; </span><br><span class=\"line\">  &lt;mirrors&gt;</span><br><span class=\"line\">    &lt;mirror&gt;</span><br><span class=\"line\">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class=\"line\">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class=\"line\">      &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;</span><br><span class=\"line\">    &lt;/mirror&gt;</span><br><span class=\"line\">  &lt;/mirrors&gt;</span><br><span class=\"line\">  &lt;profiles&gt;</span><br><span class=\"line\">    &lt;profile&gt;</span><br><span class=\"line\">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class=\"line\">      &lt;!--Enable snapshots for the built in central repo to direct --&gt;</span><br><span class=\"line\">      &lt;!--all requests to nexus via the mirror --&gt;</span><br><span class=\"line\">      &lt;repositories&gt;</span><br><span class=\"line\">        &lt;repository&gt;</span><br><span class=\"line\">          &lt;id&gt;central&lt;/id&gt;</span><br><span class=\"line\">          &lt;url&gt;http://central&lt;/url&gt;</span><br><span class=\"line\">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class=\"line\">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class=\"line\">        &lt;/repository&gt;</span><br><span class=\"line\">      &lt;/repositories&gt;</span><br><span class=\"line\">     &lt;pluginRepositories&gt;</span><br><span class=\"line\">        &lt;pluginRepository&gt;</span><br><span class=\"line\">          &lt;id&gt;central&lt;/id&gt;</span><br><span class=\"line\">          &lt;url&gt;http://central&lt;/url&gt;</span><br><span class=\"line\">          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class=\"line\">          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class=\"line\">        &lt;/pluginRepository&gt;</span><br><span class=\"line\">      &lt;/pluginRepositories&gt;</span><br><span class=\"line\">    &lt;/profile&gt;</span><br><span class=\"line\">  &lt;/profiles&gt;</span><br><span class=\"line\">  &lt;activeProfiles&gt;</span><br><span class=\"line\">    &lt;!--make the profile active all the time --&gt;</span><br><span class=\"line\">    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;</span><br><span class=\"line\">  &lt;/activeProfiles&gt;</span><br><span class=\"line\">  &lt;servers&gt;</span><br><span class=\"line\">    &lt;server&gt;</span><br><span class=\"line\">      &lt;id&gt;nexus&lt;/id&gt;</span><br><span class=\"line\">      &lt;username&gt;admin&lt;/username&gt;</span><br><span class=\"line\">      &lt;password&gt;admin123&lt;/password&gt;</span><br><span class=\"line\">    &lt;/server&gt;</span><br><span class=\"line\">  &lt;/servers&gt;</span><br><span class=\"line\">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"服务器性能优化","date":"2021-08-31T15:55:21.000Z","id":"srv-optimize","_content":"\n*在一些高QPS的场景下，服务器可能面临的挑战和问题总结。*\n\n1. 服务器一定要有流控功能和降级预案，一些接口可以提供有损服务，最差情况只要保证核心业务不出问题。\n2. 梳理出各个关键接口在不可用时的表现，和处理方案，已经可能面临的问题，落实到文档，一步步攻坚。\n3. 核心业务和接口预估最高QPS，根据QPS指标做好全链路压测。\n4. 做好性能监控和报警，实时查看大盘数据。\n5. 最常出现性能瓶颈的地方：\n   - 登录，特别是注册新用户。流控限制服务的承载上限，一定不能超过当前服务的承载。流控触发后，前端进行友好的过渡，根据不同的游戏类型进行特定场景的处理，比如进行一局单机游戏。\n   - 针对一些更极端的场景，可预见的某个时间段，会有大量的用户登录和创建，前端不验证流控前，直接预先将登录进行打散。针对大量创建用户引起的数据库性能瓶颈问题，可以预先生成一大批新用户数据，放入缓存。\n   - 注意玩家退出或掉线的逻辑，是否有一些数据回写，判断是否会成为瓶颈。\n6. 数据库可能出现问题的地方：\n   - Mongo 提前关闭autosplit，movechunk，retryWrites。\n   - 数据库连接要预热。\n7. 前端要注意的一些点：\n   - 提供1到2个备用的资源CDN。\n   - 服务器提供两个一级域名和几个二级域名让客户端随机选取使用。\n   - 考虑前端SDK一些接口遇到性能瓶颈的情况，特别是登录验证，做好预案和降级处理。\n8. 日志在这种级别下也可能出现性能瓶颈，看下日志库还有没有可优化的地方，在最高峰可以允许短暂的将info级别日志关闭，流量下来之后尽快动态打开。\n9. 提前做好上线前的各种预案和上线流程，以及异常情况下的降级处理流程，责任到人，文档化，有迹可循，不慌乱。\n10. 检查最后是否还有遗漏的地方，特别是准备老用户或者压测未覆盖的场景，以及全服广播之类的。\n","source":"_posts/srv-optimize.md","raw":"---\ntitle: 服务器性能优化\ndate: 2021-08-31 23:55:21\ntags:\n  - 笔记\nid: srv-optimize\ncategories:\n  - 笔记\n---\n\n*在一些高QPS的场景下，服务器可能面临的挑战和问题总结。*\n\n1. 服务器一定要有流控功能和降级预案，一些接口可以提供有损服务，最差情况只要保证核心业务不出问题。\n2. 梳理出各个关键接口在不可用时的表现，和处理方案，已经可能面临的问题，落实到文档，一步步攻坚。\n3. 核心业务和接口预估最高QPS，根据QPS指标做好全链路压测。\n4. 做好性能监控和报警，实时查看大盘数据。\n5. 最常出现性能瓶颈的地方：\n   - 登录，特别是注册新用户。流控限制服务的承载上限，一定不能超过当前服务的承载。流控触发后，前端进行友好的过渡，根据不同的游戏类型进行特定场景的处理，比如进行一局单机游戏。\n   - 针对一些更极端的场景，可预见的某个时间段，会有大量的用户登录和创建，前端不验证流控前，直接预先将登录进行打散。针对大量创建用户引起的数据库性能瓶颈问题，可以预先生成一大批新用户数据，放入缓存。\n   - 注意玩家退出或掉线的逻辑，是否有一些数据回写，判断是否会成为瓶颈。\n6. 数据库可能出现问题的地方：\n   - Mongo 提前关闭autosplit，movechunk，retryWrites。\n   - 数据库连接要预热。\n7. 前端要注意的一些点：\n   - 提供1到2个备用的资源CDN。\n   - 服务器提供两个一级域名和几个二级域名让客户端随机选取使用。\n   - 考虑前端SDK一些接口遇到性能瓶颈的情况，特别是登录验证，做好预案和降级处理。\n8. 日志在这种级别下也可能出现性能瓶颈，看下日志库还有没有可优化的地方，在最高峰可以允许短暂的将info级别日志关闭，流量下来之后尽快动态打开。\n9. 提前做好上线前的各种预案和上线流程，以及异常情况下的降级处理流程，责任到人，文档化，有迹可循，不慌乱。\n10. 检查最后是否还有遗漏的地方，特别是准备老用户或者压测未覆盖的场景，以及全服广播之类的。\n","slug":"srv-optimize","published":1,"updated":"2021-09-02T02:03:39.153Z","_id":"ckt1g0lk00012hcmn3h5b236p","comments":1,"layout":"post","photos":[],"link":"","content":"<p><em>在一些高QPS的场景下，服务器可能面临的挑战和问题总结。</em></p>\n<ol>\n<li>服务器一定要有流控功能和降级预案，一些接口可以提供有损服务，最差情况只要保证核心业务不出问题。</li>\n<li>梳理出各个关键接口在不可用时的表现，和处理方案，已经可能面临的问题，落实到文档，一步步攻坚。</li>\n<li>核心业务和接口预估最高QPS，根据QPS指标做好全链路压测。</li>\n<li>做好性能监控和报警，实时查看大盘数据。</li>\n<li>最常出现性能瓶颈的地方：<ul>\n<li>登录，特别是注册新用户。流控限制服务的承载上限，一定不能超过当前服务的承载。流控触发后，前端进行友好的过渡，根据不同的游戏类型进行特定场景的处理，比如进行一局单机游戏。</li>\n<li>针对一些更极端的场景，可预见的某个时间段，会有大量的用户登录和创建，前端不验证流控前，直接预先将登录进行打散。针对大量创建用户引起的数据库性能瓶颈问题，可以预先生成一大批新用户数据，放入缓存。</li>\n<li>注意玩家退出或掉线的逻辑，是否有一些数据回写，判断是否会成为瓶颈。</li>\n</ul>\n</li>\n<li>数据库可能出现问题的地方：<ul>\n<li>Mongo 提前关闭autosplit，movechunk，retryWrites。</li>\n<li>数据库连接要预热。</li>\n</ul>\n</li>\n<li>前端要注意的一些点：<ul>\n<li>提供1到2个备用的资源CDN。</li>\n<li>服务器提供两个一级域名和几个二级域名让客户端随机选取使用。</li>\n<li>考虑前端SDK一些接口遇到性能瓶颈的情况，特别是登录验证，做好预案和降级处理。</li>\n</ul>\n</li>\n<li>日志在这种级别下也可能出现性能瓶颈，看下日志库还有没有可优化的地方，在最高峰可以允许短暂的将info级别日志关闭，流量下来之后尽快动态打开。</li>\n<li>提前做好上线前的各种预案和上线流程，以及异常情况下的降级处理流程，责任到人，文档化，有迹可循，不慌乱。</li>\n<li>检查最后是否还有遗漏的地方，特别是准备老用户或者压测未覆盖的场景，以及全服广播之类的。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><em>在一些高QPS的场景下，服务器可能面临的挑战和问题总结。</em></p>\n<ol>\n<li>服务器一定要有流控功能和降级预案，一些接口可以提供有损服务，最差情况只要保证核心业务不出问题。</li>\n<li>梳理出各个关键接口在不可用时的表现，和处理方案，已经可能面临的问题，落实到文档，一步步攻坚。</li>\n<li>核心业务和接口预估最高QPS，根据QPS指标做好全链路压测。</li>\n<li>做好性能监控和报警，实时查看大盘数据。</li>\n<li>最常出现性能瓶颈的地方：<ul>\n<li>登录，特别是注册新用户。流控限制服务的承载上限，一定不能超过当前服务的承载。流控触发后，前端进行友好的过渡，根据不同的游戏类型进行特定场景的处理，比如进行一局单机游戏。</li>\n<li>针对一些更极端的场景，可预见的某个时间段，会有大量的用户登录和创建，前端不验证流控前，直接预先将登录进行打散。针对大量创建用户引起的数据库性能瓶颈问题，可以预先生成一大批新用户数据，放入缓存。</li>\n<li>注意玩家退出或掉线的逻辑，是否有一些数据回写，判断是否会成为瓶颈。</li>\n</ul>\n</li>\n<li>数据库可能出现问题的地方：<ul>\n<li>Mongo 提前关闭autosplit，movechunk，retryWrites。</li>\n<li>数据库连接要预热。</li>\n</ul>\n</li>\n<li>前端要注意的一些点：<ul>\n<li>提供1到2个备用的资源CDN。</li>\n<li>服务器提供两个一级域名和几个二级域名让客户端随机选取使用。</li>\n<li>考虑前端SDK一些接口遇到性能瓶颈的情况，特别是登录验证，做好预案和降级处理。</li>\n</ul>\n</li>\n<li>日志在这种级别下也可能出现性能瓶颈，看下日志库还有没有可优化的地方，在最高峰可以允许短暂的将info级别日志关闭，流量下来之后尽快动态打开。</li>\n<li>提前做好上线前的各种预案和上线流程，以及异常情况下的降级处理流程，责任到人，文档化，有迹可循，不慌乱。</li>\n<li>检查最后是否还有遗漏的地方，特别是准备老用户或者压测未覆盖的场景，以及全服广播之类的。</li>\n</ol>\n"},{"title":"WordPress上传权限问题及主题","date":"2018-10-11T12:19:37.000Z","id":"wordpress","_content":"\n[![htjgKI.md.png](https://z3.ax1x.com/2021/08/30/htjgKI.md.png)](https://imgtu.com/i/htjgKI)\n\n<!--more-->\n\n打开所有写权限\n\nchmod 777 /usr/local/lampp/htdocs/zzq/\n\n修改文件夹所属用户组。查看用户组指令：cat /etc/group   别人都是www:www  我是daemon\n\nchown -R daemon:daemon zzq\n\n还原文件夹权限\n\nchmod 755 /usr/local/lampp/htdocs/zzq/\n\n## 主题网站\n\nhttp://ztmao.com/\n","source":"_posts/wordpress.md","raw":"---\ntitle: WordPress上传权限问题及主题\ndate: 2018-10-11 20:19:37\ntags:\n  - 笔记\nid: wordpress\ncategories:\n  - 笔记\n---\n\n[![htjgKI.md.png](https://z3.ax1x.com/2021/08/30/htjgKI.md.png)](https://imgtu.com/i/htjgKI)\n\n<!--more-->\n\n打开所有写权限\n\nchmod 777 /usr/local/lampp/htdocs/zzq/\n\n修改文件夹所属用户组。查看用户组指令：cat /etc/group   别人都是www:www  我是daemon\n\nchown -R daemon:daemon zzq\n\n还原文件夹权限\n\nchmod 755 /usr/local/lampp/htdocs/zzq/\n\n## 主题网站\n\nhttp://ztmao.com/\n","slug":"wordpress","published":1,"updated":"2021-08-30T14:13:34.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lk20015hcmn11qg84nr","content":"<p><a href=\"https://imgtu.com/i/htjgKI\"><img src=\"https://z3.ax1x.com/2021/08/30/htjgKI.md.png\" alt=\"htjgKI.md.png\"></a></p>\n<span id=\"more\"></span>\n\n<p>打开所有写权限</p>\n<p>chmod 777 /usr/local/lampp/htdocs/zzq/</p>\n<p>修改文件夹所属用户组。查看用户组指令：cat /etc/group   别人都是www:www  我是daemon</p>\n<p>chown -R daemon:daemon zzq</p>\n<p>还原文件夹权限</p>\n<p>chmod 755 /usr/local/lampp/htdocs/zzq/</p>\n<h2 id=\"主题网站\"><a href=\"#主题网站\" class=\"headerlink\" title=\"主题网站\"></a>主题网站</h2><p><a href=\"http://ztmao.com/\">http://ztmao.com/</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://imgtu.com/i/htjgKI\"><img src=\"https://z3.ax1x.com/2021/08/30/htjgKI.md.png\" alt=\"htjgKI.md.png\"></a></p>","more":"<p>打开所有写权限</p>\n<p>chmod 777 /usr/local/lampp/htdocs/zzq/</p>\n<p>修改文件夹所属用户组。查看用户组指令：cat /etc/group   别人都是www:www  我是daemon</p>\n<p>chown -R daemon:daemon zzq</p>\n<p>还原文件夹权限</p>\n<p>chmod 755 /usr/local/lampp/htdocs/zzq/</p>\n<h2 id=\"主题网站\"><a href=\"#主题网站\" class=\"headerlink\" title=\"主题网站\"></a>主题网站</h2><p><a href=\"http://ztmao.com/\">http://ztmao.com/</a></p>"},{"title":"沙盒游戏3D场景建模","date":"2018-10-19T14:13:52.000Z","id":"sandbox-scene","_content":"\n在一次聚餐之后，晚上睡觉前突然灵感爆棚想到的实现方案。\n\n下面是在项目内部分享的PPT，具体代码实现在github：https://github.com/zhangga/JAVAZSet\n\n[![hNUOo9.md.png](https://z3.ax1x.com/2021/08/30/hNUOo9.md.png)](https://imgtu.com/i/hNUOo9)\n\n<!--more-->\n\n[![hNULdJ.md.png](https://z3.ax1x.com/2021/08/30/hNULdJ.md.png)](https://imgtu.com/i/hNULdJ)\n\n[![hNUjiR.md.png](https://z3.ax1x.com/2021/08/30/hNUjiR.md.png)](https://imgtu.com/i/hNUjiR)\n\n## 实际碰到的一点问题：\n\n1.把9张1024*1024的navmesh合一张的时候，原生的recast是用32位分配空间，其中14位分配给tile，所以tile有上限的考虑。\n\n现在把recast改为用64位表示，需要宏定义。在DetourNavMesh.h中定义 #define DT_POLYREF64 1\n\n这样tile就有28位了，不太存在超过上限的可能了。\n\n发现问题。改完之后的dll在加载新地图的时候，内存直接飙升。\n\n打印输出，定位到问题发生在，dtLoadNavMesh时读取到的tile的内存size值不正常，导致内存申请异常。\n\n至此问题已经定位，navmesh文件格式和读取的格式不一致，数据错位，读取异常。\n\n进一步跟踪，发现是C++ struct内存对齐不同导致的。客户端生成默认是8，服务器读取是按4，结果服务器少读4字节。\n\n在DetourInit.h文件中有如下代码：#pragma pack(push,4) 控制，前后端修改一致即可。\n\nppt在GitHub上。[JavaZSet](https://github.com/zhangga/JAVAZSet)\n","source":"_posts/sandbox-scene.md","raw":"---\ntitle: 沙盒游戏3D场景建模\ndate: 2018-10-19 22:13:52\ntags:\n  - 笔记\nid: sandbox-scene\ncategories:\n  - 笔记\n---\n\n在一次聚餐之后，晚上睡觉前突然灵感爆棚想到的实现方案。\n\n下面是在项目内部分享的PPT，具体代码实现在github：https://github.com/zhangga/JAVAZSet\n\n[![hNUOo9.md.png](https://z3.ax1x.com/2021/08/30/hNUOo9.md.png)](https://imgtu.com/i/hNUOo9)\n\n<!--more-->\n\n[![hNULdJ.md.png](https://z3.ax1x.com/2021/08/30/hNULdJ.md.png)](https://imgtu.com/i/hNULdJ)\n\n[![hNUjiR.md.png](https://z3.ax1x.com/2021/08/30/hNUjiR.md.png)](https://imgtu.com/i/hNUjiR)\n\n## 实际碰到的一点问题：\n\n1.把9张1024*1024的navmesh合一张的时候，原生的recast是用32位分配空间，其中14位分配给tile，所以tile有上限的考虑。\n\n现在把recast改为用64位表示，需要宏定义。在DetourNavMesh.h中定义 #define DT_POLYREF64 1\n\n这样tile就有28位了，不太存在超过上限的可能了。\n\n发现问题。改完之后的dll在加载新地图的时候，内存直接飙升。\n\n打印输出，定位到问题发生在，dtLoadNavMesh时读取到的tile的内存size值不正常，导致内存申请异常。\n\n至此问题已经定位，navmesh文件格式和读取的格式不一致，数据错位，读取异常。\n\n进一步跟踪，发现是C++ struct内存对齐不同导致的。客户端生成默认是8，服务器读取是按4，结果服务器少读4字节。\n\n在DetourInit.h文件中有如下代码：#pragma pack(push,4) 控制，前后端修改一致即可。\n\nppt在GitHub上。[JavaZSet](https://github.com/zhangga/JAVAZSet)\n","slug":"sandbox-scene","published":1,"updated":"2021-09-01T11:28:49.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lk40018hcmn3yqhhm1j","content":"<p>在一次聚餐之后，晚上睡觉前突然灵感爆棚想到的实现方案。</p>\n<p>下面是在项目内部分享的PPT，具体代码实现在github：<a href=\"https://github.com/zhangga/JAVAZSet\">https://github.com/zhangga/JAVAZSet</a></p>\n<p><a href=\"https://imgtu.com/i/hNUOo9\"><img src=\"https://z3.ax1x.com/2021/08/30/hNUOo9.md.png\" alt=\"hNUOo9.md.png\"></a></p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://imgtu.com/i/hNULdJ\"><img src=\"https://z3.ax1x.com/2021/08/30/hNULdJ.md.png\" alt=\"hNULdJ.md.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/hNUjiR\"><img src=\"https://z3.ax1x.com/2021/08/30/hNUjiR.md.png\" alt=\"hNUjiR.md.png\"></a></p>\n<h2 id=\"实际碰到的一点问题：\"><a href=\"#实际碰到的一点问题：\" class=\"headerlink\" title=\"实际碰到的一点问题：\"></a>实际碰到的一点问题：</h2><p>1.把9张1024*1024的navmesh合一张的时候，原生的recast是用32位分配空间，其中14位分配给tile，所以tile有上限的考虑。</p>\n<p>现在把recast改为用64位表示，需要宏定义。在DetourNavMesh.h中定义 #define DT_POLYREF64 1</p>\n<p>这样tile就有28位了，不太存在超过上限的可能了。</p>\n<p>发现问题。改完之后的dll在加载新地图的时候，内存直接飙升。</p>\n<p>打印输出，定位到问题发生在，dtLoadNavMesh时读取到的tile的内存size值不正常，导致内存申请异常。</p>\n<p>至此问题已经定位，navmesh文件格式和读取的格式不一致，数据错位，读取异常。</p>\n<p>进一步跟踪，发现是C++ struct内存对齐不同导致的。客户端生成默认是8，服务器读取是按4，结果服务器少读4字节。</p>\n<p>在DetourInit.h文件中有如下代码：#pragma pack(push,4) 控制，前后端修改一致即可。</p>\n<p>ppt在GitHub上。<a href=\"https://github.com/zhangga/JAVAZSet\">JavaZSet</a></p>\n","site":{"data":{}},"excerpt":"<p>在一次聚餐之后，晚上睡觉前突然灵感爆棚想到的实现方案。</p>\n<p>下面是在项目内部分享的PPT，具体代码实现在github：<a href=\"https://github.com/zhangga/JAVAZSet\">https://github.com/zhangga/JAVAZSet</a></p>\n<p><a href=\"https://imgtu.com/i/hNUOo9\"><img src=\"https://z3.ax1x.com/2021/08/30/hNUOo9.md.png\" alt=\"hNUOo9.md.png\"></a></p>","more":"<p><a href=\"https://imgtu.com/i/hNULdJ\"><img src=\"https://z3.ax1x.com/2021/08/30/hNULdJ.md.png\" alt=\"hNULdJ.md.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/hNUjiR\"><img src=\"https://z3.ax1x.com/2021/08/30/hNUjiR.md.png\" alt=\"hNUjiR.md.png\"></a></p>\n<h2 id=\"实际碰到的一点问题：\"><a href=\"#实际碰到的一点问题：\" class=\"headerlink\" title=\"实际碰到的一点问题：\"></a>实际碰到的一点问题：</h2><p>1.把9张1024*1024的navmesh合一张的时候，原生的recast是用32位分配空间，其中14位分配给tile，所以tile有上限的考虑。</p>\n<p>现在把recast改为用64位表示，需要宏定义。在DetourNavMesh.h中定义 #define DT_POLYREF64 1</p>\n<p>这样tile就有28位了，不太存在超过上限的可能了。</p>\n<p>发现问题。改完之后的dll在加载新地图的时候，内存直接飙升。</p>\n<p>打印输出，定位到问题发生在，dtLoadNavMesh时读取到的tile的内存size值不正常，导致内存申请异常。</p>\n<p>至此问题已经定位，navmesh文件格式和读取的格式不一致，数据错位，读取异常。</p>\n<p>进一步跟踪，发现是C++ struct内存对齐不同导致的。客户端生成默认是8，服务器读取是按4，结果服务器少读4字节。</p>\n<p>在DetourInit.h文件中有如下代码：#pragma pack(push,4) 控制，前后端修改一致即可。</p>\n<p>ppt在GitHub上。<a href=\"https://github.com/zhangga/JAVAZSet\">JavaZSet</a></p>"},{"title":"JAVA版ZSet性能测试","date":"2018-12-28T11:37:35.000Z","id":"zset","_content":"\n自己实现的JAVA版ZSet的主要功能，源码在github：\n\nhttps://github.com/zhangga/JAVAZSet\n\n[![hBs35t.md.png](https://z3.ax1x.com/2021/09/01/hBs35t.md.png)](https://imgtu.com/i/hBs35t)\n\n性能测试：\n\n下面数据都是在本地windows下执行10次的评价值：JVM10G + i7-8700开着各种应用。Eclipse Run 预热几次稳定后。\n\n### ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\n\n获取1000-3000分值的数据，执行1W次，\n\n取样10次用时ms：6604+6490+6648+6602+7718+7626+6682+7498+6588+7358=69814/10=6981\n\n### ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\n\n获取1000-3000分值的数据，执行1W次，\n\n取样10次用时ms：7594+8279+8622+8476+7810+7397+7241+8579+8019+8554=80571/10=8057\n\n### ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\n\n## 获取高度方法性能测试：\n\n1.使用ZSet获取附近的障碍物，判断是否在障碍物内，获取障碍物高度。\n\n测试用例，在一处放置11个圆形障碍物，搜索2米范围内的障碍物，获取高度。100W次测试，用时在450ms-500ms之间。\n\n2.使用一个正常地图（37号场景）的navmesh数据，recast的获取高度。100W次测试，用时在1000ms-1100ms之间。\n","source":"_posts/zset.md","raw":"---\ntitle: JAVA版ZSet性能测试\ndate: 2018-12-28 19:37:35\ntags:\n  - 笔记\nid: zset\ncategories:\n  - 笔记\n---\n\n自己实现的JAVA版ZSet的主要功能，源码在github：\n\nhttps://github.com/zhangga/JAVAZSet\n\n[![hBs35t.md.png](https://z3.ax1x.com/2021/09/01/hBs35t.md.png)](https://imgtu.com/i/hBs35t)\n\n性能测试：\n\n下面数据都是在本地windows下执行10次的评价值：JVM10G + i7-8700开着各种应用。Eclipse Run 预热几次稳定后。\n\n### ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\n\n获取1000-3000分值的数据，执行1W次，\n\n取样10次用时ms：6604+6490+6648+6602+7718+7626+6682+7498+6588+7358=69814/10=6981\n\n### ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\n\n获取1000-3000分值的数据，执行1W次，\n\n取样10次用时ms：7594+8279+8622+8476+7810+7397+7241+8579+8019+8554=80571/10=8057\n\n### ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\n\n## 获取高度方法性能测试：\n\n1.使用ZSet获取附近的障碍物，判断是否在障碍物内，获取障碍物高度。\n\n测试用例，在一处放置11个圆形障碍物，搜索2米范围内的障碍物，获取高度。100W次测试，用时在450ms-500ms之间。\n\n2.使用一个正常地图（37号场景）的navmesh数据，recast的获取高度。100W次测试，用时在1000ms-1100ms之间。\n","slug":"zset","published":1,"updated":"2021-09-01T11:39:00.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lk6001bhcmn7fx13cvt","content":"<p>自己实现的JAVA版ZSet的主要功能，源码在github：</p>\n<p><a href=\"https://github.com/zhangga/JAVAZSet\">https://github.com/zhangga/JAVAZSet</a></p>\n<p><a href=\"https://imgtu.com/i/hBs35t\"><img src=\"https://z3.ax1x.com/2021/09/01/hBs35t.md.png\" alt=\"hBs35t.md.png\"></a></p>\n<p>性能测试：</p>\n<p>下面数据都是在本地windows下执行10次的评价值：JVM10G + i7-8700开着各种应用。Eclipse Run 预热几次稳定后。</p>\n<h3 id=\"ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"><a href=\"#ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\" class=\"headerlink\" title=\"ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"></a>ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。</h3><p>获取1000-3000分值的数据，执行1W次，</p>\n<p>取样10次用时ms：6604+6490+6648+6602+7718+7626+6682+7498+6588+7358=69814/10=6981</p>\n<h3 id=\"ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"><a href=\"#ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\" class=\"headerlink\" title=\"ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"></a>ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。</h3><p>获取1000-3000分值的数据，执行1W次，</p>\n<p>取样10次用时ms：7594+8279+8622+8476+7810+7397+7241+8579+8019+8554=80571/10=8057</p>\n<h3 id=\"ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\"><a href=\"#ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\" class=\"headerlink\" title=\"ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\"></a>ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。</h3><h2 id=\"获取高度方法性能测试：\"><a href=\"#获取高度方法性能测试：\" class=\"headerlink\" title=\"获取高度方法性能测试：\"></a>获取高度方法性能测试：</h2><p>1.使用ZSet获取附近的障碍物，判断是否在障碍物内，获取障碍物高度。</p>\n<p>测试用例，在一处放置11个圆形障碍物，搜索2米范围内的障碍物，获取高度。100W次测试，用时在450ms-500ms之间。</p>\n<p>2.使用一个正常地图（37号场景）的navmesh数据，recast的获取高度。100W次测试，用时在1000ms-1100ms之间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自己实现的JAVA版ZSet的主要功能，源码在github：</p>\n<p><a href=\"https://github.com/zhangga/JAVAZSet\">https://github.com/zhangga/JAVAZSet</a></p>\n<p><a href=\"https://imgtu.com/i/hBs35t\"><img src=\"https://z3.ax1x.com/2021/09/01/hBs35t.md.png\" alt=\"hBs35t.md.png\"></a></p>\n<p>性能测试：</p>\n<p>下面数据都是在本地windows下执行10次的评价值：JVM10G + i7-8700开着各种应用。Eclipse Run 预热几次稳定后。</p>\n<h3 id=\"ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"><a href=\"#ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\" class=\"headerlink\" title=\"ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"></a>ZSet使用TreeMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。</h3><p>获取1000-3000分值的数据，执行1W次，</p>\n<p>取样10次用时ms：6604+6490+6648+6602+7718+7626+6682+7498+6588+7358=69814/10=6981</p>\n<h3 id=\"ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"><a href=\"#ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\" class=\"headerlink\" title=\"ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。\"></a>ZSet使用ConcurrentSkipListMap、list的组合存放分值信息。100W条总数据，分值为1W（0-9999）个，这样平均相同分值会有100条数据在list中。</h3><p>获取1000-3000分值的数据，执行1W次，</p>\n<p>取样10次用时ms：7594+8279+8622+8476+7810+7397+7241+8579+8019+8554=80571/10=8057</p>\n<h3 id=\"ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\"><a href=\"#ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\" class=\"headerlink\" title=\"ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。\"></a>ZSet不需要线程安全的情形下使用TreeMap的效率会更高点。</h3><h2 id=\"获取高度方法性能测试：\"><a href=\"#获取高度方法性能测试：\" class=\"headerlink\" title=\"获取高度方法性能测试：\"></a>获取高度方法性能测试：</h2><p>1.使用ZSet获取附近的障碍物，判断是否在障碍物内，获取障碍物高度。</p>\n<p>测试用例，在一处放置11个圆形障碍物，搜索2米范围内的障碍物，获取高度。100W次测试，用时在450ms-500ms之间。</p>\n<p>2.使用一个正常地图（37号场景）的navmesh数据，recast的获取高度。100W次测试，用时在1000ms-1100ms之间。</p>\n"},{"title":"垃圾回收器G1详解","date":"2021-09-01T05:50:42.000Z","id":"garbage-first","_content":"\n转载自：[JVM七大垃圾回收器下篇G1(Garbage First)](https://www.cnblogs.com/yanl55555/p/13366387.html)\n\n# G1回收器:区域化分代式\n\n**既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？**\n  原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。\n  与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。\n  官方给G1设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量（高吞吐），所以才担当起“全功能收集器”的重任与期望。\n\n<!--more-->\n\n## **为什么名字叫做Garbage First （G1）呢？**\n\n- 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region） （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。\n- G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。\n- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。\n- G1 （Garbage一First） 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。\n- 在JDK1. 7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel 0ld组合。被Oracle官方称为“全功能的垃圾收集器” 。\n- 与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） 。\n- G1在jdk8中还不是默认的垃圾回收器，需要使用一XX： +UseG1GC来启用。\n\n## G1垃圾回收器优势\n\n与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：四个特点：\n\n- 并行与并发\n  - ➢并行性： G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW\n  - ➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况\n- 分代收集\n  - ➢从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n  - ➢将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。\n  - ➢和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144423293-687202683.png)![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144442615-1696089988.png)\n\n \n\n \n\n- 空间整合\n\n- - ➢CMS： “标记一清除”算法、内存碎片、若干次Gc后进行一次碎片整理\n  - ➢G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法。\n  - 但整体上实际可看作是标记一压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。\n\n- 可预测的停顿时间模型（即：软实时soft real一time）\n\n  ： 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。\n\n  - ➢由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。\n  - ➢G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以 及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。\n  - ➢相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要.好很多。\n\n## G1缺点\n\n- 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。\n- 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。\n\n## G1参数设置\n\n- -XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。\n- -XX：G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。\n- -XX：MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms\n- -xX：ParallelGCThread 设置sTw.工作线程数的值。最多设置为8\n- -XX：ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。\n- -XX：Ini tiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。\n\n## G1回收器的常见操作步骤\n\nG1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：\n\n- 第一步：开启G1垃圾收集器\n- 第二步：设置堆的最大内存\n- 第三步：设置最大的停顿时间\n\nG1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。（后文详细讲）\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723143818066-1702622040.png)\n\n## G1适用场景\n\n- 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）\n- 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；\n- 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。\n- 用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：\n  ①超过50%的Java堆被活动数据占用；\n  ②对象分配频率或年代提升频率变化很大；\n  ③GC停顿时间过长（长于0. 5至1秒）。\n- HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC（线程优先级低）的多线程操作\n- 而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。\n\n## 分区region,化整为零\n\n使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。\n\n可以通过一 XX：G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。\n\n虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑_上的连续。\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723150834993-49164173.png)\n\n- 一个region 有可能属于Eden， Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。\n- G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。\n- 设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。\n\n# G1回收器垃圾回收过程\n\nG1 GC的垃圾回收过程主要包括如下三个环节：\n\n- 年轻代GC （Young GC ）\n- 老年代并发标记过程（ Concurrent Marking）\n- 混合回收（Mixed GC ）\n- （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723151103477-1084742760.png)\n\n 顺时针， young gc 一> young gc + concurrent mark 一> Mixed GC顺序，进行垃圾回收。\n\n1.应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的（多个回收线程）独占式(STW)收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。\n\n2.当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。\n\n3.标记完成马.上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起 被回收的。\n\n举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31 个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。\n\n## 记忆集与写屏障\n\n- 一个对象被不同区域引用的问题(分代引用问题)\n- 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？\n- 在其他的分代收集器，也存在这样的问题（ 而G1更突出）\n- 回收新生代也不得不同时扫描老年代？\n- 这样的话会降低MinorGC的效率；\n\n**·解决方法：**\n\n- ➢无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：\n- ➢每个Region都有 一个对应的Remembered Set；\n- ➢每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .\n- ➢然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；\n- ➢如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；\n- ➢当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723152028598-2055678824.png)\n\n# G1回收过程详解\n\n## 过程1年轻代GC\n\n- JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。\n- 年轻代垃圾回收只会回收Eden区（主动）和Survivor区（被动）。\n- YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。\n- 复制算法（S、E-->空闲区相当于To区）（S-->寻找新的空闲区作为老年代）\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723153515525-318612700.png)\n\n然后开始如下回收过程：\n\n- 第一阶段，扫描根\n  - 根是：指static变量指向的对象（类生命周期，方法区引用的对象），正在执行的方法调用链条上的局部变量等（方法生命周期，虚拟机栈引用的对象）。根引用连同RSet记录的外部引用作为扫描存活对象的入口。\n- **第二阶段，更新RSet**\n\n​     处理dirty card queue（ 见备注）中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。\n\n- - dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。\n  - 在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。\n  - 那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。\n\n- **第三阶段，处理RSet**。\n  识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。\n- **第四阶段，复制对象**。\n  此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。\n- **第五阶段，处理引用**。\n  处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。\n\n## 过程2年轻代GC+并发标记过程\n\n- 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一.次年轻代GC。\n- 根区域扫描（Root Region Scanning） ： G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。\n- 并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。\n- 再次标记（Remark）： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。\n- 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。\n  - ➢这个阶段并不会实际上去做垃圾的收集\n- 并发清理阶段：识别并清理完全空闲的区域。\n\n## 过程3混合回收\n\n当越来越多的对象晋升到老年代Oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个OldGC，除了回收整个Young Region，还会回收一部分的0ldRegion。这里需要注意：是一部分老年代， 而不是全部老年代。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。\n\n- 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过一XX： G1MixedGCCountTarget设置）被回收。\n- 混合回收的回收集（Collection Set） 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。\n- 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，一xX： G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。\n- 混合回收并不一定要进行8次。有一个阈值一Xx： G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。\n\n## 过程4Full GC\n\nG1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。\n要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。\n导致G1Full GC的原因可能有两个：\n\n- 1.Evacuation的时候没有足够的to一 space来存放晋升的对象；\n- 2.并发处理过程完成之前空间耗尽。\n\n**补充：**\n\n从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实.本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。\n\n# G1回收器优化建议\n\n- 年轻代大小\n  - ➢避免使用一Xmn或一XX：NewRatio等相关选项显式设置年轻代大小➢固定年轻代的大小会覆盖暂停时间目标\n- 暂停时间目标不要太过严苛\n  - G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间\n  - 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。\n\n# 7种经典的垃圾回收器总结\n\n截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723155737552-624347732.png)\n\n \n\n 不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合（连线），如下图：\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723160245863-1482952705.png)\n\n- 1.两个收集器间有连线，表明它们可以搭配使用： Serial/Serial 0ld、Serial /CMS、ParNew/Serial 0ld、ParNew/CMS、 Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；\n- 2.其中Serial 0ld作 为CMS出现\"Concurrent Mode Failure\"失败 的后备预案。\n- 3.（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial 0ld这两个组合声明为Deprecated （JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。\n- 4.（绿色虚线）JDK 14中：弃用ParallelScavenge 和Serial0ld GC组合 （JEP 366）\n- 5.（青色虚线）JDK 14中：删除CMS垃圾回收器 （JEP 363 ） GC发展阶段： Serial => Parallel （并行） => CMS （并发） => G1 => ZGC\n\n## **怎么选择垃圾回收器**\n\n- Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。\n- 怎么选择垃圾收集器？\n  - 1.优先调整堆的大小让JVM自适应完成。\n  - 2.如果内存小于100M，使用串行收集器\n  - 3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器\n  - 4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择\n  - 5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器\n  - 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。\n- 最后需要明确一一个观点：\n  - 1.没有最好的收集器，更没有万能的收集；\n  - 2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器\n\n","source":"_posts/garbage-first.md","raw":"---\ntitle: 垃圾回收器G1详解\ndate: 2021-09-01 13:50:42\ntags:\n  - 笔记\nid: garbage-first\ncategories:\n  - 笔记\n---\n\n转载自：[JVM七大垃圾回收器下篇G1(Garbage First)](https://www.cnblogs.com/yanl55555/p/13366387.html)\n\n# G1回收器:区域化分代式\n\n**既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？**\n  原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。\n  与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。\n  官方给G1设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量（高吞吐），所以才担当起“全功能收集器”的重任与期望。\n\n<!--more-->\n\n## **为什么名字叫做Garbage First （G1）呢？**\n\n- 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region） （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。\n- G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。\n- 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。\n- G1 （Garbage一First） 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。\n- 在JDK1. 7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel 0ld组合。被Oracle官方称为“全功能的垃圾收集器” 。\n- 与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） 。\n- G1在jdk8中还不是默认的垃圾回收器，需要使用一XX： +UseG1GC来启用。\n\n## G1垃圾回收器优势\n\n与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：四个特点：\n\n- 并行与并发\n  - ➢并行性： G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW\n  - ➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况\n- 分代收集\n  - ➢从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n  - ➢将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。\n  - ➢和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144423293-687202683.png)![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144442615-1696089988.png)\n\n \n\n \n\n- 空间整合\n\n- - ➢CMS： “标记一清除”算法、内存碎片、若干次Gc后进行一次碎片整理\n  - ➢G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法。\n  - 但整体上实际可看作是标记一压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。\n\n- 可预测的停顿时间模型（即：软实时soft real一time）\n\n  ： 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。\n\n  - ➢由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。\n  - ➢G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以 及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。\n  - ➢相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要.好很多。\n\n## G1缺点\n\n- 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。\n- 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。\n\n## G1参数设置\n\n- -XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。\n- -XX：G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。\n- -XX：MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms\n- -xX：ParallelGCThread 设置sTw.工作线程数的值。最多设置为8\n- -XX：ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。\n- -XX：Ini tiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。\n\n## G1回收器的常见操作步骤\n\nG1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：\n\n- 第一步：开启G1垃圾收集器\n- 第二步：设置堆的最大内存\n- 第三步：设置最大的停顿时间\n\nG1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。（后文详细讲）\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723143818066-1702622040.png)\n\n## G1适用场景\n\n- 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）\n- 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；\n- 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。\n- 用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：\n  ①超过50%的Java堆被活动数据占用；\n  ②对象分配频率或年代提升频率变化很大；\n  ③GC停顿时间过长（长于0. 5至1秒）。\n- HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC（线程优先级低）的多线程操作\n- 而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。\n\n## 分区region,化整为零\n\n使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。\n\n可以通过一 XX：G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。\n\n虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑_上的连续。\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723150834993-49164173.png)\n\n- 一个region 有可能属于Eden， Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。\n- G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。\n- 设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。\n\n# G1回收器垃圾回收过程\n\nG1 GC的垃圾回收过程主要包括如下三个环节：\n\n- 年轻代GC （Young GC ）\n- 老年代并发标记过程（ Concurrent Marking）\n- 混合回收（Mixed GC ）\n- （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723151103477-1084742760.png)\n\n 顺时针， young gc 一> young gc + concurrent mark 一> Mixed GC顺序，进行垃圾回收。\n\n1.应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的（多个回收线程）独占式(STW)收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。\n\n2.当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。\n\n3.标记完成马.上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起 被回收的。\n\n举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31 个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。\n\n## 记忆集与写屏障\n\n- 一个对象被不同区域引用的问题(分代引用问题)\n- 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？\n- 在其他的分代收集器，也存在这样的问题（ 而G1更突出）\n- 回收新生代也不得不同时扫描老年代？\n- 这样的话会降低MinorGC的效率；\n\n**·解决方法：**\n\n- ➢无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：\n- ➢每个Region都有 一个对应的Remembered Set；\n- ➢每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .\n- ➢然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；\n- ➢如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；\n- ➢当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723152028598-2055678824.png)\n\n# G1回收过程详解\n\n## 过程1年轻代GC\n\n- JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。\n- 年轻代垃圾回收只会回收Eden区（主动）和Survivor区（被动）。\n- YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。\n- 复制算法（S、E-->空闲区相当于To区）（S-->寻找新的空闲区作为老年代）\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723153515525-318612700.png)\n\n然后开始如下回收过程：\n\n- 第一阶段，扫描根\n  - 根是：指static变量指向的对象（类生命周期，方法区引用的对象），正在执行的方法调用链条上的局部变量等（方法生命周期，虚拟机栈引用的对象）。根引用连同RSet记录的外部引用作为扫描存活对象的入口。\n- **第二阶段，更新RSet**\n\n​     处理dirty card queue（ 见备注）中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。\n\n- - dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。\n  - 在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。\n  - 那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。\n\n- **第三阶段，处理RSet**。\n  识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。\n- **第四阶段，复制对象**。\n  此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。\n- **第五阶段，处理引用**。\n  处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。\n\n## 过程2年轻代GC+并发标记过程\n\n- 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一.次年轻代GC。\n- 根区域扫描（Root Region Scanning） ： G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。\n- 并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。\n- 再次标记（Remark）： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。\n- 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。\n  - ➢这个阶段并不会实际上去做垃圾的收集\n- 并发清理阶段：识别并清理完全空闲的区域。\n\n## 过程3混合回收\n\n当越来越多的对象晋升到老年代Oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个OldGC，除了回收整个Young Region，还会回收一部分的0ldRegion。这里需要注意：是一部分老年代， 而不是全部老年代。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。\n\n- 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过一XX： G1MixedGCCountTarget设置）被回收。\n- 混合回收的回收集（Collection Set） 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。\n- 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，一xX： G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。\n- 混合回收并不一定要进行8次。有一个阈值一Xx： G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。\n\n## 过程4Full GC\n\nG1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。\n要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。\n导致G1Full GC的原因可能有两个：\n\n- 1.Evacuation的时候没有足够的to一 space来存放晋升的对象；\n- 2.并发处理过程完成之前空间耗尽。\n\n**补充：**\n\n从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实.本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。\n\n# G1回收器优化建议\n\n- 年轻代大小\n  - ➢避免使用一Xmn或一XX：NewRatio等相关选项显式设置年轻代大小➢固定年轻代的大小会覆盖暂停时间目标\n- 暂停时间目标不要太过严苛\n  - G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间\n  - 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。\n\n# 7种经典的垃圾回收器总结\n\n截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723155737552-624347732.png)\n\n \n\n 不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合（连线），如下图：\n\n![img](https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723160245863-1482952705.png)\n\n- 1.两个收集器间有连线，表明它们可以搭配使用： Serial/Serial 0ld、Serial /CMS、ParNew/Serial 0ld、ParNew/CMS、 Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；\n- 2.其中Serial 0ld作 为CMS出现\"Concurrent Mode Failure\"失败 的后备预案。\n- 3.（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial 0ld这两个组合声明为Deprecated （JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。\n- 4.（绿色虚线）JDK 14中：弃用ParallelScavenge 和Serial0ld GC组合 （JEP 366）\n- 5.（青色虚线）JDK 14中：删除CMS垃圾回收器 （JEP 363 ） GC发展阶段： Serial => Parallel （并行） => CMS （并发） => G1 => ZGC\n\n## **怎么选择垃圾回收器**\n\n- Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。\n- 怎么选择垃圾收集器？\n  - 1.优先调整堆的大小让JVM自适应完成。\n  - 2.如果内存小于100M，使用串行收集器\n  - 3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器\n  - 4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择\n  - 5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器\n  - 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。\n- 最后需要明确一一个观点：\n  - 1.没有最好的收集器，更没有万能的收集；\n  - 2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器\n\n","slug":"garbage-first","published":1,"updated":"2021-09-01T11:29:34.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lkb001ihcmn1t3nhqo8","content":"<p>转载自：<a href=\"https://www.cnblogs.com/yanl55555/p/13366387.html\">JVM七大垃圾回收器下篇G1(Garbage First)</a></p>\n<h1 id=\"G1回收器-区域化分代式\"><a href=\"#G1回收器-区域化分代式\" class=\"headerlink\" title=\"G1回收器:区域化分代式\"></a>G1回收器:区域化分代式</h1><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong><br>  原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。<br>  与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。<br>  官方给G1设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量（高吞吐），所以才担当起“全功能收集器”的重任与期望。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么名字叫做Garbage-First-（G1）呢？\"><a href=\"#为什么名字叫做Garbage-First-（G1）呢？\" class=\"headerlink\" title=\"为什么名字叫做Garbage First （G1）呢？\"></a><strong>为什么名字叫做Garbage First （G1）呢？</strong></h2><ul>\n<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region） （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li>\n<li>G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li>\n<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。</li>\n<li>G1 （Garbage一First） 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li>\n<li>在JDK1. 7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel 0ld组合。被Oracle官方称为“全功能的垃圾收集器” 。</li>\n<li>与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） 。</li>\n<li>G1在jdk8中还不是默认的垃圾回收器，需要使用一XX： +UseG1GC来启用。</li>\n</ul>\n<h2 id=\"G1垃圾回收器优势\"><a href=\"#G1垃圾回收器优势\" class=\"headerlink\" title=\"G1垃圾回收器优势\"></a>G1垃圾回收器优势</h2><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：四个特点：</p>\n<ul>\n<li>并行与并发<ul>\n<li>➢并行性： G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>\n<li>➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>\n</ul>\n</li>\n<li>分代收集<ul>\n<li>➢从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>➢将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>➢和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144423293-687202683.png\" alt=\"img\"><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144442615-1696089988.png\" alt=\"img\"></p>\n<ul>\n<li><p>空间整合</p>\n</li>\n<li><ul>\n<li>➢CMS： “标记一清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>\n<li>➢G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法。</li>\n<li>但整体上实际可看作是标记一压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li><p>可预测的停顿时间模型（即：软实时soft real一time）</p>\n<p>： 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>\n<ul>\n<li>➢由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>➢G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以 及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>➢相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要.好很多。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"G1缺点\"><a href=\"#G1缺点\" class=\"headerlink\" title=\"G1缺点\"></a>G1缺点</h2><ul>\n<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</li>\n<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。</li>\n</ul>\n<h2 id=\"G1参数设置\"><a href=\"#G1参数设置\" class=\"headerlink\" title=\"G1参数设置\"></a>G1参数设置</h2><ul>\n<li>-XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。</li>\n<li>-XX：G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>\n<li>-XX：MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>\n<li>-xX：ParallelGCThread 设置sTw.工作线程数的值。最多设置为8</li>\n<li>-XX：ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</li>\n<li>-XX：Ini tiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>\n</ul>\n<h2 id=\"G1回收器的常见操作步骤\"><a href=\"#G1回收器的常见操作步骤\" class=\"headerlink\" title=\"G1回收器的常见操作步骤\"></a>G1回收器的常见操作步骤</h2><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>\n<ul>\n<li>第一步：开启G1垃圾收集器</li>\n<li>第二步：设置堆的最大内存</li>\n<li>第三步：设置最大的停顿时间</li>\n</ul>\n<p>G1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。（后文详细讲）</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723143818066-1702622040.png\" alt=\"img\"></p>\n<h2 id=\"G1适用场景\"><a href=\"#G1适用场景\" class=\"headerlink\" title=\"G1适用场景\"></a>G1适用场景</h2><ul>\n<li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li>\n<li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li>\n<li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>\n<li>用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：<br>①超过50%的Java堆被活动数据占用；<br>②对象分配频率或年代提升频率变化很大；<br>③GC停顿时间过长（长于0. 5至1秒）。</li>\n<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC（线程优先级低）的多线程操作</li>\n<li>而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>\n</ul>\n<h2 id=\"分区region-化整为零\"><a href=\"#分区region-化整为零\" class=\"headerlink\" title=\"分区region,化整为零\"></a>分区region,化整为零</h2><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。</p>\n<p>可以通过一 XX：G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>\n<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑_上的连续。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723150834993-49164173.png\" alt=\"img\"></p>\n<ul>\n<li>一个region 有可能属于Eden， Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>\n<li>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。</li>\n<li>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li>\n</ul>\n<h1 id=\"G1回收器垃圾回收过程\"><a href=\"#G1回收器垃圾回收过程\" class=\"headerlink\" title=\"G1回收器垃圾回收过程\"></a>G1回收器垃圾回收过程</h1><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>\n<ul>\n<li>年轻代GC （Young GC ）</li>\n<li>老年代并发标记过程（ Concurrent Marking）</li>\n<li>混合回收（Mixed GC ）</li>\n<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723151103477-1084742760.png\" alt=\"img\"></p>\n<p> 顺时针， young gc 一&gt; young gc + concurrent mark 一&gt; Mixed GC顺序，进行垃圾回收。</p>\n<p>1.应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的（多个回收线程）独占式(STW)收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>\n<p>2.当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>\n<p>3.标记完成马.上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起 被回收的。</p>\n<p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31 个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>\n<h2 id=\"记忆集与写屏障\"><a href=\"#记忆集与写屏障\" class=\"headerlink\" title=\"记忆集与写屏障\"></a>记忆集与写屏障</h2><ul>\n<li>一个对象被不同区域引用的问题(分代引用问题)</li>\n<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li>\n<li>在其他的分代收集器，也存在这样的问题（ 而G1更突出）</li>\n<li>回收新生代也不得不同时扫描老年代？</li>\n<li>这样的话会降低MinorGC的效率；</li>\n</ul>\n<p><strong>·解决方法：</strong></p>\n<ul>\n<li>➢无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：</li>\n<li>➢每个Region都有 一个对应的Remembered Set；</li>\n<li>➢每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .</li>\n<li>➢然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；</li>\n<li>➢如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>\n<li>➢当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723152028598-2055678824.png\" alt=\"img\"></p>\n<h1 id=\"G1回收过程详解\"><a href=\"#G1回收过程详解\" class=\"headerlink\" title=\"G1回收过程详解\"></a>G1回收过程详解</h1><h2 id=\"过程1年轻代GC\"><a href=\"#过程1年轻代GC\" class=\"headerlink\" title=\"过程1年轻代GC\"></a>过程1年轻代GC</h2><ul>\n<li>JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>\n<li>年轻代垃圾回收只会回收Eden区（主动）和Survivor区（被动）。</li>\n<li>YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li>\n<li>复制算法（S、E–&gt;空闲区相当于To区）（S–&gt;寻找新的空闲区作为老年代）</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723153515525-318612700.png\" alt=\"img\"></p>\n<p>然后开始如下回收过程：</p>\n<ul>\n<li>第一阶段，扫描根<ul>\n<li>根是：指static变量指向的对象（类生命周期，方法区引用的对象），正在执行的方法调用链条上的局部变量等（方法生命周期，虚拟机栈引用的对象）。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>\n</ul>\n</li>\n<li><strong>第二阶段，更新RSet</strong></li>\n</ul>\n<p>​     处理dirty card queue（ 见备注）中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。</p>\n<ul>\n<li><ul>\n<li>dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li>\n<li>在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>\n<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>\n</ul>\n</li>\n<li><p><strong>第三阶段，处理RSet</strong>。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>\n</li>\n<li><p><strong>第四阶段，复制对象</strong>。<br>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。</p>\n</li>\n<li><p><strong>第五阶段，处理引用</strong>。<br>处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>\n</li>\n</ul>\n<h2 id=\"过程2年轻代GC-并发标记过程\"><a href=\"#过程2年轻代GC-并发标记过程\" class=\"headerlink\" title=\"过程2年轻代GC+并发标记过程\"></a>过程2年轻代GC+并发标记过程</h2><ul>\n<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一.次年轻代GC。</li>\n<li>根区域扫描（Root Region Scanning） ： G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</li>\n<li>并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>\n<li>再次标记（Remark）： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。</li>\n<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。<ul>\n<li>➢这个阶段并不会实际上去做垃圾的收集</li>\n</ul>\n</li>\n<li>并发清理阶段：识别并清理完全空闲的区域。</li>\n</ul>\n<h2 id=\"过程3混合回收\"><a href=\"#过程3混合回收\" class=\"headerlink\" title=\"过程3混合回收\"></a>过程3混合回收</h2><p>当越来越多的对象晋升到老年代Oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个OldGC，除了回收整个Young Region，还会回收一部分的0ldRegion。这里需要注意：是一部分老年代， 而不是全部老年代。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>\n<ul>\n<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过一XX： G1MixedGCCountTarget设置）被回收。</li>\n<li>混合回收的回收集（Collection Set） 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>\n<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，一xX： G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>\n<li>混合回收并不一定要进行8次。有一个阈值一Xx： G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>\n</ul>\n<h2 id=\"过程4Full-GC\"><a href=\"#过程4Full-GC\" class=\"headerlink\" title=\"过程4Full GC\"></a>过程4Full GC</h2><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。<br>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。<br>导致G1Full GC的原因可能有两个：</p>\n<ul>\n<li>1.Evacuation的时候没有足够的to一 space来存放晋升的对象；</li>\n<li>2.并发处理过程完成之前空间耗尽。</li>\n</ul>\n<p><strong>补充：</strong></p>\n<p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实.本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>\n<h1 id=\"G1回收器优化建议\"><a href=\"#G1回收器优化建议\" class=\"headerlink\" title=\"G1回收器优化建议\"></a>G1回收器优化建议</h1><ul>\n<li>年轻代大小<ul>\n<li>➢避免使用一Xmn或一XX：NewRatio等相关选项显式设置年轻代大小➢固定年轻代的大小会覆盖暂停时间目标</li>\n</ul>\n</li>\n<li>暂停时间目标不要太过严苛<ul>\n<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>\n<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"7种经典的垃圾回收器总结\"><a href=\"#7种经典的垃圾回收器总结\" class=\"headerlink\" title=\"7种经典的垃圾回收器总结\"></a>7种经典的垃圾回收器总结</h1><p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723155737552-624347732.png\" alt=\"img\"></p>\n<p> 不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合（连线），如下图：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723160245863-1482952705.png\" alt=\"img\"></p>\n<ul>\n<li>1.两个收集器间有连线，表明它们可以搭配使用： Serial/Serial 0ld、Serial /CMS、ParNew/Serial 0ld、ParNew/CMS、 Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；</li>\n<li>2.其中Serial 0ld作 为CMS出现”Concurrent Mode Failure”失败 的后备预案。</li>\n<li>3.（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial 0ld这两个组合声明为Deprecated （JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>4.（绿色虚线）JDK 14中：弃用ParallelScavenge 和Serial0ld GC组合 （JEP 366）</li>\n<li>5.（青色虚线）JDK 14中：删除CMS垃圾回收器 （JEP 363 ） GC发展阶段： Serial =&gt; Parallel （并行） =&gt; CMS （并发） =&gt; G1 =&gt; ZGC</li>\n</ul>\n<h2 id=\"怎么选择垃圾回收器\"><a href=\"#怎么选择垃圾回收器\" class=\"headerlink\" title=\"怎么选择垃圾回收器\"></a><strong>怎么选择垃圾回收器</strong></h2><ul>\n<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>\n<li>怎么选择垃圾收集器？<ul>\n<li>1.优先调整堆的大小让JVM自适应完成。</li>\n<li>2.如果内存小于100M，使用串行收集器</li>\n<li>3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>\n<li>4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>\n<li>5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>\n<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>\n</ul>\n</li>\n<li>最后需要明确一一个观点：<ul>\n<li>1.没有最好的收集器，更没有万能的收集；</li>\n<li>2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>转载自：<a href=\"https://www.cnblogs.com/yanl55555/p/13366387.html\">JVM七大垃圾回收器下篇G1(Garbage First)</a></p>\n<h1 id=\"G1回收器-区域化分代式\"><a href=\"#G1回收器-区域化分代式\" class=\"headerlink\" title=\"G1回收器:区域化分代式\"></a>G1回收器:区域化分代式</h1><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong><br>  原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。<br>  与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。<br>  官方给G1设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量（高吞吐），所以才担当起“全功能收集器”的重任与期望。</p>","more":"<h2 id=\"为什么名字叫做Garbage-First-（G1）呢？\"><a href=\"#为什么名字叫做Garbage-First-（G1）呢？\" class=\"headerlink\" title=\"为什么名字叫做Garbage First （G1）呢？\"></a><strong>为什么名字叫做Garbage First （G1）呢？</strong></h2><ul>\n<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region） （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li>\n<li>G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li>\n<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 。</li>\n<li>G1 （Garbage一First） 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li>\n<li>在JDK1. 7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS回收器以及Parallel + Parallel 0ld组合。被Oracle官方称为“全功能的垃圾收集器” 。</li>\n<li>与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） 。</li>\n<li>G1在jdk8中还不是默认的垃圾回收器，需要使用一XX： +UseG1GC来启用。</li>\n</ul>\n<h2 id=\"G1垃圾回收器优势\"><a href=\"#G1垃圾回收器优势\" class=\"headerlink\" title=\"G1垃圾回收器优势\"></a>G1垃圾回收器优势</h2><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：四个特点：</p>\n<ul>\n<li>并行与并发<ul>\n<li>➢并行性： G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程STW</li>\n<li>➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>\n</ul>\n</li>\n<li>分代收集<ul>\n<li>➢从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>➢将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>➢和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144423293-687202683.png\" alt=\"img\"><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723144442615-1696089988.png\" alt=\"img\"></p>\n<ul>\n<li><p>空间整合</p>\n</li>\n<li><ul>\n<li>➢CMS： “标记一清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>\n<li>➢G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法。</li>\n<li>但整体上实际可看作是标记一压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li><p>可预测的停顿时间模型（即：软实时soft real一time）</p>\n<p>： 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>\n<ul>\n<li>➢由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>➢G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以 及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>➢相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要.好很多。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"G1缺点\"><a href=\"#G1缺点\" class=\"headerlink\" title=\"G1缺点\"></a>G1缺点</h2><ul>\n<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</li>\n<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6一8GB之间。</li>\n</ul>\n<h2 id=\"G1参数设置\"><a href=\"#G1参数设置\" class=\"headerlink\" title=\"G1参数设置\"></a>G1参数设置</h2><ul>\n<li>-XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。</li>\n<li>-XX：G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>\n<li>-XX：MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>\n<li>-xX：ParallelGCThread 设置sTw.工作线程数的值。最多设置为8</li>\n<li>-XX：ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</li>\n<li>-XX：Ini tiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>\n</ul>\n<h2 id=\"G1回收器的常见操作步骤\"><a href=\"#G1回收器的常见操作步骤\" class=\"headerlink\" title=\"G1回收器的常见操作步骤\"></a>G1回收器的常见操作步骤</h2><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>\n<ul>\n<li>第一步：开启G1垃圾收集器</li>\n<li>第二步：设置堆的最大内存</li>\n<li>第三步：设置最大的停顿时间</li>\n</ul>\n<p>G1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。（后文详细讲）</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723143818066-1702622040.png\" alt=\"img\"></p>\n<h2 id=\"G1适用场景\"><a href=\"#G1适用场景\" class=\"headerlink\" title=\"G1适用场景\"></a>G1适用场景</h2><ul>\n<li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li>\n<li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li>\n<li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>\n<li>用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：<br>①超过50%的Java堆被活动数据占用；<br>②对象分配频率或年代提升频率变化很大；<br>③GC停顿时间过长（长于0. 5至1秒）。</li>\n<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC（线程优先级低）的多线程操作</li>\n<li>而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>\n</ul>\n<h2 id=\"分区region-化整为零\"><a href=\"#分区region-化整为零\" class=\"headerlink\" title=\"分区region,化整为零\"></a>分区region,化整为零</h2><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB， 32MB。</p>\n<p>可以通过一 XX：G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>\n<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑_上的连续。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723150834993-49164173.png\" alt=\"img\"></p>\n<ul>\n<li>一个region 有可能属于Eden， Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>\n<li>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。</li>\n<li>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li>\n</ul>\n<h1 id=\"G1回收器垃圾回收过程\"><a href=\"#G1回收器垃圾回收过程\" class=\"headerlink\" title=\"G1回收器垃圾回收过程\"></a>G1回收器垃圾回收过程</h1><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>\n<ul>\n<li>年轻代GC （Young GC ）</li>\n<li>老年代并发标记过程（ Concurrent Marking）</li>\n<li>混合回收（Mixed GC ）</li>\n<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723151103477-1084742760.png\" alt=\"img\"></p>\n<p> 顺时针， young gc 一&gt; young gc + concurrent mark 一&gt; Mixed GC顺序，进行垃圾回收。</p>\n<p>1.应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程； G1的年轻代收集阶段是一个并行的（多个回收线程）独占式(STW)收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>\n<p>2.当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>\n<p>3.标记完成马.上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起 被回收的。</p>\n<p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31 个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>\n<h2 id=\"记忆集与写屏障\"><a href=\"#记忆集与写屏障\" class=\"headerlink\" title=\"记忆集与写屏障\"></a>记忆集与写屏障</h2><ul>\n<li>一个对象被不同区域引用的问题(分代引用问题)</li>\n<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li>\n<li>在其他的分代收集器，也存在这样的问题（ 而G1更突出）</li>\n<li>回收新生代也不得不同时扫描老年代？</li>\n<li>这样的话会降低MinorGC的效率；</li>\n</ul>\n<p><strong>·解决方法：</strong></p>\n<ul>\n<li>➢无论G1还是其他分代收集器，JVM都是使用RememberedSet来避免全局扫描：</li>\n<li>➢每个Region都有 一个对应的Remembered Set；</li>\n<li>➢每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； .</li>\n<li>➢然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象） ；</li>\n<li>➢如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>\n<li>➢当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723152028598-2055678824.png\" alt=\"img\"></p>\n<h1 id=\"G1回收过程详解\"><a href=\"#G1回收过程详解\" class=\"headerlink\" title=\"G1回收过程详解\"></a>G1回收过程详解</h1><h2 id=\"过程1年轻代GC\"><a href=\"#过程1年轻代GC\" class=\"headerlink\" title=\"过程1年轻代GC\"></a>过程1年轻代GC</h2><ul>\n<li>JVM启动时，G1 先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>\n<li>年轻代垃圾回收只会回收Eden区（主动）和Survivor区（被动）。</li>\n<li>YGC时，首先G1停止应用程序的执行（Stop一The一World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li>\n<li>复制算法（S、E–&gt;空闲区相当于To区）（S–&gt;寻找新的空闲区作为老年代）</li>\n</ul>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723153515525-318612700.png\" alt=\"img\"></p>\n<p>然后开始如下回收过程：</p>\n<ul>\n<li>第一阶段，扫描根<ul>\n<li>根是：指static变量指向的对象（类生命周期，方法区引用的对象），正在执行的方法调用链条上的局部变量等（方法生命周期，虚拟机栈引用的对象）。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>\n</ul>\n</li>\n<li><strong>第二阶段，更新RSet</strong></li>\n</ul>\n<p>​     处理dirty card queue（ 见备注）中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。</p>\n<ul>\n<li><ul>\n<li>dirty card queue: 对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li>\n<li>在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>\n<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>\n</ul>\n</li>\n<li><p><strong>第三阶段，处理RSet</strong>。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>\n</li>\n<li><p><strong>第四阶段，复制对象</strong>。<br>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。</p>\n</li>\n<li><p><strong>第五阶段，处理引用</strong>。<br>处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>\n</li>\n</ul>\n<h2 id=\"过程2年轻代GC-并发标记过程\"><a href=\"#过程2年轻代GC-并发标记过程\" class=\"headerlink\" title=\"过程2年轻代GC+并发标记过程\"></a>过程2年轻代GC+并发标记过程</h2><ul>\n<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一.次年轻代GC。</li>\n<li>根区域扫描（Root Region Scanning） ： G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</li>\n<li>并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>\n<li>再次标记（Remark）： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot一at一the一beginning （SATB）。</li>\n<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。<ul>\n<li>➢这个阶段并不会实际上去做垃圾的收集</li>\n</ul>\n</li>\n<li>并发清理阶段：识别并清理完全空闲的区域。</li>\n</ul>\n<h2 id=\"过程3混合回收\"><a href=\"#过程3混合回收\" class=\"headerlink\" title=\"过程3混合回收\"></a>过程3混合回收</h2><p>当越来越多的对象晋升到老年代Oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个OldGC，除了回收整个Young Region，还会回收一部分的0ldRegion。这里需要注意：是一部分老年代， 而不是全部老年代。可以选择哪些OldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>\n<ul>\n<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过一XX： G1MixedGCCountTarget设置）被回收。</li>\n<li>混合回收的回收集（Collection Set） 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>\n<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，一xX： G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>\n<li>混合回收并不一定要进行8次。有一个阈值一Xx： G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>\n</ul>\n<h2 id=\"过程4Full-GC\"><a href=\"#过程4Full-GC\" class=\"headerlink\" title=\"过程4Full GC\"></a>过程4Full GC</h2><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop一 The一World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。<br>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc， 这种情况可以通过增大内存解决。<br>导致G1Full GC的原因可能有两个：</p>\n<ul>\n<li>1.Evacuation的时候没有足够的to一 space来存放晋升的对象；</li>\n<li>2.并发处理过程完成之前空间耗尽。</li>\n</ul>\n<p><strong>补充：</strong></p>\n<p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实.本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>\n<h1 id=\"G1回收器优化建议\"><a href=\"#G1回收器优化建议\" class=\"headerlink\" title=\"G1回收器优化建议\"></a>G1回收器优化建议</h1><ul>\n<li>年轻代大小<ul>\n<li>➢避免使用一Xmn或一XX：NewRatio等相关选项显式设置年轻代大小➢固定年轻代的大小会覆盖暂停时间目标</li>\n</ul>\n</li>\n<li>暂停时间目标不要太过严苛<ul>\n<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>\n<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表 示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"7种经典的垃圾回收器总结\"><a href=\"#7种经典的垃圾回收器总结\" class=\"headerlink\" title=\"7种经典的垃圾回收器总结\"></a>7种经典的垃圾回收器总结</h1><p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723155737552-624347732.png\" alt=\"img\"></p>\n<p> 不同厂商、不同版本的虚拟机实现差别很大。HotSpot 虚拟机在JDK7/8后所有收集器及组合（连线），如下图：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1846149/202007/1846149-20200723160245863-1482952705.png\" alt=\"img\"></p>\n<ul>\n<li>1.两个收集器间有连线，表明它们可以搭配使用： Serial/Serial 0ld、Serial /CMS、ParNew/Serial 0ld、ParNew/CMS、 Parallel Scavenge/Serial 01d、Parallel Scavenge/Parallel 0ld、G1；</li>\n<li>2.其中Serial 0ld作 为CMS出现”Concurrent Mode Failure”失败 的后备预案。</li>\n<li>3.（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial 0ld这两个组合声明为Deprecated （JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>4.（绿色虚线）JDK 14中：弃用ParallelScavenge 和Serial0ld GC组合 （JEP 366）</li>\n<li>5.（青色虚线）JDK 14中：删除CMS垃圾回收器 （JEP 363 ） GC发展阶段： Serial =&gt; Parallel （并行） =&gt; CMS （并发） =&gt; G1 =&gt; ZGC</li>\n</ul>\n<h2 id=\"怎么选择垃圾回收器\"><a href=\"#怎么选择垃圾回收器\" class=\"headerlink\" title=\"怎么选择垃圾回收器\"></a><strong>怎么选择垃圾回收器</strong></h2><ul>\n<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>\n<li>怎么选择垃圾收集器？<ul>\n<li>1.优先调整堆的大小让JVM自适应完成。</li>\n<li>2.如果内存小于100M，使用串行收集器</li>\n<li>3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>\n<li>4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>\n<li>5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>\n<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>\n</ul>\n</li>\n<li>最后需要明确一一个观点：<ul>\n<li>1.没有最好的收集器，更没有万能的收集；</li>\n<li>2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>\n</ul>\n</li>\n</ul>"},{"title":"TCP/KCP详解，及源码注解","date":"2018-12-08T11:36:07.000Z","id":"kcp","_content":"\n# KCP-Netty的中文注解版：\n\n[kcp-netty中文注释](https://github.com/zhangga/kcp-netty)\n\n# KCP/UDT比较：\n\n[kcp/udt](https://github.com/libinzhangyuan/asio_kcp)\n\n# KCP\n\n传输层，可靠性，ARQ协议。\n\n目的：解决在网络拥堵情况下tcp协议的网络速度慢的问题。可靠性，传输速度。\n\n一般用udp作为下层传输协议，udp报文+控制头。\n\n传输数据大于mss(最大报文段)时，kcp将数据分片存储在多个kcp包(Segment)中。\n\n1. 1. **滑动窗口机制：**kcp采用滑动窗口机制来提高发送速度。由于UDP在网络中的传输是不可靠的，因此会出现丢包和包的乱序。kcp是可靠的保证数据有序的协议，所以为了纠正包的乱序。接收方维护一个接收窗口。接收窗口有一个起始序号rcv_nxt以及尾序号rcv_nxt+rcv_wnd。如果接收窗口收到序号为rcv_nxt的分片那么rcv_nxt就加一，形象一点的说法是滑动窗口右移,并把该数据放入接收队列供应用层取用。如果收到的数据在窗口范围内但不是rcv_nxt那么就把数据保存起来,等收到rcv_nxt序号的分片时再一并放入接收队列供应用层取用。\n\n1. **快速重传机制：**数据在网络中的传输时间是不固定的，因此超时重传时间比较长。而为了尽早地判断出数据包的丢失，kcp引入了快速重传机制。快速重传机制工作原理是，当发送方发送了n,n+1,n+2…等等包出去后，接收方没有接收到n,而接收到n+1,n+2..等等n号包之后的包，这时因为n号包之后的包都已经接收到了，而n号包还没有接收到，所以可以认为n号包已经丢失了，告知发送方可以进行快速重传。kcp为了支持快速重传，接收方需要告诉发送方，哪些包已经成功收到了，哪些包没有收到。因此接收方返回发送方的确认数据（ack）中包含以下信息：接收窗口左端的序号rcv_nxt,接收到的大于rcv_nxt的包序号sn。rcv_nxt的含义是接收方已经成功按顺序接收了rcv_nxt序号之前的所有包,大于rcv_nxt的序号sn表示的是在接收窗口内的不连续的包。发送方接收到接收方发过来的数据时，首先解析rcv_nxt，把发送缓存中所有小于rcv_nxt序号的包全部移除掉（因为这些包全都都已经正确接收了）。然后再解析sn,遍历发送缓存，找到所有序号小于sn的包，这些包就是可能在网络中已经丢掉了的包,只是可能，因为有可能这些包只是拥堵在了网络中，需要更长的时间到达，所以这里我们设置一个快速重传的门限，对每个分片维护一个快速重传的计数，每收到一个ack解析sn后找到了一个分片，就把该分片的快速重传的计数加一，如果该计数达到了快速重传门限，那么就认为该分片已经丢失，可以触发快速重传，该门限值在kcp中可以设置，tcp中是3。\n2. **选择重传机制：**选择重传的关键在于接收方要告知发送方哪些包已经收到了，哪些包没有收到，为了最小化数据量，接收方可以告诉发送方哪些包已经按序收到了，哪些包是收到的但是不连续。所以返回的ack中包含rcv_nxt和sn。rcv_nxt代表收到的所有连续的包，sn代表哪些不连续的包收到了，那么根据这两个参数可以计算出来没有收到的包的序号。\n3. **拥塞控制：**拥塞控制就是告诉发送方，网络太堵了，应该少发一些数据，因此在滑动窗口的机制上引入了拥塞窗口，也就是说发送发发送的数据不得超过拥塞窗口，拥塞窗口的大小会随网络情况而变快，网络快拥塞窗口就大，反之同理。拥塞窗口的大小控制使用慢启动机制，具体参考TCP。\n\n应用：kcp采取一系列措施尽量提高网络传输速率，在网络实时性和可靠性要求比较高的场景下可以考虑kcp协议代替tcp协议。\n\n名词说明（源码字段）：\n用户数据：应用层发送的数据，如一张图片2Kb的数据\nMTU：最大传输单元。即每次发送的最大数据\nRTO：Retransmission TimeOut，重传超时时间。\ncwnd:congestion window，拥塞窗口，表示发送方可发送多少个KCP数据包。与接收方窗口有关，与网络状况（拥塞控制）有关，与发送窗口大小有关。\nrwnd:receiver window,接收方窗口大小，表示接收方还可接收多少个KCP数据包\nsnd_queue:待发送KCP数据包队列\nsnd_nxt:下一个即将发送的kcp数据包序列号\nsnd_una:下一个待确认的序列号\n\n![TCP/KCP详解，及源码注解 - 第1张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1.png?resize=640%2C467)\n\n![TCP/KCP详解，及源码注解 - 第2张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2.png?resize=640%2C351)\n\n[ KCP 发送过程 ]\n\n![TCP/KCP详解，及源码注解 - 第3张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3.jpg?resize=485%2C296)\n\n[ RTO算法对比图 ]\n\nKCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。\n\n![TCP/KCP详解，及源码注解 - 第4张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4.png?resize=365%2C353)\n\n**rcv_queue的数据是连续的，rcv_buf可能是间隔的**\n\n![TCP/KCP详解，及源码注解 - 第5张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/5.png?resize=355%2C448)\n\n![TCP/KCP详解，及源码注解 - 第6张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/6.png?resize=466%2C424)\n\n[ 数据确认包处理流程 ]\n\n![TCP/KCP详解，及源码注解 - 第7张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/7.png?resize=574%2C403)\n\n[ KCP快速确认 ]\n\n**总结：TCP可靠简单，但是复杂无私，所以速度慢。KCP尽可能保留UDP快的特点下，保证可靠。**\n\n![TCP/KCP详解，及源码注解 - 第8张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/992994-20180616162318524-660296383.jpg?resize=640%2C323)\n\n总结：UDP收到的包，不断通过kcp_input喂给KCP，KCP会对这部分数据（KCP协议数据）进行解包，重新封装成应用层用户数据，应用层通过kcp_recv获取。应用层通过kcp_send发送数据，KCP会把用户数据拆分kcp数据包，通过kcp_output，以UDP（send）的方式发送。\n\n**KCP的配置模式**\n\n\\1. 工作模式：\n\n> int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)\n\n- nodelay ：是否启用 nodelay模式，0不启用；1启用。\n- interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms\n- resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）\n- nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。\n\n**普通模式：** ikcp_nodelay(kcp, 0, 40, 0, 0);\n\n**极速模式：** ikcp_nodelay(kcp, 1, 10, 2, 1)\n\n\\1. 最大窗口\n\n> int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);\n\n该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。\n\n\\2. 最大传输单元：\n\n纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。\n\n\\3. 最小RTO：\n\n不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：\nkcp->rx_minrto = 10;\n\nKCP原理见：[KCP原理](https://www.cnblogs.com/wetest/p/9190786.html)\n\n# TCP\n\n### 特性：\n\n1.为流量设计（KB数据/秒），充分利用宽带。\n\n2.安全可靠，丢包全部重传。\n\n3.超时 = RTO * 2。\n\n4.延迟ACK，充分利用宽带。\n\n#### UNA vs ACK+UNA：\n\nARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到  ），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而  KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。\n\n### 拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\n\n**慢开始算法**：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。\n\n![TCP/KCP详解，及源码注解 - 第9张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120451114.jpg?resize=499%2C305)\n\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\n\n另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。\n\n为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：\n\n当 cwnd < ssthresh 时，使用上述的慢开始算法。\n\n当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n\n当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。\n\n拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n\n如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。\n\n![TCP/KCP详解，及源码注解 - 第10张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120591634.jpg?resize=570%2C306)\n\n<1>. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。\n\n<2>. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。\n\n<3>. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。\n\n强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞。**\n\n### 快重传和快恢复算法：\n\n如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。\n\n快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。\n\n![TCP/KCP详解，及源码注解 - 第11张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2010101122524670.jpg?resize=492%2C276)\n\n接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。\n\n与快重传配合使用的还有快恢复算法，其过程有以下两个要点：\n\n<1>. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。\n\n<2>. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。\n\n下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。\n\n区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。\n\n![TCP/KCP详解，及源码注解 - 第12张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101123101842.jpg?resize=621%2C313)\n\n也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。\n\n在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。\n\n采用这样的拥塞控制方法使得TCP的性能有明显的改进。\n\n接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。\n\n发送方窗口的上限值 = Min [ rwnd, cwnd ]\n\n当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。\n\n当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大值。\n\n","source":"_posts/kcp.md","raw":"---\ntitle: TCP/KCP详解，及源码注解\ndate: 2018-12-08 19:36:07\ntags:\n  - 笔记\nid: kcp\ncategories:\n  - 笔记\n---\n\n# KCP-Netty的中文注解版：\n\n[kcp-netty中文注释](https://github.com/zhangga/kcp-netty)\n\n# KCP/UDT比较：\n\n[kcp/udt](https://github.com/libinzhangyuan/asio_kcp)\n\n# KCP\n\n传输层，可靠性，ARQ协议。\n\n目的：解决在网络拥堵情况下tcp协议的网络速度慢的问题。可靠性，传输速度。\n\n一般用udp作为下层传输协议，udp报文+控制头。\n\n传输数据大于mss(最大报文段)时，kcp将数据分片存储在多个kcp包(Segment)中。\n\n1. 1. **滑动窗口机制：**kcp采用滑动窗口机制来提高发送速度。由于UDP在网络中的传输是不可靠的，因此会出现丢包和包的乱序。kcp是可靠的保证数据有序的协议，所以为了纠正包的乱序。接收方维护一个接收窗口。接收窗口有一个起始序号rcv_nxt以及尾序号rcv_nxt+rcv_wnd。如果接收窗口收到序号为rcv_nxt的分片那么rcv_nxt就加一，形象一点的说法是滑动窗口右移,并把该数据放入接收队列供应用层取用。如果收到的数据在窗口范围内但不是rcv_nxt那么就把数据保存起来,等收到rcv_nxt序号的分片时再一并放入接收队列供应用层取用。\n\n1. **快速重传机制：**数据在网络中的传输时间是不固定的，因此超时重传时间比较长。而为了尽早地判断出数据包的丢失，kcp引入了快速重传机制。快速重传机制工作原理是，当发送方发送了n,n+1,n+2…等等包出去后，接收方没有接收到n,而接收到n+1,n+2..等等n号包之后的包，这时因为n号包之后的包都已经接收到了，而n号包还没有接收到，所以可以认为n号包已经丢失了，告知发送方可以进行快速重传。kcp为了支持快速重传，接收方需要告诉发送方，哪些包已经成功收到了，哪些包没有收到。因此接收方返回发送方的确认数据（ack）中包含以下信息：接收窗口左端的序号rcv_nxt,接收到的大于rcv_nxt的包序号sn。rcv_nxt的含义是接收方已经成功按顺序接收了rcv_nxt序号之前的所有包,大于rcv_nxt的序号sn表示的是在接收窗口内的不连续的包。发送方接收到接收方发过来的数据时，首先解析rcv_nxt，把发送缓存中所有小于rcv_nxt序号的包全部移除掉（因为这些包全都都已经正确接收了）。然后再解析sn,遍历发送缓存，找到所有序号小于sn的包，这些包就是可能在网络中已经丢掉了的包,只是可能，因为有可能这些包只是拥堵在了网络中，需要更长的时间到达，所以这里我们设置一个快速重传的门限，对每个分片维护一个快速重传的计数，每收到一个ack解析sn后找到了一个分片，就把该分片的快速重传的计数加一，如果该计数达到了快速重传门限，那么就认为该分片已经丢失，可以触发快速重传，该门限值在kcp中可以设置，tcp中是3。\n2. **选择重传机制：**选择重传的关键在于接收方要告知发送方哪些包已经收到了，哪些包没有收到，为了最小化数据量，接收方可以告诉发送方哪些包已经按序收到了，哪些包是收到的但是不连续。所以返回的ack中包含rcv_nxt和sn。rcv_nxt代表收到的所有连续的包，sn代表哪些不连续的包收到了，那么根据这两个参数可以计算出来没有收到的包的序号。\n3. **拥塞控制：**拥塞控制就是告诉发送方，网络太堵了，应该少发一些数据，因此在滑动窗口的机制上引入了拥塞窗口，也就是说发送发发送的数据不得超过拥塞窗口，拥塞窗口的大小会随网络情况而变快，网络快拥塞窗口就大，反之同理。拥塞窗口的大小控制使用慢启动机制，具体参考TCP。\n\n应用：kcp采取一系列措施尽量提高网络传输速率，在网络实时性和可靠性要求比较高的场景下可以考虑kcp协议代替tcp协议。\n\n名词说明（源码字段）：\n用户数据：应用层发送的数据，如一张图片2Kb的数据\nMTU：最大传输单元。即每次发送的最大数据\nRTO：Retransmission TimeOut，重传超时时间。\ncwnd:congestion window，拥塞窗口，表示发送方可发送多少个KCP数据包。与接收方窗口有关，与网络状况（拥塞控制）有关，与发送窗口大小有关。\nrwnd:receiver window,接收方窗口大小，表示接收方还可接收多少个KCP数据包\nsnd_queue:待发送KCP数据包队列\nsnd_nxt:下一个即将发送的kcp数据包序列号\nsnd_una:下一个待确认的序列号\n\n![TCP/KCP详解，及源码注解 - 第1张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1.png?resize=640%2C467)\n\n![TCP/KCP详解，及源码注解 - 第2张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2.png?resize=640%2C351)\n\n[ KCP 发送过程 ]\n\n![TCP/KCP详解，及源码注解 - 第3张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3.jpg?resize=485%2C296)\n\n[ RTO算法对比图 ]\n\nKCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。\n\n![TCP/KCP详解，及源码注解 - 第4张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4.png?resize=365%2C353)\n\n**rcv_queue的数据是连续的，rcv_buf可能是间隔的**\n\n![TCP/KCP详解，及源码注解 - 第5张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/5.png?resize=355%2C448)\n\n![TCP/KCP详解，及源码注解 - 第6张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/6.png?resize=466%2C424)\n\n[ 数据确认包处理流程 ]\n\n![TCP/KCP详解，及源码注解 - 第7张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/7.png?resize=574%2C403)\n\n[ KCP快速确认 ]\n\n**总结：TCP可靠简单，但是复杂无私，所以速度慢。KCP尽可能保留UDP快的特点下，保证可靠。**\n\n![TCP/KCP详解，及源码注解 - 第8张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/992994-20180616162318524-660296383.jpg?resize=640%2C323)\n\n总结：UDP收到的包，不断通过kcp_input喂给KCP，KCP会对这部分数据（KCP协议数据）进行解包，重新封装成应用层用户数据，应用层通过kcp_recv获取。应用层通过kcp_send发送数据，KCP会把用户数据拆分kcp数据包，通过kcp_output，以UDP（send）的方式发送。\n\n**KCP的配置模式**\n\n\\1. 工作模式：\n\n> int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)\n\n- nodelay ：是否启用 nodelay模式，0不启用；1启用。\n- interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms\n- resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）\n- nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。\n\n**普通模式：** ikcp_nodelay(kcp, 0, 40, 0, 0);\n\n**极速模式：** ikcp_nodelay(kcp, 1, 10, 2, 1)\n\n\\1. 最大窗口\n\n> int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);\n\n该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。\n\n\\2. 最大传输单元：\n\n纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。\n\n\\3. 最小RTO：\n\n不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：\nkcp->rx_minrto = 10;\n\nKCP原理见：[KCP原理](https://www.cnblogs.com/wetest/p/9190786.html)\n\n# TCP\n\n### 特性：\n\n1.为流量设计（KB数据/秒），充分利用宽带。\n\n2.安全可靠，丢包全部重传。\n\n3.超时 = RTO * 2。\n\n4.延迟ACK，充分利用宽带。\n\n#### UNA vs ACK+UNA：\n\nARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到  ），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而  KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。\n\n### 拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\n\n**慢开始算法**：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。\n\n![TCP/KCP详解，及源码注解 - 第9张  | 张嘎](https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120451114.jpg?resize=499%2C305)\n\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\n\n另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。\n\n为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：\n\n当 cwnd < ssthresh 时，使用上述的慢开始算法。\n\n当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n\n当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。\n\n拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n\n如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。\n\n![TCP/KCP详解，及源码注解 - 第10张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120591634.jpg?resize=570%2C306)\n\n<1>. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。\n\n<2>. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。\n\n<3>. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。\n\n强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞。**\n\n### 快重传和快恢复算法：\n\n如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。\n\n快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。\n\n![TCP/KCP详解，及源码注解 - 第11张  | 张嘎](https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2010101122524670.jpg?resize=492%2C276)\n\n接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。\n\n与快重传配合使用的还有快恢复算法，其过程有以下两个要点：\n\n<1>. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。\n\n<2>. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。\n\n下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。\n\n区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。\n\n![TCP/KCP详解，及源码注解 - 第12张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101123101842.jpg?resize=621%2C313)\n\n也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。\n\n在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。\n\n采用这样的拥塞控制方法使得TCP的性能有明显的改进。\n\n接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。\n\n发送方窗口的上限值 = Min [ rwnd, cwnd ]\n\n当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。\n\n当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大值。\n\n","slug":"kcp","published":1,"updated":"2021-09-01T11:37:17.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lkb001jhcmn6i2z1jo6","content":"<h1 id=\"KCP-Netty的中文注解版：\"><a href=\"#KCP-Netty的中文注解版：\" class=\"headerlink\" title=\"KCP-Netty的中文注解版：\"></a>KCP-Netty的中文注解版：</h1><p><a href=\"https://github.com/zhangga/kcp-netty\">kcp-netty中文注释</a></p>\n<h1 id=\"KCP-UDT比较：\"><a href=\"#KCP-UDT比较：\" class=\"headerlink\" title=\"KCP/UDT比较：\"></a>KCP/UDT比较：</h1><p><a href=\"https://github.com/libinzhangyuan/asio_kcp\">kcp/udt</a></p>\n<h1 id=\"KCP\"><a href=\"#KCP\" class=\"headerlink\" title=\"KCP\"></a>KCP</h1><p>传输层，可靠性，ARQ协议。</p>\n<p>目的：解决在网络拥堵情况下tcp协议的网络速度慢的问题。可靠性，传输速度。</p>\n<p>一般用udp作为下层传输协议，udp报文+控制头。</p>\n<p>传输数据大于mss(最大报文段)时，kcp将数据分片存储在多个kcp包(Segment)中。</p>\n<ol>\n<li><ol>\n<li><strong>滑动窗口机制：</strong>kcp采用滑动窗口机制来提高发送速度。由于UDP在网络中的传输是不可靠的，因此会出现丢包和包的乱序。kcp是可靠的保证数据有序的协议，所以为了纠正包的乱序。接收方维护一个接收窗口。接收窗口有一个起始序号rcv_nxt以及尾序号rcv_nxt+rcv_wnd。如果接收窗口收到序号为rcv_nxt的分片那么rcv_nxt就加一，形象一点的说法是滑动窗口右移,并把该数据放入接收队列供应用层取用。如果收到的数据在窗口范围内但不是rcv_nxt那么就把数据保存起来,等收到rcv_nxt序号的分片时再一并放入接收队列供应用层取用。</li>\n</ol>\n</li>\n<li><p><strong>快速重传机制：</strong>数据在网络中的传输时间是不固定的，因此超时重传时间比较长。而为了尽早地判断出数据包的丢失，kcp引入了快速重传机制。快速重传机制工作原理是，当发送方发送了n,n+1,n+2…等等包出去后，接收方没有接收到n,而接收到n+1,n+2..等等n号包之后的包，这时因为n号包之后的包都已经接收到了，而n号包还没有接收到，所以可以认为n号包已经丢失了，告知发送方可以进行快速重传。kcp为了支持快速重传，接收方需要告诉发送方，哪些包已经成功收到了，哪些包没有收到。因此接收方返回发送方的确认数据（ack）中包含以下信息：接收窗口左端的序号rcv_nxt,接收到的大于rcv_nxt的包序号sn。rcv_nxt的含义是接收方已经成功按顺序接收了rcv_nxt序号之前的所有包,大于rcv_nxt的序号sn表示的是在接收窗口内的不连续的包。发送方接收到接收方发过来的数据时，首先解析rcv_nxt，把发送缓存中所有小于rcv_nxt序号的包全部移除掉（因为这些包全都都已经正确接收了）。然后再解析sn,遍历发送缓存，找到所有序号小于sn的包，这些包就是可能在网络中已经丢掉了的包,只是可能，因为有可能这些包只是拥堵在了网络中，需要更长的时间到达，所以这里我们设置一个快速重传的门限，对每个分片维护一个快速重传的计数，每收到一个ack解析sn后找到了一个分片，就把该分片的快速重传的计数加一，如果该计数达到了快速重传门限，那么就认为该分片已经丢失，可以触发快速重传，该门限值在kcp中可以设置，tcp中是3。</p>\n</li>\n<li><p><strong>选择重传机制：</strong>选择重传的关键在于接收方要告知发送方哪些包已经收到了，哪些包没有收到，为了最小化数据量，接收方可以告诉发送方哪些包已经按序收到了，哪些包是收到的但是不连续。所以返回的ack中包含rcv_nxt和sn。rcv_nxt代表收到的所有连续的包，sn代表哪些不连续的包收到了，那么根据这两个参数可以计算出来没有收到的包的序号。</p>\n</li>\n<li><p><strong>拥塞控制：</strong>拥塞控制就是告诉发送方，网络太堵了，应该少发一些数据，因此在滑动窗口的机制上引入了拥塞窗口，也就是说发送发发送的数据不得超过拥塞窗口，拥塞窗口的大小会随网络情况而变快，网络快拥塞窗口就大，反之同理。拥塞窗口的大小控制使用慢启动机制，具体参考TCP。</p>\n</li>\n</ol>\n<p>应用：kcp采取一系列措施尽量提高网络传输速率，在网络实时性和可靠性要求比较高的场景下可以考虑kcp协议代替tcp协议。</p>\n<p>名词说明（源码字段）：<br>用户数据：应用层发送的数据，如一张图片2Kb的数据<br>MTU：最大传输单元。即每次发送的最大数据<br>RTO：Retransmission TimeOut，重传超时时间。<br>cwnd:congestion window，拥塞窗口，表示发送方可发送多少个KCP数据包。与接收方窗口有关，与网络状况（拥塞控制）有关，与发送窗口大小有关。<br>rwnd:receiver window,接收方窗口大小，表示接收方还可接收多少个KCP数据包<br>snd_queue:待发送KCP数据包队列<br>snd_nxt:下一个即将发送的kcp数据包序列号<br>snd_una:下一个待确认的序列号</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1.png?resize=640,467\" alt=\"TCP/KCP详解，及源码注解 - 第1张  | 张嘎\"></p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2.png?resize=640,351\" alt=\"TCP/KCP详解，及源码注解 - 第2张  | 张嘎\"></p>\n<p>[ KCP 发送过程 ]</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3.jpg?resize=485,296\" alt=\"TCP/KCP详解，及源码注解 - 第3张  | 张嘎\"></p>\n<p>[ RTO算法对比图 ]</p>\n<p>KCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4.png?resize=365,353\" alt=\"TCP/KCP详解，及源码注解 - 第4张  | 张嘎\"></p>\n<p><strong>rcv_queue的数据是连续的，rcv_buf可能是间隔的</strong></p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/5.png?resize=355,448\" alt=\"TCP/KCP详解，及源码注解 - 第5张  | 张嘎\"></p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/6.png?resize=466,424\" alt=\"TCP/KCP详解，及源码注解 - 第6张  | 张嘎\"></p>\n<p>[ 数据确认包处理流程 ]</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/7.png?resize=574,403\" alt=\"TCP/KCP详解，及源码注解 - 第7张  | 张嘎\"></p>\n<p>[ KCP快速确认 ]</p>\n<p><strong>总结：TCP可靠简单，但是复杂无私，所以速度慢。KCP尽可能保留UDP快的特点下，保证可靠。</strong></p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/992994-20180616162318524-660296383.jpg?resize=640,323\" alt=\"TCP/KCP详解，及源码注解 - 第8张  | 张嘎\"></p>\n<p>总结：UDP收到的包，不断通过kcp_input喂给KCP，KCP会对这部分数据（KCP协议数据）进行解包，重新封装成应用层用户数据，应用层通过kcp_recv获取。应用层通过kcp_send发送数据，KCP会把用户数据拆分kcp数据包，通过kcp_output，以UDP（send）的方式发送。</p>\n<p><strong>KCP的配置模式</strong></p>\n<p>\\1. 工作模式：</p>\n<blockquote>\n<p>int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)</p>\n</blockquote>\n<ul>\n<li>nodelay ：是否启用 nodelay模式，0不启用；1启用。</li>\n<li>interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms</li>\n<li>resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）</li>\n<li>nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。</li>\n</ul>\n<p><strong>普通模式：</strong> ikcp_nodelay(kcp, 0, 40, 0, 0);</p>\n<p><strong>极速模式：</strong> ikcp_nodelay(kcp, 1, 10, 2, 1)</p>\n<p>\\1. 最大窗口</p>\n<blockquote>\n<p>int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);</p>\n</blockquote>\n<p>该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。</p>\n<p>\\2. 最大传输单元：</p>\n<p>纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。</p>\n<p>\\3. 最小RTO：</p>\n<p>不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：<br>kcp-&gt;rx_minrto = 10;</p>\n<p>KCP原理见：<a href=\"https://www.cnblogs.com/wetest/p/9190786.html\">KCP原理</a></p>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><h3 id=\"特性：\"><a href=\"#特性：\" class=\"headerlink\" title=\"特性：\"></a>特性：</h3><p>1.为流量设计（KB数据/秒），充分利用宽带。</p>\n<p>2.安全可靠，丢包全部重传。</p>\n<p>3.超时 = RTO * 2。</p>\n<p>4.延迟ACK，充分利用宽带。</p>\n<h4 id=\"UNA-vs-ACK-UNA：\"><a href=\"#UNA-vs-ACK-UNA：\" class=\"headerlink\" title=\"UNA vs ACK+UNA：\"></a>UNA vs ACK+UNA：</h4><p>ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到  ），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而  KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</p>\n<h3 id=\"拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\"><a href=\"#拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\" class=\"headerlink\" title=\"拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\"></a>拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。</h3><p><strong>慢开始算法</strong>：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120451114.jpg?resize=499,305\" alt=\"TCP/KCP详解，及源码注解 - 第9张  | 张嘎\"></p>\n<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>\n<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>\n<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>\n<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>\n<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>\n<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>\n<p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>\n<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>\n<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120591634.jpg?resize=570,306\" alt=\"TCP/KCP详解，及源码注解 - 第10张  | 张嘎\"></p>\n<p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</p>\n<p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。</p>\n<p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。</p>\n<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞。</strong></p>\n<h3 id=\"快重传和快恢复算法：\"><a href=\"#快重传和快恢复算法：\" class=\"headerlink\" title=\"快重传和快恢复算法：\"></a>快重传和快恢复算法：</h3><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>\n<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2010101122524670.jpg?resize=492,276\" alt=\"TCP/KCP详解，及源码注解 - 第11张  | 张嘎\"></p>\n<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>\n<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>\n<p>&lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>\n<p>&lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>\n<p>下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>\n<p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101123101842.jpg?resize=621,313\" alt=\"TCP/KCP详解，及源码注解 - 第12张  | 张嘎\"></p>\n<p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>\n<p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p>\n<p>采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>\n<p>接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。</p>\n<p>发送方窗口的上限值 = Min [ rwnd, cwnd ]</p>\n<p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>\n<p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"KCP-Netty的中文注解版：\"><a href=\"#KCP-Netty的中文注解版：\" class=\"headerlink\" title=\"KCP-Netty的中文注解版：\"></a>KCP-Netty的中文注解版：</h1><p><a href=\"https://github.com/zhangga/kcp-netty\">kcp-netty中文注释</a></p>\n<h1 id=\"KCP-UDT比较：\"><a href=\"#KCP-UDT比较：\" class=\"headerlink\" title=\"KCP/UDT比较：\"></a>KCP/UDT比较：</h1><p><a href=\"https://github.com/libinzhangyuan/asio_kcp\">kcp/udt</a></p>\n<h1 id=\"KCP\"><a href=\"#KCP\" class=\"headerlink\" title=\"KCP\"></a>KCP</h1><p>传输层，可靠性，ARQ协议。</p>\n<p>目的：解决在网络拥堵情况下tcp协议的网络速度慢的问题。可靠性，传输速度。</p>\n<p>一般用udp作为下层传输协议，udp报文+控制头。</p>\n<p>传输数据大于mss(最大报文段)时，kcp将数据分片存储在多个kcp包(Segment)中。</p>\n<ol>\n<li><ol>\n<li><strong>滑动窗口机制：</strong>kcp采用滑动窗口机制来提高发送速度。由于UDP在网络中的传输是不可靠的，因此会出现丢包和包的乱序。kcp是可靠的保证数据有序的协议，所以为了纠正包的乱序。接收方维护一个接收窗口。接收窗口有一个起始序号rcv_nxt以及尾序号rcv_nxt+rcv_wnd。如果接收窗口收到序号为rcv_nxt的分片那么rcv_nxt就加一，形象一点的说法是滑动窗口右移,并把该数据放入接收队列供应用层取用。如果收到的数据在窗口范围内但不是rcv_nxt那么就把数据保存起来,等收到rcv_nxt序号的分片时再一并放入接收队列供应用层取用。</li>\n</ol>\n</li>\n<li><p><strong>快速重传机制：</strong>数据在网络中的传输时间是不固定的，因此超时重传时间比较长。而为了尽早地判断出数据包的丢失，kcp引入了快速重传机制。快速重传机制工作原理是，当发送方发送了n,n+1,n+2…等等包出去后，接收方没有接收到n,而接收到n+1,n+2..等等n号包之后的包，这时因为n号包之后的包都已经接收到了，而n号包还没有接收到，所以可以认为n号包已经丢失了，告知发送方可以进行快速重传。kcp为了支持快速重传，接收方需要告诉发送方，哪些包已经成功收到了，哪些包没有收到。因此接收方返回发送方的确认数据（ack）中包含以下信息：接收窗口左端的序号rcv_nxt,接收到的大于rcv_nxt的包序号sn。rcv_nxt的含义是接收方已经成功按顺序接收了rcv_nxt序号之前的所有包,大于rcv_nxt的序号sn表示的是在接收窗口内的不连续的包。发送方接收到接收方发过来的数据时，首先解析rcv_nxt，把发送缓存中所有小于rcv_nxt序号的包全部移除掉（因为这些包全都都已经正确接收了）。然后再解析sn,遍历发送缓存，找到所有序号小于sn的包，这些包就是可能在网络中已经丢掉了的包,只是可能，因为有可能这些包只是拥堵在了网络中，需要更长的时间到达，所以这里我们设置一个快速重传的门限，对每个分片维护一个快速重传的计数，每收到一个ack解析sn后找到了一个分片，就把该分片的快速重传的计数加一，如果该计数达到了快速重传门限，那么就认为该分片已经丢失，可以触发快速重传，该门限值在kcp中可以设置，tcp中是3。</p>\n</li>\n<li><p><strong>选择重传机制：</strong>选择重传的关键在于接收方要告知发送方哪些包已经收到了，哪些包没有收到，为了最小化数据量，接收方可以告诉发送方哪些包已经按序收到了，哪些包是收到的但是不连续。所以返回的ack中包含rcv_nxt和sn。rcv_nxt代表收到的所有连续的包，sn代表哪些不连续的包收到了，那么根据这两个参数可以计算出来没有收到的包的序号。</p>\n</li>\n<li><p><strong>拥塞控制：</strong>拥塞控制就是告诉发送方，网络太堵了，应该少发一些数据，因此在滑动窗口的机制上引入了拥塞窗口，也就是说发送发发送的数据不得超过拥塞窗口，拥塞窗口的大小会随网络情况而变快，网络快拥塞窗口就大，反之同理。拥塞窗口的大小控制使用慢启动机制，具体参考TCP。</p>\n</li>\n</ol>\n<p>应用：kcp采取一系列措施尽量提高网络传输速率，在网络实时性和可靠性要求比较高的场景下可以考虑kcp协议代替tcp协议。</p>\n<p>名词说明（源码字段）：<br>用户数据：应用层发送的数据，如一张图片2Kb的数据<br>MTU：最大传输单元。即每次发送的最大数据<br>RTO：Retransmission TimeOut，重传超时时间。<br>cwnd:congestion window，拥塞窗口，表示发送方可发送多少个KCP数据包。与接收方窗口有关，与网络状况（拥塞控制）有关，与发送窗口大小有关。<br>rwnd:receiver window,接收方窗口大小，表示接收方还可接收多少个KCP数据包<br>snd_queue:待发送KCP数据包队列<br>snd_nxt:下一个即将发送的kcp数据包序列号<br>snd_una:下一个待确认的序列号</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/1.png?resize=640,467\" alt=\"TCP/KCP详解，及源码注解 - 第1张  | 张嘎\"></p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2.png?resize=640,351\" alt=\"TCP/KCP详解，及源码注解 - 第2张  | 张嘎\"></p>\n<p>[ KCP 发送过程 ]</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3.jpg?resize=485,296\" alt=\"TCP/KCP详解，及源码注解 - 第3张  | 张嘎\"></p>\n<p>[ RTO算法对比图 ]</p>\n<p>KCP的接收过程是将UDP收到的数据进行解包，重新组装顺序的、可靠的数据后交付给用户。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4.png?resize=365,353\" alt=\"TCP/KCP详解，及源码注解 - 第4张  | 张嘎\"></p>\n<p><strong>rcv_queue的数据是连续的，rcv_buf可能是间隔的</strong></p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/5.png?resize=355,448\" alt=\"TCP/KCP详解，及源码注解 - 第5张  | 张嘎\"></p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/6.png?resize=466,424\" alt=\"TCP/KCP详解，及源码注解 - 第6张  | 张嘎\"></p>\n<p>[ 数据确认包处理流程 ]</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/7.png?resize=574,403\" alt=\"TCP/KCP详解，及源码注解 - 第7张  | 张嘎\"></p>\n<p>[ KCP快速确认 ]</p>\n<p><strong>总结：TCP可靠简单，但是复杂无私，所以速度慢。KCP尽可能保留UDP快的特点下，保证可靠。</strong></p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/992994-20180616162318524-660296383.jpg?resize=640,323\" alt=\"TCP/KCP详解，及源码注解 - 第8张  | 张嘎\"></p>\n<p>总结：UDP收到的包，不断通过kcp_input喂给KCP，KCP会对这部分数据（KCP协议数据）进行解包，重新封装成应用层用户数据，应用层通过kcp_recv获取。应用层通过kcp_send发送数据，KCP会把用户数据拆分kcp数据包，通过kcp_output，以UDP（send）的方式发送。</p>\n<p><strong>KCP的配置模式</strong></p>\n<p>\\1. 工作模式：</p>\n<blockquote>\n<p>int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)</p>\n</blockquote>\n<ul>\n<li>nodelay ：是否启用 nodelay模式，0不启用；1启用。</li>\n<li>interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms</li>\n<li>resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）</li>\n<li>nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。</li>\n</ul>\n<p><strong>普通模式：</strong> ikcp_nodelay(kcp, 0, 40, 0, 0);</p>\n<p><strong>极速模式：</strong> ikcp_nodelay(kcp, 1, 10, 2, 1)</p>\n<p>\\1. 最大窗口</p>\n<blockquote>\n<p>int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);</p>\n</blockquote>\n<p>该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。</p>\n<p>\\2. 最大传输单元：</p>\n<p>纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。</p>\n<p>\\3. 最小RTO：</p>\n<p>不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：<br>kcp-&gt;rx_minrto = 10;</p>\n<p>KCP原理见：<a href=\"https://www.cnblogs.com/wetest/p/9190786.html\">KCP原理</a></p>\n<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><h3 id=\"特性：\"><a href=\"#特性：\" class=\"headerlink\" title=\"特性：\"></a>特性：</h3><p>1.为流量设计（KB数据/秒），充分利用宽带。</p>\n<p>2.安全可靠，丢包全部重传。</p>\n<p>3.超时 = RTO * 2。</p>\n<p>4.延迟ACK，充分利用宽带。</p>\n<h4 id=\"UNA-vs-ACK-UNA：\"><a href=\"#UNA-vs-ACK-UNA：\" class=\"headerlink\" title=\"UNA vs ACK+UNA：\"></a>UNA vs ACK+UNA：</h4><p>ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到  ），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而  KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</p>\n<h3 id=\"拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\"><a href=\"#拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\" class=\"headerlink\" title=\"拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。\"></a>拥塞控制算法：目标：公平占有宽带的前提下，无限度提高宽带的利用率。</h3><p><strong>慢开始算法</strong>：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>\n<p><img src=\"https://i1.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120451114.jpg?resize=499,305\" alt=\"TCP/KCP详解，及源码注解 - 第9张  | 张嘎\"></p>\n<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>\n<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>\n<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</p>\n<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p>\n<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>\n<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>\n<p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>\n<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>\n<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101120591634.jpg?resize=570,306\" alt=\"TCP/KCP详解，及源码注解 - 第10张  | 张嘎\"></p>\n<p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</p>\n<p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd 随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线 性规律增长。</p>\n<p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值 24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过 一个往返时间增加一个MSS的大小。</p>\n<p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，<strong>使网络比较不容易出现拥塞。</strong></p>\n<h3 id=\"快重传和快恢复算法：\"><a href=\"#快重传和快恢复算法：\" class=\"headerlink\" title=\"快重传和快恢复算法：\"></a>快重传和快恢复算法：</h3><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p>\n<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>\n<p><img src=\"https://i0.wp.com/192.144.167.243/blog/wp-content/uploads/2010101122524670.jpg?resize=492,276\" alt=\"TCP/KCP详解，及源码注解 - 第11张  | 张嘎\"></p>\n<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>\n<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>\n<p>&lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>\n<p>&lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>\n<p>下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p>\n<p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/2010101123101842.jpg?resize=621,313\" alt=\"TCP/KCP详解，及源码注解 - 第12张  | 张嘎\"></p>\n<p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>\n<p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p>\n<p>采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>\n<p>接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。</p>\n<p>发送方窗口的上限值 = Min [ rwnd, cwnd ]</p>\n<p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p>\n<p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>\n"},{"title":"Redis常见面试题","date":"2019-03-27T11:52:43.000Z","id":"redis-pre","_content":"\n和Redis结缘还是2011年刚开始实习，做的第一款游戏《部落战争》，\n就是使用的Redis作为持久层和缓存。 当时对Redis的认识还比较浅，但是Redis的好多特性已经开始慢慢了解。\n\n这里推荐一下大神的Redis公众号。付磊。快手同事，《Redis开发与运维》一书的作者，强烈推荐这本书，偏向实战，另外一本很有名的书《Redis设计与实现》更注重原理。两本书都非常值得好好读下。\n\n![Redis常见面试题 - 第1张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4-576x1024.jpg?resize=640%2C1138)\n\n![Redis常见面试题 - 第2张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-576x1024.jpg?resize=576%2C1024)\n\n#### Memcached相比于Redis的主要特点有如下：\n\n\\1. 超高OPS：例如千万级别以上（线上千万OPS以上的Redis也存在）\n\\2. 多线程：抗热点能力强。\n\\3. 支持大value：例如Memcached 5支持100MB以上的value\n\n但Memcached相比于Redis维护成本会更高，而且对于很多基础设施支持也不好（双机房、键值分析、内存优化、服务端高可用）。\n\n最近发现KCC上出现Memcached滥用的情况\n\n为防止滥用，必须满足如下规则才会开通：\n\n\\1. OPS: 超过100万\n\\2. big value：10MB+\n\\3. 明显热点\n\\4. CAS需求\n\n**一、Redis常见的数据结构和使用场景**\n\n(一)String 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做**一些复杂的计数功能的缓存。**\n\n(二)hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做**单点登录**的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。\n\n(三)list 使用List的数据结构，可以**做简单的消息队列的功能**。另外还有一个就是，可以利用lrange命令，**做基于redis的分页功能**，性能极佳，用户体验好。\n\n(四)set 因为set堆放的是一堆不重复值的集合。所以可以做**全局去重的功能**。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以**计算共同喜好，全部的喜好，自己独有的喜好等功能**。\n\n(五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做**排行榜应用，取TOP N操作**。另外，参照另一篇[《分布式之延时任务方案解析》](http://link.zhihu.com/?target=https%3A//www.cnblogs.com/rjzheng/p/8972725.html)，该文指出了sorted set可以用来做**延时任务**。最后一个应用就是可以做**范围查找**。\n\n**二、Redis的hash怎么实现的**\n满足以下两条件时：\n1、键和值的长度都小于64字节\n2、键值对数量小于512个\n使用ziplist编码。不满足时转化为hashtable编码，并且这个转化过程是不可逆的。\nhashtable的实现方式和Java的hashmap类似，数组上散列，散列冲突的使用链表，不同的是redis采用渐进式的rehash策略。\n何为**渐进式rehash**？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。维护两张哈希表，1个索引来指示当前的rehash进度。\nrehash是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。\n**Java HashMap**的rehash，每次创建一个数组（哈希表），一次性将old表rehash过去。\n\n**三、为什么不能用Redis做专门的持久化**\n性价比：内存吃紧 ，海量数据在重启后加载耗时。RDB加载快。\n权限控制。\n数据完整：MySQL 在崩溃处理，数据恢复方面比reids好。\nredis作为数据库查询功能太弱。数据KV弱于结构化。\n数据隔离。\n\n# Redis Cluster|功能限制\n\n1.Key批量操作支持有限。目前只支持同slot内的key执行批量操作（如mget,mset）。\n\n2.Key事务操作支持有限。只支持多key在同一个节点上的事务操作，多个key分布在不同节点上时无法使用事务功能。\n\n3.Key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash，list等映射到不同节点。\n\n4.不支持多数据库空间，集群模式下只能使用db0空间。\n\n5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。\n\n# Redis Cluster高可用\n\n提供了灵活的节点扩容和收缩方案，在不影响集群对外服务的情况下进行。\n自动故障转移保证集群可以正常对外提供服务。主观下线，客观下线，投票选举策略。选出从节点替换主节点，保证集群高可用。\n\n**下面是两篇引用的文章。https://zhuanlan.zhihu.com/p/59168140**\n\n## 引言\n\n## 为什么写这篇文章?\n\n博主的[《分布式之消息队列复习精讲》](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/rjzheng/p/8994962.html)得到了大家的好评，内心诚惶诚恐，想着再出一篇关于复习精讲的文章。但是还是要说明一下，复习精讲的文章偏面试准备，真正在开发过程中，还是脚踏实地，一步一个脚印，不要投机取巧。 考虑到绝大部分写业务的程序员，在实际开发中使用redis的时候，只会setvalue和getvalue两个操作，对redis整体缺乏一个认知。又恰逢博主某个同事下周要去培训redis，所以博主斗胆以redis为题材，对redis常见问题做一个总结，希望能够弥补大家的知识盲点。\n\n## 复习要点?\n\n本文围绕以下几点进行阐述\n\n- 1、为什么使用redis\n- 2、使用redis有什么缺点\n- 3、单线程的redis为什么这么快\n- 4、redis的数据类型，以及每种数据类型的使用场景\n- 5、redis的过期策略以及内存淘汰机制\n- 6、redis和数据库双写一致性问题\n- 7、如何应对缓存穿透和缓存雪崩问题\n- 8、如何解决redis的并发竞争问题\n\n## 正文\n\n## 1、为什么使用redis\n\n**分析**:博主觉得在项目中使用redis，主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。\n\n**回答**:如下所示，分为两点\n\n**（一）性能** 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够**迅速响应**。\n\n![Redis常见面试题 - 第3张  | 张嘎](https://i0.wp.com/pic4.zhimg.com/80/v2-8200a2192b95b1596dc8d02c71b9abcf_hd.jpg?w=640&ssl=1)\n\n**题外话：**忽然想聊一下这个**迅速响应**的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在**瞬间**解决，对于页内操作则需要在**刹那**间解决。另外，超过**一弹指**的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。” 那么**瞬间、刹那、一弹指**具体是多少时间呢？ 根据《摩诃僧祗律》记载\n\n```\n一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。\n```\n\n那么，经过周密的计算，一**瞬间**为0.36 秒,一**刹那**有 0.018 秒.一**弹指**长达 7.2 秒。\n\n**（二）并发** 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。\n\n![Redis常见面试题 - 第4张  | 张嘎](https://i2.wp.com/pic3.zhimg.com/80/v2-ee0f4577491f13d82e185e7ef6aa8eae_hd.jpg?w=640&ssl=1)\n\n## 2、使用redis有什么缺点\n\n**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。\n\n**回答**:主要是四个问题\n\n- (一)缓存和数据库双写一致性问题\n- (二)缓存雪崩问题\n- (三)缓存击穿问题\n- (四)缓存的并发竞争问题\n\n这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。\n\n## 3、单线程的redis为什么这么快\n\n**分析**:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。\n\n**回答**:主要是以下三点 (一)纯内存操作 (二)单线程操作，避免了频繁的上下文切换 (三)采用了非阻塞**I/O多路复用机制**\n\n**题外话：**我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了**一批**快递员，然后小曲发现资金不够了，只够买**一辆**车送快递。\n\n**经营方式一** 客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题 – 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递 – 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了 – 快递员之间的协调很花时间\n\n综合上述缺点，小曲痛定思痛，提出了下面的经营方式\n\n**经营方式二** 小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按**送达地点**标注好，然后**依次**放在一个地方。最后，那个快递员**依次**的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。\n\n**对比** 上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。\n\n在上述比喻中:\n\n- 每个快递员——————>每个线程\n- 每个快递——————–>每个socket(I/O流)\n- 快递的送达地点————–>socket的不同状态\n- 客户送快递请求————–>来自客户端的请求\n- 小曲的经营方式————–>服务端运行的代码\n- 一辆车———————->CPU的核数\n\n于是我们有如下结论\n\n1. 经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。\n2. 经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。\n\n下面类比到真实的redis线程模型，如图所示\n\n![Redis常见面试题 - 第5张  | 张嘎](https://i0.wp.com/pic1.zhimg.com/80/v2-fa81e4bb9560b8ac6470bfa322f36a98_hd.jpg?w=640&ssl=1)\n\n参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。\n\n## 5、redis的过期策略以及内存淘汰机制\n\n**分析**:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?\n\n**回答**: redis采用的是定期删除+惰性删除策略。\n\n**为什么不用定时删除策略?** 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.\n\n**定期删除+惰性删除是如何工作的呢?**\n\n定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。\n\n**采用定期删除+惰性删除就没其他问题了么?**\n\n不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**。 在redis.conf中有一行配置\n\n```\n# maxmemory-policy volatile-lru\n```\n\n该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)\n\n1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**\n\n2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**\n\n3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**\n\n4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**\n\n5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐** 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐** ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。\n\n## 6、redis和数据库双写一致性问题\n\n**分析**:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是**如果对数据有强一致性要求，不能放缓存。**我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说**降低不一致发生的概率**，无法完全避免。因此，有强一致性要求的数据，不能放缓存。\n\n**回答**:[《分布式之数据库和缓存双写一致性方案解析》](http://link.zhihu.com/?target=https%3A//www.cnblogs.com/rjzheng/p/9041659.html)给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。\n\n## 7、如何应对缓存穿透和缓存雪崩问题\n\n**分析**:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。\n\n**回答**:如下所示\n\n**缓存穿透**，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。\n\n**解决方案**: (一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 (二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作。 (三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。\n\n**缓存雪崩**，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。\n\n**解决方案**: (一)给缓存的失效时间，加上一个随机值，避免集体失效。 (二)使用互斥锁，但是该方案吞吐量明显下降了。 (三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 – I 从缓存A读数据库，有则直接返回 – II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 – III 更新线程同时更新缓存A和缓存B。\n\n## 8、如何解决redis的并发竞争key问题\n\n**分析**:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主**不推荐使用redis的事务机制。**因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，**redis的事务机制，十分鸡肋。**\n\n**回答:**如下所示\n\n(1)如果对这个key操作，**不要求顺序** 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。\n\n(2)如果对这个key操作，**要求顺序** 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA–>valueB–>valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下\n\n```\n系统A key 1 {valueA  3:00}\n系统B key 1 {valueB  3:05}\n系统C key 1 {valueC  3:10}\n```\n\n那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。\n\n其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。\n\n\n\n# [【原创】分布式之数据库和缓存双写一致性方案解析](https://www.cnblogs.com/rjzheng/p/9041659.html)\n\n## 引言\n\n### 为什么写这篇文章？\n\n![Redis常见面试题 - 第6张  | 张嘎](https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_getkeyflow.png?w=640&ssl=1)\n\n首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。\n\n但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。\n\n### 文章结构\n\n本文由以下三个部分组成\n1、讲解缓存更新策略\n2、对每种策略进行缺点分析\n3、针对缺点给出改进方案\n\n## 正文\n\n先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。\n在这里，我们讨论**三种**更新策略：\n\n1. 先更新数据库，再更新缓存\n2. 先删除缓存，再更新数据库\n3. 先更新数据库，再删除缓存\n\n应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。\n\n### (1)先更新数据库，再更新缓存\n\n这套方案，大家是普遍反对的。为什么呢？有如下两点原因。\n**原因一（线程安全角度）**\n同时有请求A和请求B进行更新操作，那么会出现\n（1）线程A更新了数据库\n（2）线程B更新了数据库\n（3）线程B更新了缓存\n（4）线程A更新了缓存\n这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n**原因二（业务场景角度）**\n有如下两点：\n（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n\n接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。\n\n### (2)先删缓存，再更新数据库\n\n该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n（1）请求A进行写操作，删除缓存\n（2）请求B查询发现缓存不存在\n（3）请求B去数据库查询得到旧值\n（4）请求B将旧值写入缓存\n（5）请求A将新值写入数据库\n上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n那么，**如何解决呢？采用延时双删策略**\n伪代码如下\n\n```\npublic void write(String key,Object data){\n        redis.delKey(key);\n        db.updateData(data);\n        Thread.sleep(1000);\n        redis.delKey(key);\n    }\n```\n\n转化为中文描述就是\n（1）先淘汰缓存\n（2）再写数据库（这两步和原来一样）\n（3）休眠1秒，再次淘汰缓存\n这么做，可以将1秒内所造成的缓存脏数据，再次删除。\n**那么，这个1秒怎么确定的，具体该休眠多久呢？**\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n**如果你用了mysql的读写分离架构怎么办？**\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n（1）请求A进行写操作，删除缓存\n（2）请求A将数据写入数据库了，\n（3）请求B查询缓存发现，缓存没有值\n（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n（5）请求B将旧值写入缓存\n（6）数据库完成主从同步，从库变为新值\n上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n**采用这种同步淘汰策略，吞吐量降低怎么办？**\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n**第二次删除,如果删除失败怎么办？**\n这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：\n（1）请求A进行写操作，删除缓存\n（2）请求B查询发现缓存不存在\n（3）请求B去数据库查询得到旧值\n（4）请求B将旧值写入缓存\n（5）请求A将新值写入数据库\n（6）请求A试图去删除请求B写入对缓存值，结果失败了。\nok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。\n**如何解决呢？**\n具体解决方案，且看博主对第(3)种更新策略的解析。\n\n### (3)先更新数据库，再删缓存\n\n首先，先说一下。老外提出了一个缓存更新套路，名为[《Cache-Aside pattern》](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)。其中就指出\n\n- **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。\n- **命中**：应用程序从cache中取数据，取到后返回。\n- **更新**：先把数据存到数据库中，成功后，再让缓存失效。\n\n![Redis常见面试题 - 第7张  | 张嘎](https://i2.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png?w=640&ssl=1)\n\n![Redis常见面试题 - 第8张  | 张嘎](https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png?w=640&ssl=1)\n\n另外，知名社交网站facebook也在论文[《Scaling Memcache at Facebook》](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)中提出，他们用的也是先更新数据库，再删缓存的策略。\n**这种情况不存在并发问题么？**\n不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n（1）缓存刚好失效\n（2）请求A查询数据库，得一个旧值\n（3）请求B将新值写入数据库\n（4）请求B删除缓存\n（5）请求A将查到的旧值写入缓存\nok，如果发生上述情况，确实是会发生脏数据。\n**然而，发生这种情况的概率又有多少呢？**\n发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n假设，有人非要抬杠，有强迫症，一定要解决怎么办？\n**如何解决上述并发问题？**\n首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。\n**还有其他造成不一致的原因么？**\n有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。\n**如何解决？**\n提供一个保障的重试机制即可，这里给出两套方案。\n**方案一**：\n如下图所示\n\n流程如下所示\n（1）更新数据库数据；\n（2）缓存因为种种问题删除失败\n（3）将需要删除的key发送至消息队列\n（4）自己消费消息，获得需要删除的key\n（5）继续重试删除操作，直到成功\n然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。\n**方案二**：\n\n流程如下图所示：\n（1）更新数据库数据\n（2）数据库会将操作信息写入binlog日志当中\n（3）订阅程序提取出所需要的数据以及key\n（4）另起一段非业务代码，获得该信息\n（5）尝试删除缓存操作，发现删除失败\n（6）将这些信息发送至消息队列\n（7）重新从消息队列中获得该数据，重试操作。\n\n**备注说明：**上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。\n\n## 总结\n\n本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。\n\n## 参考文献\n\n1、[主从DB与cache一致性](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect)\n2、[缓存更新的套路](https://coolshell.cn/articles/17416.html)\n","source":"_posts/redis-pre.md","raw":"---\ntitle: Redis常见面试题\ndate: 2019-03-27 19:52:43\ntags:\n  - 笔记\nid: redis-pre\ncategories:\n  - 笔记\n---\n\n和Redis结缘还是2011年刚开始实习，做的第一款游戏《部落战争》，\n就是使用的Redis作为持久层和缓存。 当时对Redis的认识还比较浅，但是Redis的好多特性已经开始慢慢了解。\n\n这里推荐一下大神的Redis公众号。付磊。快手同事，《Redis开发与运维》一书的作者，强烈推荐这本书，偏向实战，另外一本很有名的书《Redis设计与实现》更注重原理。两本书都非常值得好好读下。\n\n![Redis常见面试题 - 第1张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4-576x1024.jpg?resize=640%2C1138)\n\n![Redis常见面试题 - 第2张  | 张嘎](https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-576x1024.jpg?resize=576%2C1024)\n\n#### Memcached相比于Redis的主要特点有如下：\n\n\\1. 超高OPS：例如千万级别以上（线上千万OPS以上的Redis也存在）\n\\2. 多线程：抗热点能力强。\n\\3. 支持大value：例如Memcached 5支持100MB以上的value\n\n但Memcached相比于Redis维护成本会更高，而且对于很多基础设施支持也不好（双机房、键值分析、内存优化、服务端高可用）。\n\n最近发现KCC上出现Memcached滥用的情况\n\n为防止滥用，必须满足如下规则才会开通：\n\n\\1. OPS: 超过100万\n\\2. big value：10MB+\n\\3. 明显热点\n\\4. CAS需求\n\n**一、Redis常见的数据结构和使用场景**\n\n(一)String 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做**一些复杂的计数功能的缓存。**\n\n(二)hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做**单点登录**的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。\n\n(三)list 使用List的数据结构，可以**做简单的消息队列的功能**。另外还有一个就是，可以利用lrange命令，**做基于redis的分页功能**，性能极佳，用户体验好。\n\n(四)set 因为set堆放的是一堆不重复值的集合。所以可以做**全局去重的功能**。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以**计算共同喜好，全部的喜好，自己独有的喜好等功能**。\n\n(五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做**排行榜应用，取TOP N操作**。另外，参照另一篇[《分布式之延时任务方案解析》](http://link.zhihu.com/?target=https%3A//www.cnblogs.com/rjzheng/p/8972725.html)，该文指出了sorted set可以用来做**延时任务**。最后一个应用就是可以做**范围查找**。\n\n**二、Redis的hash怎么实现的**\n满足以下两条件时：\n1、键和值的长度都小于64字节\n2、键值对数量小于512个\n使用ziplist编码。不满足时转化为hashtable编码，并且这个转化过程是不可逆的。\nhashtable的实现方式和Java的hashmap类似，数组上散列，散列冲突的使用链表，不同的是redis采用渐进式的rehash策略。\n何为**渐进式rehash**？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。维护两张哈希表，1个索引来指示当前的rehash进度。\nrehash是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。\n**Java HashMap**的rehash，每次创建一个数组（哈希表），一次性将old表rehash过去。\n\n**三、为什么不能用Redis做专门的持久化**\n性价比：内存吃紧 ，海量数据在重启后加载耗时。RDB加载快。\n权限控制。\n数据完整：MySQL 在崩溃处理，数据恢复方面比reids好。\nredis作为数据库查询功能太弱。数据KV弱于结构化。\n数据隔离。\n\n# Redis Cluster|功能限制\n\n1.Key批量操作支持有限。目前只支持同slot内的key执行批量操作（如mget,mset）。\n\n2.Key事务操作支持有限。只支持多key在同一个节点上的事务操作，多个key分布在不同节点上时无法使用事务功能。\n\n3.Key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash，list等映射到不同节点。\n\n4.不支持多数据库空间，集群模式下只能使用db0空间。\n\n5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。\n\n# Redis Cluster高可用\n\n提供了灵活的节点扩容和收缩方案，在不影响集群对外服务的情况下进行。\n自动故障转移保证集群可以正常对外提供服务。主观下线，客观下线，投票选举策略。选出从节点替换主节点，保证集群高可用。\n\n**下面是两篇引用的文章。https://zhuanlan.zhihu.com/p/59168140**\n\n## 引言\n\n## 为什么写这篇文章?\n\n博主的[《分布式之消息队列复习精讲》](http://link.zhihu.com/?target=http%3A//www.cnblogs.com/rjzheng/p/8994962.html)得到了大家的好评，内心诚惶诚恐，想着再出一篇关于复习精讲的文章。但是还是要说明一下，复习精讲的文章偏面试准备，真正在开发过程中，还是脚踏实地，一步一个脚印，不要投机取巧。 考虑到绝大部分写业务的程序员，在实际开发中使用redis的时候，只会setvalue和getvalue两个操作，对redis整体缺乏一个认知。又恰逢博主某个同事下周要去培训redis，所以博主斗胆以redis为题材，对redis常见问题做一个总结，希望能够弥补大家的知识盲点。\n\n## 复习要点?\n\n本文围绕以下几点进行阐述\n\n- 1、为什么使用redis\n- 2、使用redis有什么缺点\n- 3、单线程的redis为什么这么快\n- 4、redis的数据类型，以及每种数据类型的使用场景\n- 5、redis的过期策略以及内存淘汰机制\n- 6、redis和数据库双写一致性问题\n- 7、如何应对缓存穿透和缓存雪崩问题\n- 8、如何解决redis的并发竞争问题\n\n## 正文\n\n## 1、为什么使用redis\n\n**分析**:博主觉得在项目中使用redis，主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。\n\n**回答**:如下所示，分为两点\n\n**（一）性能** 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够**迅速响应**。\n\n![Redis常见面试题 - 第3张  | 张嘎](https://i0.wp.com/pic4.zhimg.com/80/v2-8200a2192b95b1596dc8d02c71b9abcf_hd.jpg?w=640&ssl=1)\n\n**题外话：**忽然想聊一下这个**迅速响应**的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在**瞬间**解决，对于页内操作则需要在**刹那**间解决。另外，超过**一弹指**的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。” 那么**瞬间、刹那、一弹指**具体是多少时间呢？ 根据《摩诃僧祗律》记载\n\n```\n一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。\n```\n\n那么，经过周密的计算，一**瞬间**为0.36 秒,一**刹那**有 0.018 秒.一**弹指**长达 7.2 秒。\n\n**（二）并发** 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。\n\n![Redis常见面试题 - 第4张  | 张嘎](https://i2.wp.com/pic3.zhimg.com/80/v2-ee0f4577491f13d82e185e7ef6aa8eae_hd.jpg?w=640&ssl=1)\n\n## 2、使用redis有什么缺点\n\n**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。\n\n**回答**:主要是四个问题\n\n- (一)缓存和数据库双写一致性问题\n- (二)缓存雪崩问题\n- (三)缓存击穿问题\n- (四)缓存的并发竞争问题\n\n这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。\n\n## 3、单线程的redis为什么这么快\n\n**分析**:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。\n\n**回答**:主要是以下三点 (一)纯内存操作 (二)单线程操作，避免了频繁的上下文切换 (三)采用了非阻塞**I/O多路复用机制**\n\n**题外话：**我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了**一批**快递员，然后小曲发现资金不够了，只够买**一辆**车送快递。\n\n**经营方式一** 客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题 – 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递 – 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了 – 快递员之间的协调很花时间\n\n综合上述缺点，小曲痛定思痛，提出了下面的经营方式\n\n**经营方式二** 小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按**送达地点**标注好，然后**依次**放在一个地方。最后，那个快递员**依次**的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。\n\n**对比** 上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。\n\n在上述比喻中:\n\n- 每个快递员——————>每个线程\n- 每个快递——————–>每个socket(I/O流)\n- 快递的送达地点————–>socket的不同状态\n- 客户送快递请求————–>来自客户端的请求\n- 小曲的经营方式————–>服务端运行的代码\n- 一辆车———————->CPU的核数\n\n于是我们有如下结论\n\n1. 经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。\n2. 经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。\n\n下面类比到真实的redis线程模型，如图所示\n\n![Redis常见面试题 - 第5张  | 张嘎](https://i0.wp.com/pic1.zhimg.com/80/v2-fa81e4bb9560b8ac6470bfa322f36a98_hd.jpg?w=640&ssl=1)\n\n参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。\n\n## 5、redis的过期策略以及内存淘汰机制\n\n**分析**:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?\n\n**回答**: redis采用的是定期删除+惰性删除策略。\n\n**为什么不用定时删除策略?** 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.\n\n**定期删除+惰性删除是如何工作的呢?**\n\n定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。\n\n**采用定期删除+惰性删除就没其他问题了么?**\n\n不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**。 在redis.conf中有一行配置\n\n```\n# maxmemory-policy volatile-lru\n```\n\n该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)\n\n1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**\n\n2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**\n\n3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**\n\n4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**\n\n5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐** 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐** ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。\n\n## 6、redis和数据库双写一致性问题\n\n**分析**:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是**如果对数据有强一致性要求，不能放缓存。**我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说**降低不一致发生的概率**，无法完全避免。因此，有强一致性要求的数据，不能放缓存。\n\n**回答**:[《分布式之数据库和缓存双写一致性方案解析》](http://link.zhihu.com/?target=https%3A//www.cnblogs.com/rjzheng/p/9041659.html)给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。\n\n## 7、如何应对缓存穿透和缓存雪崩问题\n\n**分析**:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。\n\n**回答**:如下所示\n\n**缓存穿透**，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。\n\n**解决方案**: (一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 (二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作。 (三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。\n\n**缓存雪崩**，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。\n\n**解决方案**: (一)给缓存的失效时间，加上一个随机值，避免集体失效。 (二)使用互斥锁，但是该方案吞吐量明显下降了。 (三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 – I 从缓存A读数据库，有则直接返回 – II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 – III 更新线程同时更新缓存A和缓存B。\n\n## 8、如何解决redis的并发竞争key问题\n\n**分析**:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主**不推荐使用redis的事务机制。**因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，**redis的事务机制，十分鸡肋。**\n\n**回答:**如下所示\n\n(1)如果对这个key操作，**不要求顺序** 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。\n\n(2)如果对这个key操作，**要求顺序** 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA–>valueB–>valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下\n\n```\n系统A key 1 {valueA  3:00}\n系统B key 1 {valueB  3:05}\n系统C key 1 {valueC  3:10}\n```\n\n那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。\n\n其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。\n\n\n\n# [【原创】分布式之数据库和缓存双写一致性方案解析](https://www.cnblogs.com/rjzheng/p/9041659.html)\n\n## 引言\n\n### 为什么写这篇文章？\n\n![Redis常见面试题 - 第6张  | 张嘎](https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_getkeyflow.png?w=640&ssl=1)\n\n首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。\n\n但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。\n\n### 文章结构\n\n本文由以下三个部分组成\n1、讲解缓存更新策略\n2、对每种策略进行缺点分析\n3、针对缺点给出改进方案\n\n## 正文\n\n先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。\n在这里，我们讨论**三种**更新策略：\n\n1. 先更新数据库，再更新缓存\n2. 先删除缓存，再更新数据库\n3. 先更新数据库，再删除缓存\n\n应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。\n\n### (1)先更新数据库，再更新缓存\n\n这套方案，大家是普遍反对的。为什么呢？有如下两点原因。\n**原因一（线程安全角度）**\n同时有请求A和请求B进行更新操作，那么会出现\n（1）线程A更新了数据库\n（2）线程B更新了数据库\n（3）线程B更新了缓存\n（4）线程A更新了缓存\n这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n**原因二（业务场景角度）**\n有如下两点：\n（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n\n接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。\n\n### (2)先删缓存，再更新数据库\n\n该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n（1）请求A进行写操作，删除缓存\n（2）请求B查询发现缓存不存在\n（3）请求B去数据库查询得到旧值\n（4）请求B将旧值写入缓存\n（5）请求A将新值写入数据库\n上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n那么，**如何解决呢？采用延时双删策略**\n伪代码如下\n\n```\npublic void write(String key,Object data){\n        redis.delKey(key);\n        db.updateData(data);\n        Thread.sleep(1000);\n        redis.delKey(key);\n    }\n```\n\n转化为中文描述就是\n（1）先淘汰缓存\n（2）再写数据库（这两步和原来一样）\n（3）休眠1秒，再次淘汰缓存\n这么做，可以将1秒内所造成的缓存脏数据，再次删除。\n**那么，这个1秒怎么确定的，具体该休眠多久呢？**\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n**如果你用了mysql的读写分离架构怎么办？**\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n（1）请求A进行写操作，删除缓存\n（2）请求A将数据写入数据库了，\n（3）请求B查询缓存发现，缓存没有值\n（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n（5）请求B将旧值写入缓存\n（6）数据库完成主从同步，从库变为新值\n上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n**采用这种同步淘汰策略，吞吐量降低怎么办？**\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n**第二次删除,如果删除失败怎么办？**\n这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：\n（1）请求A进行写操作，删除缓存\n（2）请求B查询发现缓存不存在\n（3）请求B去数据库查询得到旧值\n（4）请求B将旧值写入缓存\n（5）请求A将新值写入数据库\n（6）请求A试图去删除请求B写入对缓存值，结果失败了。\nok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。\n**如何解决呢？**\n具体解决方案，且看博主对第(3)种更新策略的解析。\n\n### (3)先更新数据库，再删缓存\n\n首先，先说一下。老外提出了一个缓存更新套路，名为[《Cache-Aside pattern》](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)。其中就指出\n\n- **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。\n- **命中**：应用程序从cache中取数据，取到后返回。\n- **更新**：先把数据存到数据库中，成功后，再让缓存失效。\n\n![Redis常见面试题 - 第7张  | 张嘎](https://i2.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png?w=640&ssl=1)\n\n![Redis常见面试题 - 第8张  | 张嘎](https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png?w=640&ssl=1)\n\n另外，知名社交网站facebook也在论文[《Scaling Memcache at Facebook》](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)中提出，他们用的也是先更新数据库，再删缓存的策略。\n**这种情况不存在并发问题么？**\n不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n（1）缓存刚好失效\n（2）请求A查询数据库，得一个旧值\n（3）请求B将新值写入数据库\n（4）请求B删除缓存\n（5）请求A将查到的旧值写入缓存\nok，如果发生上述情况，确实是会发生脏数据。\n**然而，发生这种情况的概率又有多少呢？**\n发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n假设，有人非要抬杠，有强迫症，一定要解决怎么办？\n**如何解决上述并发问题？**\n首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。\n**还有其他造成不一致的原因么？**\n有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。\n**如何解决？**\n提供一个保障的重试机制即可，这里给出两套方案。\n**方案一**：\n如下图所示\n\n流程如下所示\n（1）更新数据库数据；\n（2）缓存因为种种问题删除失败\n（3）将需要删除的key发送至消息队列\n（4）自己消费消息，获得需要删除的key\n（5）继续重试删除操作，直到成功\n然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。\n**方案二**：\n\n流程如下图所示：\n（1）更新数据库数据\n（2）数据库会将操作信息写入binlog日志当中\n（3）订阅程序提取出所需要的数据以及key\n（4）另起一段非业务代码，获得该信息\n（5）尝试删除缓存操作，发现删除失败\n（6）将这些信息发送至消息队列\n（7）重新从消息队列中获得该数据，重试操作。\n\n**备注说明：**上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。\n\n## 总结\n\n本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。\n\n## 参考文献\n\n1、[主从DB与cache一致性](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect)\n2、[缓存更新的套路](https://coolshell.cn/articles/17416.html)\n","slug":"redis-pre","published":1,"updated":"2021-09-01T11:53:38.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lkc001lhcmn1cpke6y4","content":"<p>和Redis结缘还是2011年刚开始实习，做的第一款游戏《部落战争》，<br>就是使用的Redis作为持久层和缓存。 当时对Redis的认识还比较浅，但是Redis的好多特性已经开始慢慢了解。</p>\n<p>这里推荐一下大神的Redis公众号。付磊。快手同事，《Redis开发与运维》一书的作者，强烈推荐这本书，偏向实战，另外一本很有名的书《Redis设计与实现》更注重原理。两本书都非常值得好好读下。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4-576x1024.jpg?resize=640,1138\" alt=\"Redis常见面试题 - 第1张  | 张嘎\"></p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-576x1024.jpg?resize=576,1024\" alt=\"Redis常见面试题 - 第2张  | 张嘎\"></p>\n<h4 id=\"Memcached相比于Redis的主要特点有如下：\"><a href=\"#Memcached相比于Redis的主要特点有如下：\" class=\"headerlink\" title=\"Memcached相比于Redis的主要特点有如下：\"></a>Memcached相比于Redis的主要特点有如下：</h4><p>\\1. 超高OPS：例如千万级别以上（线上千万OPS以上的Redis也存在）<br>\\2. 多线程：抗热点能力强。<br>\\3. 支持大value：例如Memcached 5支持100MB以上的value</p>\n<p>但Memcached相比于Redis维护成本会更高，而且对于很多基础设施支持也不好（双机房、键值分析、内存优化、服务端高可用）。</p>\n<p>最近发现KCC上出现Memcached滥用的情况</p>\n<p>为防止滥用，必须满足如下规则才会开通：</p>\n<p>\\1. OPS: 超过100万<br>\\2. big value：10MB+<br>\\3. 明显热点<br>\\4. CAS需求</p>\n<p><strong>一、Redis常见的数据结构和使用场景</strong></p>\n<p>(一)String 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></p>\n<p>(二)hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>\n<p>(三)list 使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p>\n<p>(四)set 因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p>\n<p>(五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。另外，参照另一篇<a href=\"http://link.zhihu.com/?target=https://www.cnblogs.com/rjzheng/p/8972725.html\">《分布式之延时任务方案解析》</a>，该文指出了sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p>\n<p><strong>二、Redis的hash怎么实现的</strong><br>满足以下两条件时：<br>1、键和值的长度都小于64字节<br>2、键值对数量小于512个<br>使用ziplist编码。不满足时转化为hashtable编码，并且这个转化过程是不可逆的。<br>hashtable的实现方式和Java的hashmap类似，数组上散列，散列冲突的使用链表，不同的是redis采用渐进式的rehash策略。<br>何为<strong>渐进式rehash</strong>？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。维护两张哈希表，1个索引来指示当前的rehash进度。<br>rehash是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。<br><strong>Java HashMap</strong>的rehash，每次创建一个数组（哈希表），一次性将old表rehash过去。</p>\n<p><strong>三、为什么不能用Redis做专门的持久化</strong><br>性价比：内存吃紧 ，海量数据在重启后加载耗时。RDB加载快。<br>权限控制。<br>数据完整：MySQL 在崩溃处理，数据恢复方面比reids好。<br>redis作为数据库查询功能太弱。数据KV弱于结构化。<br>数据隔离。</p>\n<h1 id=\"Redis-Cluster-功能限制\"><a href=\"#Redis-Cluster-功能限制\" class=\"headerlink\" title=\"Redis Cluster|功能限制\"></a>Redis Cluster|功能限制</h1><p>1.Key批量操作支持有限。目前只支持同slot内的key执行批量操作（如mget,mset）。</p>\n<p>2.Key事务操作支持有限。只支持多key在同一个节点上的事务操作，多个key分布在不同节点上时无法使用事务功能。</p>\n<p>3.Key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash，list等映射到不同节点。</p>\n<p>4.不支持多数据库空间，集群模式下只能使用db0空间。</p>\n<p>5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>\n<h1 id=\"Redis-Cluster高可用\"><a href=\"#Redis-Cluster高可用\" class=\"headerlink\" title=\"Redis Cluster高可用\"></a>Redis Cluster高可用</h1><p>提供了灵活的节点扩容和收缩方案，在不影响集群对外服务的情况下进行。<br>自动故障转移保证集群可以正常对外提供服务。主观下线，客观下线，投票选举策略。选出从节点替换主节点，保证集群高可用。</p>\n<p><strong>下面是两篇引用的文章。<a href=\"https://zhuanlan.zhihu.com/p/59168140\">https://zhuanlan.zhihu.com/p/59168140</a></strong></p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h2 id=\"为什么写这篇文章\"><a href=\"#为什么写这篇文章\" class=\"headerlink\" title=\"为什么写这篇文章?\"></a>为什么写这篇文章?</h2><p>博主的<a href=\"http://link.zhihu.com/?target=http://www.cnblogs.com/rjzheng/p/8994962.html\">《分布式之消息队列复习精讲》</a>得到了大家的好评，内心诚惶诚恐，想着再出一篇关于复习精讲的文章。但是还是要说明一下，复习精讲的文章偏面试准备，真正在开发过程中，还是脚踏实地，一步一个脚印，不要投机取巧。 考虑到绝大部分写业务的程序员，在实际开发中使用redis的时候，只会setvalue和getvalue两个操作，对redis整体缺乏一个认知。又恰逢博主某个同事下周要去培训redis，所以博主斗胆以redis为题材，对redis常见问题做一个总结，希望能够弥补大家的知识盲点。</p>\n<h2 id=\"复习要点\"><a href=\"#复习要点\" class=\"headerlink\" title=\"复习要点?\"></a>复习要点?</h2><p>本文围绕以下几点进行阐述</p>\n<ul>\n<li>1、为什么使用redis</li>\n<li>2、使用redis有什么缺点</li>\n<li>3、单线程的redis为什么这么快</li>\n<li>4、redis的数据类型，以及每种数据类型的使用场景</li>\n<li>5、redis的过期策略以及内存淘汰机制</li>\n<li>6、redis和数据库双写一致性问题</li>\n<li>7、如何应对缓存穿透和缓存雪崩问题</li>\n<li>8、如何解决redis的并发竞争问题</li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h2 id=\"1、为什么使用redis\"><a href=\"#1、为什么使用redis\" class=\"headerlink\" title=\"1、为什么使用redis\"></a>1、为什么使用redis</h2><p><strong>分析</strong>:博主觉得在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p>\n<p><strong>回答</strong>:如下所示，分为两点</p>\n<p><strong>（一）性能</strong> 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。</p>\n<p><img src=\"https://i0.wp.com/pic4.zhimg.com/80/v2-8200a2192b95b1596dc8d02c71b9abcf_hd.jpg?w=640&ssl=1\" alt=\"Redis常见面试题 - 第3张  | 张嘎\"></p>\n<p><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。” 那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？ 根据《摩诃僧祗律》记载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure>\n\n<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>\n<p><strong>（二）并发</strong> 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>\n<p><img src=\"https://i2.wp.com/pic3.zhimg.com/80/v2-ee0f4577491f13d82e185e7ef6aa8eae_hd.jpg?w=640&ssl=1\" alt=\"Redis常见面试题 - 第4张  | 张嘎\"></p>\n<h2 id=\"2、使用redis有什么缺点\"><a href=\"#2、使用redis有什么缺点\" class=\"headerlink\" title=\"2、使用redis有什么缺点\"></a>2、使用redis有什么缺点</h2><p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>\n<p><strong>回答</strong>:主要是四个问题</p>\n<ul>\n<li>(一)缓存和数据库双写一致性问题</li>\n<li>(二)缓存雪崩问题</li>\n<li>(三)缓存击穿问题</li>\n<li>(四)缓存的并发竞争问题</li>\n</ul>\n<p>这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>\n<h2 id=\"3、单线程的redis为什么这么快\"><a href=\"#3、单线程的redis为什么这么快\" class=\"headerlink\" title=\"3、单线程的redis为什么这么快\"></a>3、单线程的redis为什么这么快</h2><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</p>\n<p><strong>回答</strong>:主要是以下三点 (一)纯内存操作 (二)单线程操作，避免了频繁的上下文切换 (三)采用了非阻塞<strong>I/O多路复用机制</strong></p>\n<p><strong>题外话：</strong>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。</p>\n<p><strong>经营方式一</strong> 客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题 – 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递 – 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了 – 快递员之间的协调很花时间</p>\n<p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</p>\n<p><strong>经营方式二</strong> 小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>\n<p><strong>对比</strong> 上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。</p>\n<p>在上述比喻中:</p>\n<ul>\n<li>每个快递员——————&gt;每个线程</li>\n<li>每个快递——————–&gt;每个socket(I/O流)</li>\n<li>快递的送达地点————–&gt;socket的不同状态</li>\n<li>客户送快递请求————–&gt;来自客户端的请求</li>\n<li>小曲的经营方式————–&gt;服务端运行的代码</li>\n<li>一辆车———————-&gt;CPU的核数</li>\n</ul>\n<p>于是我们有如下结论</p>\n<ol>\n<li>经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。</li>\n<li>经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</li>\n</ol>\n<p>下面类比到真实的redis线程模型，如图所示</p>\n<p><img src=\"https://i0.wp.com/pic1.zhimg.com/80/v2-fa81e4bb9560b8ac6470bfa322f36a98_hd.jpg?w=640&ssl=1\" alt=\"Redis常见面试题 - 第5张  | 张嘎\"></p>\n<p>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>\n<h2 id=\"5、redis的过期策略以及内存淘汰机制\"><a href=\"#5、redis的过期策略以及内存淘汰机制\" class=\"headerlink\" title=\"5、redis的过期策略以及内存淘汰机制\"></a>5、redis的过期策略以及内存淘汰机制</h2><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>\n<p><strong>回答</strong>: redis采用的是定期删除+惰性删除策略。</p>\n<p><strong>为什么不用定时删除策略?</strong> 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>\n<p><strong>定期删除+惰性删除是如何工作的呢?</strong></p>\n<p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>\n<p><strong>采用定期删除+惰性删除就没其他问题了么?</strong></p>\n<p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。 在redis.conf中有一行配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>\n\n<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p>\n<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong></p>\n<p>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong></p>\n<p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong></p>\n<p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong></p>\n<p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong> 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong> ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>\n<h2 id=\"6、redis和数据库双写一致性问题\"><a href=\"#6、redis和数据库双写一致性问题\" class=\"headerlink\" title=\"6、redis和数据库双写一致性问题\"></a>6、redis和数据库双写一致性问题</h2><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>\n<p><strong>回答</strong>:<a href=\"http://link.zhihu.com/?target=https://www.cnblogs.com/rjzheng/p/9041659.html\">《分布式之数据库和缓存双写一致性方案解析》</a>给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>\n<h2 id=\"7、如何应对缓存穿透和缓存雪崩问题\"><a href=\"#7、如何应对缓存穿透和缓存雪崩问题\" class=\"headerlink\" title=\"7、如何应对缓存穿透和缓存雪崩问题\"></a>7、如何应对缓存穿透和缓存雪崩问题</h2><p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>\n<p><strong>回答</strong>:如下所示</p>\n<p><strong>缓存穿透</strong>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>\n<p><strong>解决方案</strong>: (一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 (二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。 (三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>\n<p><strong>缓存雪崩</strong>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>\n<p><strong>解决方案</strong>: (一)给缓存的失效时间，加上一个随机值，避免集体失效。 (二)使用互斥锁，但是该方案吞吐量明显下降了。 (三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 – I 从缓存A读数据库，有则直接返回 – II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 – III 更新线程同时更新缓存A和缓存B。</p>\n<h2 id=\"8、如何解决redis的并发竞争key问题\"><a href=\"#8、如何解决redis的并发竞争key问题\" class=\"headerlink\" title=\"8、如何解决redis的并发竞争key问题\"></a>8、如何解决redis的并发竞争key问题</h2><p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p>\n<p>**回答:**如下所示</p>\n<p>(1)如果对这个key操作，<strong>不要求顺序</strong> 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</p>\n<p>(2)如果对这个key操作，<strong>要求顺序</strong> 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class=\"line\">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class=\"line\">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>\n<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>\n<h1 id=\"【原创】分布式之数据库和缓存双写一致性方案解析\"><a href=\"#【原创】分布式之数据库和缓存双写一致性方案解析\" class=\"headerlink\" title=\"【原创】分布式之数据库和缓存双写一致性方案解析\"></a><a href=\"https://www.cnblogs.com/rjzheng/p/9041659.html\">【原创】分布式之数据库和缓存双写一致性方案解析</a></h1><h2 id=\"引言-1\"><a href=\"#引言-1\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"为什么写这篇文章？\"><a href=\"#为什么写这篇文章？\" class=\"headerlink\" title=\"为什么写这篇文章？\"></a>为什么写这篇文章？</h3><p><img src=\"https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_getkeyflow.png?w=640&ssl=1\" alt=\"Redis常见面试题 - 第6张  | 张嘎\"></p>\n<p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>\n<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。</p>\n<h3 id=\"文章结构\"><a href=\"#文章结构\" class=\"headerlink\" title=\"文章结构\"></a>文章结构</h3><p>本文由以下三个部分组成<br>1、讲解缓存更新策略<br>2、对每种策略进行缺点分析<br>3、针对缺点给出改进方案</p>\n<h2 id=\"正文-1\"><a href=\"#正文-1\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p>\n<ol>\n<li>先更新数据库，再更新缓存</li>\n<li>先删除缓存，再更新数据库</li>\n<li>先更新数据库，再删除缓存</li>\n</ol>\n<p>应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。</p>\n<h3 id=\"1-先更新数据库，再更新缓存\"><a href=\"#1-先更新数据库，再更新缓存\" class=\"headerlink\" title=\"(1)先更新数据库，再更新缓存\"></a>(1)先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>\n<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>\n<h3 id=\"2-先删缓存，再更新数据库\"><a href=\"#2-先删缓存，再更新数据库\" class=\"headerlink\" title=\"(2)先删缓存，再更新数据库\"></a>(2)先删缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong><br>伪代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void write(String key,Object data)&#123;</span><br><span class=\"line\">        redis.delKey(key);</span><br><span class=\"line\">        db.updateData(data);</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">        redis.delKey(key);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>转化为中文描述就是<br>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除请求B写入对缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong><br>具体解决方案，且看博主对第(3)种更新策略的解析。</p>\n<h3 id=\"3-先更新数据库，再删缓存\"><a href=\"#3-先更新数据库，再删缓存\" class=\"headerlink\" title=\"(3)先更新数据库，再删缓存\"></a>(3)先更新数据库，再删缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside\">《Cache-Aside pattern》</a>。其中就指出</p>\n<ul>\n<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>\n<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>\n<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>\n</ul>\n<p><img src=\"https://i2.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png?w=640&ssl=1\" alt=\"Redis常见面试题 - 第7张  | 张嘎\"></p>\n<p><img src=\"https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png?w=640&ssl=1\" alt=\"Redis常见面试题 - 第8张  | 张嘎\"></p>\n<p>另外，知名社交网站facebook也在论文<a href=\"https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf\">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。<br><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br><strong>然而，发生这种情况的概率又有多少呢？</strong><br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？<br><strong>如何解决上述并发问题？</strong><br>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。<br><strong>如何解决？</strong><br>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一</strong>：<br>如下图所示</p>\n<p>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功<br>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。<br><strong>方案二</strong>：</p>\n<p>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p>\n<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>1、<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect\">主从DB与cache一致性</a><br>2、<a href=\"https://coolshell.cn/articles/17416.html\">缓存更新的套路</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>和Redis结缘还是2011年刚开始实习，做的第一款游戏《部落战争》，<br>就是使用的Redis作为持久层和缓存。 当时对Redis的认识还比较浅，但是Redis的好多特性已经开始慢慢了解。</p>\n<p>这里推荐一下大神的Redis公众号。付磊。快手同事，《Redis开发与运维》一书的作者，强烈推荐这本书，偏向实战，另外一本很有名的书《Redis设计与实现》更注重原理。两本书都非常值得好好读下。</p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/4-576x1024.jpg?resize=640,1138\" alt=\"Redis常见面试题 - 第1张  | 张嘎\"></p>\n<p><img src=\"https://i2.wp.com/192.144.167.243/blog/wp-content/uploads/3-1-576x1024.jpg?resize=576,1024\" alt=\"Redis常见面试题 - 第2张  | 张嘎\"></p>\n<h4 id=\"Memcached相比于Redis的主要特点有如下：\"><a href=\"#Memcached相比于Redis的主要特点有如下：\" class=\"headerlink\" title=\"Memcached相比于Redis的主要特点有如下：\"></a>Memcached相比于Redis的主要特点有如下：</h4><p>\\1. 超高OPS：例如千万级别以上（线上千万OPS以上的Redis也存在）<br>\\2. 多线程：抗热点能力强。<br>\\3. 支持大value：例如Memcached 5支持100MB以上的value</p>\n<p>但Memcached相比于Redis维护成本会更高，而且对于很多基础设施支持也不好（双机房、键值分析、内存优化、服务端高可用）。</p>\n<p>最近发现KCC上出现Memcached滥用的情况</p>\n<p>为防止滥用，必须满足如下规则才会开通：</p>\n<p>\\1. OPS: 超过100万<br>\\2. big value：10MB+<br>\\3. 明显热点<br>\\4. CAS需求</p>\n<p><strong>一、Redis常见的数据结构和使用场景</strong></p>\n<p>(一)String 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<strong>一些复杂的计数功能的缓存。</strong></p>\n<p>(二)hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<strong>单点登录</strong>的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>\n<p>(三)list 使用List的数据结构，可以<strong>做简单的消息队列的功能</strong>。另外还有一个就是，可以利用lrange命令，<strong>做基于redis的分页功能</strong>，性能极佳，用户体验好。</p>\n<p>(四)set 因为set堆放的是一堆不重复值的集合。所以可以做<strong>全局去重的功能</strong>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以<strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong>。</p>\n<p>(五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<strong>排行榜应用，取TOP N操作</strong>。另外，参照另一篇<a href=\"http://link.zhihu.com/?target=https://www.cnblogs.com/rjzheng/p/8972725.html\">《分布式之延时任务方案解析》</a>，该文指出了sorted set可以用来做<strong>延时任务</strong>。最后一个应用就是可以做<strong>范围查找</strong>。</p>\n<p><strong>二、Redis的hash怎么实现的</strong><br>满足以下两条件时：<br>1、键和值的长度都小于64字节<br>2、键值对数量小于512个<br>使用ziplist编码。不满足时转化为hashtable编码，并且这个转化过程是不可逆的。<br>hashtable的实现方式和Java的hashmap类似，数组上散列，散列冲突的使用链表，不同的是redis采用渐进式的rehash策略。<br>何为<strong>渐进式rehash</strong>？就是把拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。维护两张哈希表，1个索引来指示当前的rehash进度。<br>rehash是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。<br><strong>Java HashMap</strong>的rehash，每次创建一个数组（哈希表），一次性将old表rehash过去。</p>\n<p><strong>三、为什么不能用Redis做专门的持久化</strong><br>性价比：内存吃紧 ，海量数据在重启后加载耗时。RDB加载快。<br>权限控制。<br>数据完整：MySQL 在崩溃处理，数据恢复方面比reids好。<br>redis作为数据库查询功能太弱。数据KV弱于结构化。<br>数据隔离。</p>\n<h1 id=\"Redis-Cluster-功能限制\"><a href=\"#Redis-Cluster-功能限制\" class=\"headerlink\" title=\"Redis Cluster|功能限制\"></a>Redis Cluster|功能限制</h1><p>1.Key批量操作支持有限。目前只支持同slot内的key执行批量操作（如mget,mset）。</p>\n<p>2.Key事务操作支持有限。只支持多key在同一个节点上的事务操作，多个key分布在不同节点上时无法使用事务功能。</p>\n<p>3.Key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash，list等映射到不同节点。</p>\n<p>4.不支持多数据库空间，集群模式下只能使用db0空间。</p>\n<p>5.复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>\n<h1 id=\"Redis-Cluster高可用\"><a href=\"#Redis-Cluster高可用\" class=\"headerlink\" title=\"Redis Cluster高可用\"></a>Redis Cluster高可用</h1><p>提供了灵活的节点扩容和收缩方案，在不影响集群对外服务的情况下进行。<br>自动故障转移保证集群可以正常对外提供服务。主观下线，客观下线，投票选举策略。选出从节点替换主节点，保证集群高可用。</p>\n<p><strong>下面是两篇引用的文章。<a href=\"https://zhuanlan.zhihu.com/p/59168140\">https://zhuanlan.zhihu.com/p/59168140</a></strong></p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h2 id=\"为什么写这篇文章\"><a href=\"#为什么写这篇文章\" class=\"headerlink\" title=\"为什么写这篇文章?\"></a>为什么写这篇文章?</h2><p>博主的<a href=\"http://link.zhihu.com/?target=http://www.cnblogs.com/rjzheng/p/8994962.html\">《分布式之消息队列复习精讲》</a>得到了大家的好评，内心诚惶诚恐，想着再出一篇关于复习精讲的文章。但是还是要说明一下，复习精讲的文章偏面试准备，真正在开发过程中，还是脚踏实地，一步一个脚印，不要投机取巧。 考虑到绝大部分写业务的程序员，在实际开发中使用redis的时候，只会setvalue和getvalue两个操作，对redis整体缺乏一个认知。又恰逢博主某个同事下周要去培训redis，所以博主斗胆以redis为题材，对redis常见问题做一个总结，希望能够弥补大家的知识盲点。</p>\n<h2 id=\"复习要点\"><a href=\"#复习要点\" class=\"headerlink\" title=\"复习要点?\"></a>复习要点?</h2><p>本文围绕以下几点进行阐述</p>\n<ul>\n<li>1、为什么使用redis</li>\n<li>2、使用redis有什么缺点</li>\n<li>3、单线程的redis为什么这么快</li>\n<li>4、redis的数据类型，以及每种数据类型的使用场景</li>\n<li>5、redis的过期策略以及内存淘汰机制</li>\n<li>6、redis和数据库双写一致性问题</li>\n<li>7、如何应对缓存穿透和缓存雪崩问题</li>\n<li>8、如何解决redis的并发竞争问题</li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h2 id=\"1、为什么使用redis\"><a href=\"#1、为什么使用redis\" class=\"headerlink\" title=\"1、为什么使用redis\"></a>1、为什么使用redis</h2><p><strong>分析</strong>:博主觉得在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p>\n<p><strong>回答</strong>:如下所示，分为两点</p>\n<p><strong>（一）性能</strong> 如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。</p>\n<p><img src=\"https://i0.wp.com/pic4.zhimg.com/80/v2-8200a2192b95b1596dc8d02c71b9abcf_hd.jpg?w=640&ssl=1\" alt=\"Redis常见面试题 - 第3张  | 张嘎\"></p>\n<p><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。” 那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？ 根据《摩诃僧祗律》记载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure>\n\n<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>\n<p><strong>（二）并发</strong> 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>\n<p><img src=\"https://i2.wp.com/pic3.zhimg.com/80/v2-ee0f4577491f13d82e185e7ef6aa8eae_hd.jpg?w=640&ssl=1\" alt=\"Redis常见面试题 - 第4张  | 张嘎\"></p>\n<h2 id=\"2、使用redis有什么缺点\"><a href=\"#2、使用redis有什么缺点\" class=\"headerlink\" title=\"2、使用redis有什么缺点\"></a>2、使用redis有什么缺点</h2><p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>\n<p><strong>回答</strong>:主要是四个问题</p>\n<ul>\n<li>(一)缓存和数据库双写一致性问题</li>\n<li>(二)缓存雪崩问题</li>\n<li>(三)缓存击穿问题</li>\n<li>(四)缓存的并发竞争问题</li>\n</ul>\n<p>这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>\n<h2 id=\"3、单线程的redis为什么这么快\"><a href=\"#3、单线程的redis为什么这么快\" class=\"headerlink\" title=\"3、单线程的redis为什么这么快\"></a>3、单线程的redis为什么这么快</h2><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</p>\n<p><strong>回答</strong>:主要是以下三点 (一)纯内存操作 (二)单线程操作，避免了频繁的上下文切换 (三)采用了非阻塞<strong>I/O多路复用机制</strong></p>\n<p><strong>题外话：</strong>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。</p>\n<p><strong>经营方式一</strong> 客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题 – 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递 – 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了 – 快递员之间的协调很花时间</p>\n<p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</p>\n<p><strong>经营方式二</strong> 小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>\n<p><strong>对比</strong> 上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。</p>\n<p>在上述比喻中:</p>\n<ul>\n<li>每个快递员——————&gt;每个线程</li>\n<li>每个快递——————–&gt;每个socket(I/O流)</li>\n<li>快递的送达地点————–&gt;socket的不同状态</li>\n<li>客户送快递请求————–&gt;来自客户端的请求</li>\n<li>小曲的经营方式————–&gt;服务端运行的代码</li>\n<li>一辆车———————-&gt;CPU的核数</li>\n</ul>\n<p>于是我们有如下结论</p>\n<ol>\n<li>经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。</li>\n<li>经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</li>\n</ol>\n<p>下面类比到真实的redis线程模型，如图所示</p>\n<p><img src=\"https://i0.wp.com/pic1.zhimg.com/80/v2-fa81e4bb9560b8ac6470bfa322f36a98_hd.jpg?w=640&ssl=1\" alt=\"Redis常见面试题 - 第5张  | 张嘎\"></p>\n<p>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>\n<h2 id=\"5、redis的过期策略以及内存淘汰机制\"><a href=\"#5、redis的过期策略以及内存淘汰机制\" class=\"headerlink\" title=\"5、redis的过期策略以及内存淘汰机制\"></a>5、redis的过期策略以及内存淘汰机制</h2><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>\n<p><strong>回答</strong>: redis采用的是定期删除+惰性删除策略。</p>\n<p><strong>为什么不用定时删除策略?</strong> 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>\n<p><strong>定期删除+惰性删除是如何工作的呢?</strong></p>\n<p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>\n<p><strong>采用定期删除+惰性删除就没其他问题了么?</strong></p>\n<p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。 在redis.conf中有一行配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>\n\n<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p>\n<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong></p>\n<p>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong></p>\n<p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong></p>\n<p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong></p>\n<p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong> 6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong> ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>\n<h2 id=\"6、redis和数据库双写一致性问题\"><a href=\"#6、redis和数据库双写一致性问题\" class=\"headerlink\" title=\"6、redis和数据库双写一致性问题\"></a>6、redis和数据库双写一致性问题</h2><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是<strong>如果对数据有强一致性要求，不能放缓存。</strong>我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说<strong>降低不一致发生的概率</strong>，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>\n<p><strong>回答</strong>:<a href=\"http://link.zhihu.com/?target=https://www.cnblogs.com/rjzheng/p/9041659.html\">《分布式之数据库和缓存双写一致性方案解析》</a>给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>\n<h2 id=\"7、如何应对缓存穿透和缓存雪崩问题\"><a href=\"#7、如何应对缓存穿透和缓存雪崩问题\" class=\"headerlink\" title=\"7、如何应对缓存穿透和缓存雪崩问题\"></a>7、如何应对缓存穿透和缓存雪崩问题</h2><p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>\n<p><strong>回答</strong>:如下所示</p>\n<p><strong>缓存穿透</strong>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>\n<p><strong>解决方案</strong>: (一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试 (二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。 (三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>\n<p><strong>缓存雪崩</strong>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>\n<p><strong>解决方案</strong>: (一)给缓存的失效时间，加上一个随机值，避免集体失效。 (二)使用互斥锁，但是该方案吞吐量明显下降了。 (三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 – I 从缓存A读数据库，有则直接返回 – II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 – III 更新线程同时更新缓存A和缓存B。</p>\n<h2 id=\"8、如何解决redis的并发竞争key问题\"><a href=\"#8、如何解决redis的并发竞争key问题\" class=\"headerlink\" title=\"8、如何解决redis的并发竞争key问题\"></a>8、如何解决redis的并发竞争key问题</h2><p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong></p>\n<p>**回答:**如下所示</p>\n<p>(1)如果对这个key操作，<strong>不要求顺序</strong> 这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</p>\n<p>(2)如果对这个key操作，<strong>要求顺序</strong> 假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC. 期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class=\"line\">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class=\"line\">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>\n<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>\n<h1 id=\"【原创】分布式之数据库和缓存双写一致性方案解析\"><a href=\"#【原创】分布式之数据库和缓存双写一致性方案解析\" class=\"headerlink\" title=\"【原创】分布式之数据库和缓存双写一致性方案解析\"></a><a href=\"https://www.cnblogs.com/rjzheng/p/9041659.html\">【原创】分布式之数据库和缓存双写一致性方案解析</a></h1><h2 id=\"引言-1\"><a href=\"#引言-1\" class=\"headerlink\" title=\"引言\"></a>引言</h2><h3 id=\"为什么写这篇文章？\"><a href=\"#为什么写这篇文章？\" class=\"headerlink\" title=\"为什么写这篇文章？\"></a>为什么写这篇文章？</h3><p><img src=\"https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_getkeyflow.png?w=640&ssl=1\" alt=\"Redis常见面试题 - 第6张  | 张嘎\"></p>\n<p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>\n<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。</p>\n<h3 id=\"文章结构\"><a href=\"#文章结构\" class=\"headerlink\" title=\"文章结构\"></a>文章结构</h3><p>本文由以下三个部分组成<br>1、讲解缓存更新策略<br>2、对每种策略进行缺点分析<br>3、针对缺点给出改进方案</p>\n<h2 id=\"正文-1\"><a href=\"#正文-1\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p>\n<ol>\n<li>先更新数据库，再更新缓存</li>\n<li>先删除缓存，再更新数据库</li>\n<li>先更新数据库，再删除缓存</li>\n</ol>\n<p>应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。</p>\n<h3 id=\"1-先更新数据库，再更新缓存\"><a href=\"#1-先更新数据库，再更新缓存\" class=\"headerlink\" title=\"(1)先更新数据库，再更新缓存\"></a>(1)先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>\n<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>\n<h3 id=\"2-先删缓存，再更新数据库\"><a href=\"#2-先删缓存，再更新数据库\" class=\"headerlink\" title=\"(2)先删缓存，再更新数据库\"></a>(2)先删缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong><br>伪代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void write(String key,Object data)&#123;</span><br><span class=\"line\">        redis.delKey(key);</span><br><span class=\"line\">        db.updateData(data);</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">        redis.delKey(key);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>转化为中文描述就是<br>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除请求B写入对缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong><br>具体解决方案，且看博主对第(3)种更新策略的解析。</p>\n<h3 id=\"3-先更新数据库，再删缓存\"><a href=\"#3-先更新数据库，再删缓存\" class=\"headerlink\" title=\"(3)先更新数据库，再删缓存\"></a>(3)先更新数据库，再删缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside\">《Cache-Aside pattern》</a>。其中就指出</p>\n<ul>\n<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>\n<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>\n<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>\n</ul>\n<p><img src=\"https://i2.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png?w=640&ssl=1\" alt=\"Redis常见面试题 - 第7张  | 张嘎\"></p>\n<p><img src=\"https://i0.wp.com/images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png?w=640&ssl=1\" alt=\"Redis常见面试题 - 第8张  | 张嘎\"></p>\n<p>另外，知名社交网站facebook也在论文<a href=\"https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf\">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。<br><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br><strong>然而，发生这种情况的概率又有多少呢？</strong><br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？<br><strong>如何解决上述并发问题？</strong><br>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。<br><strong>如何解决？</strong><br>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一</strong>：<br>如下图所示</p>\n<p>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功<br>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。<br><strong>方案二</strong>：</p>\n<p>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p>\n<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>1、<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect\">主从DB与cache一致性</a><br>2、<a href=\"https://coolshell.cn/articles/17416.html\">缓存更新的套路</a></p>\n"},{"title":"服务流控方案总结","date":"2020-12-26T06:09:12.000Z","id":"limiter","_content":"\n转载自：https://developer.aliyun.com/article/765912\n\n### 一 流控的场景\n\n流控的意义其实无需多言了。最常用的场景下，流控是为了保护下游有限的资源不被流量冲垮，保证服务的可用性，一般允许流控的阈值有一定的弹性，偶尔的超量访问是可以接受的。\n\n有的时候，流控服务于收费模式，比如某些云厂商会对调用 API 的频次进行计费。既然涉及到钱，一般就不允许有超出阈值的调用量。\n\n这些不同的场景下，适用的流控算法不尽相同。大多数情况下，使用 Sentinel 中间件已经能很好地应对，但 Sentinel 也并不是万能的，需要思考其他的流控方案。\n\n<!--more-->\n\n### 二 接口定义\n\n为了方便，以下所有的示例代码实现都是基于 Throttler 接口。\n\nThrottler 接口定义了一个通用的方法用于申请单个配额。\n\n当然你也可以定义一个 tryAcquire(String key, int permits) 签名的方法用于一次申请多个配额，实现的思路是一样的。\n\n有些流控算法需要为每个 key 维护一个 Throttler 实例。\n\n```\npublic interface Throttler {\n    /**\n     * 尝试申请一个配额\n     *\n     * @param key     申请配额的key\n     * @return 申请成功则返回true，否则返回false\n     */\n    boolean tryAcquire(String key);\n}\n```\n\n### 三 单机流控\n\n#### 1 简单窗口\n\n> 简单窗口是我自己的命名，有些地方也叫做固定窗口，主要是为了跟后面的滑动窗口区分。\n\n流控是为了限制指定时间间隔内能够允许的访问量，因此，最直观的思路就是基于一个给定的时间窗口，维护一个计数器用于统计访问次数，然后实现以下规则：\n\n- 如果访问次数小于阈值，则代表允许访问，访问次数 +1。\n- 如果访问次数超出阈值，则限制访问，访问次数不增。\n- 如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。这样就确保计数器统计的是最近一个窗口的访问量。\n\n**代码实现 SimpleWindowThrottler**\n\n```\n/**\n * 毫秒为单位的时间窗口\n */\nprivate final long windowInMs;\n/**\n * 时间窗口内最大允许的阈值\n */\nprivate final int threshold;\n/**\n * 最后一次成功请求时间\n */\nprivate long lastReqTime = System.currentTimeMillis();\n/**\n * 计数器\n */\nprivate long counter;\n\npublic boolean tryAcquire(String key) {\n    long now = System.currentTimeMillis();\n    // 如果当前时间已经超过了上一次访问时间开始的时间窗口，重置计数器，以当前时间作为新窗口的起始值\n    if (now - lastReqTime > windowInMs) {       #1\n        counter = 0;\n        lastReqTime = now;                  #2\n    }\n    if (counter < threshold) {                  #3\n        counter++;                          #4\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n另外一种常见的场景是根据不同的 key 来做流控，每个 key 有单独的时间窗口、阈值配置，因此需要为每个 key 维护一个单独的限流器实例。\n\n**切换到多线程环境**\n在现实应用中，往往是多个线程来同时申请配额，为了比较简洁地表达算法思路，示例代码里面都没有做并发同步控制。\n\n以简单窗口的实现为例，要转换为多线程安全的流控算法，一种直接的办法是将 tryAcquire 方法设置为 synchronized。\n\n当然一种感觉上更高效的办法也可以是修改读写变量的类型：\n\n```\nprivate volatile long lastReqTime = System.currentTimeMillis();\nprivate LongAdder counter = new LongAdder();\n```\n\n不过这样其实并不真正“安全”，设想以下的场景，两个线程 A、线程 B 前后脚尝试获取配额，#1 位置的判断条件满足后，会同时走到 #2 位置修改 lastReqTime 值，线程 B 的赋值会覆盖线程 A，导致时间窗口起始点向后偏移。同样的，位置 #3 和 #4 也会构成竞争条件。当然如果对流控的精度要求不高，这种竞争也是能接受的。\n\n**临界突变问题**\n\n简单窗口的流控实现非常简单，以 1 分钟允许 100 次访问为例，如果流量均匀保持 200 次/分钟的访问速率，系统的访问量曲线大概是这样的（按分钟清零）：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/55c271e1437d49e2822a5f3114659474.png)\n\n但如果流量并不均匀，假设在时间窗口开始时刻 0:00 有几次零星的访问，一直到 0:50 时刻，开始以 10 次/秒的速度请求，就会出现这样的访问量图线：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/71496c33553043328fd24f9e6c58a352.png)\n\n在临界的 20 秒内（0:50~1:10）系统承受的实际访问量是 200 次，换句话说，最坏的情况下，在窗口临界点附近系统会承受 2 倍的流量冲击，这就是简单窗口不能解决的临界突变问题。\n\n#### 2 滑动窗口\n\n如何解决简单窗口算法的临界突变问题？既然一个窗口统计的精度低，那么可以把整个大的时间窗口切分成更细粒度的子窗口，每个子窗口独立统计。同时，每过一个子窗口大小的时间，就向右滑动一个子窗口。这就是滑动窗口算法的思路。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/64e7d74023a84b75a17fc320b152fa27.png)\n\n如上图所示，将一分钟的时间窗口切分成 6 个子窗口，每个子窗口维护一个独立的计数器用于统计 10 秒内的访问量，每经过 10s，时间窗口向右滑动一格。\n\n回到简单窗口出现临界跳变的例子，结合上面的图再看滑动窗口如何消除临界突变。如果 0:50 到 1:00 时刻（对应灰色的格子）进来了 100 次请求，接下来 1:00~1:10 的 100 次请求会落到黄色的格子中，由于算法统计的是 6 个子窗口的访问量总和，这时候总和超过设定的阈值 100，就会拒绝后面的这 100 次请求。\n\n**代码实现（参考 Sentinel）**\n\nSentinel 提供了一个轻量高性能的滑动窗口流控算法实现，看代码的时候可以重点关注这几个类：\n\n1）功能插槽 StatisticSlot 负责记录、统计不同纬度的 runtime 指标监控信息，例如 RT、QPS 等。\n\nSentinel 内部使用了 slot chain 的责任链设计模式，每个功能插槽 slot 有不同的功能（限流、降级、系统保护），通过 ProcessorSlotChain 串联在一起。\n\n参考官方 Wiki：\nhttps://github.com/alibaba/Sentinel/wiki/Sentinel工作主流程\n\n2）StatisticSlot 使用 StatisticNode#addPassRequest 记录允许的请求数，包含秒和分钟两个维度。\n\n3）具体记录用到的是 Metric 接口，对应实现类 ArrayMetric，背后真正的滑动窗口数据结构是 LeapArray 。\n\n4）LeapArray 内部维护了滑动窗口用到的关键属性和结构，包括：\n\na）总窗口大小 intervalInMs，滑动子窗口大小 windowLengthInMs，采样数量sampleCount：\n\nsampleCount = intervalInMs / windowLengthInMs\n\n当前实现默认为 2，而总窗口大小默认是 1s，也就意味着默认的滑动窗口大小是 500ms。可以通过调整采样数量来调整统计的精度。\n\nb）滑动窗口的数组 array，数组中每个元素以 WindowWrap 表示，其中包含：\n\n- windowStart：滑动窗口的开始时间。\n- windowLength：滑动窗口的长度。\n- value：滑动窗口记录的内容，泛型表示，关键的一类就是 MetricBucket，里面包含了一组 LongAdder 用于记录不同类型的数据，例如请求通过数、请求阻塞数、请求异常数等等。\n\n记录请求的逻辑说白了，就是根据当前时间获取所属的滑动窗口，然后将该窗口的统计值 +1 即可。但实际上，获取当前所属的时间窗口这一步隐含了不少细节，详细的实现可以从 LeapArray#currentWindow 中找到，源码的注释写得很详细，这里就不多提了。\n\n这里借助一张其他同学画的图表述以上的流程：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/94326f15088f4750acd811ec75b43252.png)\n\n以上的流程基于 3.9.21 版本的源码，早先版本的 Sentinel 内部版本实现不尽相同，使用了一个叫 SentinelRollingNumber 的数据结构，但原理是类似的。\n\n**精度问题**\n\n现在思考这么一个问题：滑动窗口算法能否精准地控制任意给定时间窗口 T 内的访问量不大于 N？\n\n答案是否定的，还是将 1 分钟分成 6 个 10 秒大小的子窗口的例子，假设请求的速率现在是 20 次/秒，从 0:05 时刻开始进入，那么在 0:05~0:10 时间段内会放进 100 个请求，同时接下来的请求都会被限流，直到 1:00 时刻窗口滑动，在 1:00~1:05 时刻继续放进 100 个请求。如果把 0:05~1:05 看作是 1 分钟的时间窗口，那么这个窗口内实际的请求量是 200，超出了给定的阈值 100。\n\n如果要追求更高的精度，理论上只需要把滑动窗口切分得更细。像 Sentinel 中就可以通过修改单位时间内的采样数量 sampleCount 值来设置精度，这个值一般根据业务的需求来定，以达到在精度和内存消耗之间的平衡。\n\n**平滑度问题**\n\n使用滑动窗口算法限制流量时，我们经常会看到像下面一样的流量曲线。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/d80a395b5cb24ca59f2b97d4fb55893e.png)\n\n突发的大流量在窗口开始不久就直接把限流的阈值打满，导致剩余的窗口内所有请求都无法通过。在时间窗口的单位比较大时（例如以分为单位进行流控），这种问题的影响就比较大了。在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。\n\n#### 3 漏桶\n\n滑动窗口无法很好地解决平滑度问题，再回过头看我们对于平滑度的诉求，当流量超过一定范围后，我们想要的效果不是一下子切断流量，而是将流量控制在系统能承受的一定的速度内。假设平均访问速率为 v, 那我们要做的流控其实是流速控制，即控制平均访问速率 v ≤ N / T。\n\n在网络通信中常常用到漏桶算法来实现流量整形。漏桶算法的思路就是基于流速来做控制。想象一下上学时经常做的水池一边抽水一边注水的应用题，把水池换成水桶（还是底下有洞一注水就开始漏的那种），把请求看作是往桶里注水，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃的请求。在概念上类比：\n\n- 最大允许请求数 N：桶的大小\n- 时间窗口大小 T：一整桶水漏完的时间\n- 最大访问速率 V：一整桶水漏完的速度，即 N/T\n- 请求被限流：桶注水的速度比漏水的速度快，最终导致桶内水溢出\n\n假设起始时刻桶是空的，每次访问都会往桶里注入一单位体积的水量，那么当我们以小于等于 N/T 的速度往桶里注水时，桶内的水就永远不会溢出。反之，一旦实际注水速度超过漏水速度，桶里就会产生越来越多的积水，直到溢出为止。同时漏水的速度永远被控制在 N/T 以内，这就实现了平滑流量的目的。\n\n漏桶算法的访问速率曲线如下：\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/68127312b88a4bb3ac0b4a1caf297f6c.png)\n\n附上一张网上常见的漏桶算法原题图：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/1299847fdcb042289fa10067ab074949.png)\n\n**代码实现 LeakyBucketThrottler**\n\n```\n/**\n * 当前桶内剩余的水\n */\nprivate long left;\n/**\n * 上次成功注水的时间戳\n */\nprivate long lastInjectTime = System.currentTimeMillis();\n/**\n * 桶的容量\n */\nprivate long capacity;\n/**\n * 一桶水漏完的时间\n */\nprivate long duration;\n/**\n * 桶漏水的速度，即 capacity / duration\n */\nprivate double velocity;\n\npublic boolean tryAcquire(String key) {\n    long now = System.currentTimeMillis();\n    // 当前剩余的水 = 之前的剩余水量 - 过去这段时间内漏掉的水量\n    // 过去这段时间内漏掉的水量 = (当前时间-上次注水时间) * 漏水速度\n    // 如果当前时间相比上次注水时间相隔太久（一直没有注水），桶内的剩余水量就是0（漏完了）\n    left = Math.max(0, left - (long)((now - lastInjectTime) * velocity));\n    // 往当前水量基础上注一单位水，只要没有溢出就代表可以访问\n    if (left + 1 <= capacity) {\n        lastInjectTime = now;\n        left++;\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n**漏桶的问题**\n\n漏桶的优势在于能够平滑流量，如果流量不是均匀的，那么漏桶算法与滑动窗口算法一样无法做到真正的精确控制。极端情况下，漏桶在时间窗口 T 内也会放进相当于 2 倍阈值 N 的流量。\n\n设想一下，如果访问量相比窗口大小 N 大很多，在窗口（0~T）一开始的 0 时刻就直接涌进来，使得漏桶在时间 t（ 0≈t\n\n虽然可以通过限制桶大小的方式使得访问量控制在 N 以内，但这样做的副作用是流量在还未达到限制条件就被禁止。\n\n还有一个隐含的约束是，漏桶漏水的速度最好是一个整数值（即容量 N 能够整除时间窗口大小 T ），否则在计算剩余水量时会有些许误差。\n\n#### 4 令牌桶\n\n漏桶模型中，请求来了是往桶里注水，如果反一下，把请求放行变成从桶里抽水，对应的，把注水看作是补充系统可承受流量的话，漏桶模型就变成了令牌桶模型。\n\n理解漏桶之后，再看令牌桶就很简单了，抄一段令牌桶的原理：\n\n> 令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/c17f0f04ac0642cd8764e477b0880e26.png)\n\n**代码实现 TokenBucketThrottler**\n\n令牌桶与漏桶本质上是一样的，因此漏桶的代码稍微改下就可以变成令牌桶。\n\n```\nlong now = System.currentTimeMillis();\nleft = Math.min(capacity, left + (long)((now - lastInjectTime) * velocity));\nif (left - 1 > 0) {\n    lastInjectTime = now;\n    left--;\n    return true;\n} else {\n    return false;\n}\n```\n\n生产环境中使用令牌桶的话，可以考虑借助 Guava 中提供的 RateLimiter。它的实现是多线程安全的，调用 RateLimiter#acquire 时，如果剩余令牌不足，会阻塞线程一段时间直至有足够的可用令牌（而不是直接拒绝，这在某些场景下很有用）。除去默认的 SmoothBursty 策略外，RateLimiter 还提供了一种叫 SmoothWarmingUp 的策略，支持设置一个热身期，热身期内，RateLimiter 会平滑地将放令牌的速率加大，直致最大速率。设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存) 。RateLimiter 有一个缺点是只支持 QPS 级别。\n\n**漏桶、令牌桶的区别**\n\n虽然两者本质上只是反转了一下，不过在实际使用中，适用的场景稍有差别：\n\n1）漏桶：用于控制网络中的速率。在该算法中，输入速率可以变化，但输出速率保持恒定。常常配合一个 FIFO 队列使用。\n\n想象一下，漏桶的破洞是固定大小的，因此漏水的速率是可以保持恒定的。\n\n2）令牌桶：按照固定速率往桶中添加令牌，允许输出速率根据突发大小而变化。\n\n举个例子，一个系统限制 60 秒内的最大访问量是 60 次，换算速率是 1 次/秒，如果在一段时间内没有访问量，那么对漏桶而言此刻是空的。现在，一瞬间涌入 60 个请求，那么流量整形后，漏桶会以每秒 1 个请求的速度，花上 1 分钟将 60 个请求漏给下游。换成令牌桶的话，则是从令牌桶中一次性取走 60 个令牌，一下子塞给下游。\n\n#### 5 滑动日志\n\n一般情况下，上述的算法已经能很好地用于大部分实际应用场景了，很少有场景需要真正完全精确的控制（即任意给定时间窗口T内请求量不大于 N ）。如果要精确控制的话，我们需要记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。这就是滑动日志的算法思路。\n\n设想某一个时刻 t 有一个请求，要判断是否允许，我们要看的其实是过去 t - N 时间段内是否有大于等于 N 个请求被放行，因此只要系统维护一个队列 q，里面记录每一个请求的时间，理论上就可以计算出从 t - N 时刻开始的请求数。\n\n考虑到只需关心当前时间之前最长 T 时间内的记录，因此队列 q 的长度可以动态变化，并且队列中最多只记录 N 条访问，因此队列长度的最大值为 N。\n\n> 滑动日志与滑动窗口非常像，区别在于滑动日志的滑动是根据日志记录的时间做动态滑动，而滑动窗口是根据子窗口的大小，以子窗口维度滑动。\n\n**伪代码实现**\n\n算法的伪代码表示如下：\n\n```\n# 初始化\ncounter = 0\nq = []\n\n# 请求处理流程\n# 1.找到队列中第一个时间戳>=t-T的请求，即以当前时间t截止的时间窗口T内的最早请求\nt = now\nstart = findWindowStart(q, t)\n\n# 2.截断队列，只保留最近T时间窗口内的记录和计数值\nq = q[start, q.length - 1] \ncounter -= start\n\n# 3.判断是否放行，如果允许放行则将这次请求加到队列 q 的末尾\nif counter < threshold\n    push(q, t)\n    counter++\n    # 放行\nelse\n    # 限流\n```\n\nfindWindowStart 的实现依赖于队列 q 使用的数据结构，以简单的数组为例，可以使用二分查找等方式。后面也会看到使用其他数据结构如何实现。\n\n如果用数组实现，一个难点可能是如何截断一个队列，一种可行的思路是使用一组头尾指针 head 和 tail 分别指向数组中最近和最早的有效记录索引来解决， findWindowStart 的实现就变成在 tail 和 head 之间查找对应元素。\n\n**复杂度问题**\n\n虽然算法解决了精确度问题，但代价也是显而易见的。\n\n首先，我们要保存一个长度最大为 N 的队列，这意味着空间复杂度达到 O(N)，如果要针对不同的 key 做流控，那么空间上会占用更多。当然，可以对不活跃 key 的队列进行复用来降低内存消耗。\n\n其次，我们需要在队列中确定时间窗口，即通过 findWindowStart 方法寻找不早于当前时间戳 t - N 的请求记录。以二分查找为例，时间复杂度是 O(logN)。\n\n### 四 分布式流控\n\n现实中的应用服务往往是分布式部署的，如果共用的资源（例如数据库）或者依赖的下游服务有流量限制，那么分布式流控就要派上用场了。\n\n虽然可以给每台应用服务器平均分配流控配额，把问题转换为单机流控，但如果碰到流量不均匀、机器宕机、临时扩缩容等场景，这种做法的效果不佳。\n\n分布式环境下做流控的核心算法思路其实与单机流控是一致的，区别在于需要实现一种同步机制来保证全局配额。同步机制的实现可以有中心化和去中心化两种思路：\n\n1）中心化：配额由一个中心系统统一管控，应用进程通过向中心系统申请的方式获取流控配额。\n\n- 状态的一致性在中心系统维护，实现简单。\n- 中心系统节点的不可用会导致流控出错，需要有额外的保护。例如，中心化流控在中心存储不可用时，往往会退化为单机流控。\n\n2）去中心化：应用进程独立保存和维护流控配额状态，集群内周期性异步通讯以保持状态一致。\n\n- 相比中心化方案，去中心化方案能够降低中心化单点可靠性带来的影响，但实现上比较复杂，状态的一致性难以保证。\n- 在 CAP 中去中心化更加倾向于 A 而中心化更倾向于 C。\n\n去中心化方案在生产环境中没有见过，因此下文只讨论中心化流控的思路。\n\n#### 1 接入层入口流控\n\n应用接入的网络架构中，在应用服务器之前往往有一层 LVS 或 Nginx 做统一入口，可以在这一层做入口的流控。本质上这就是单机流控的场景。\n\n以 Nginx 为例，Nginx 提供了 ngx_http_limit_req_module 模块用于流控，底层使用的是漏桶算法。\n\n一个 Nginx 流控配置的示例如下，表示每个 IP 地址每秒只能请求 10 次 /login/ 接口。\n\n```\nlimit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;\n\nserver {\n    location /login/ {\n        limit_req zone=mylimit;\n\n        proxy_pass http://my_upstream;\n    }\n}\n```\n\nNginx 的流控指令还支持更多配置，比如说配置 limit_req 指令时加上 burst 和 nodelay 参数来允许一定程度的突发，或者结合 geo 和 map 指令来实现黑白名单流控，具体可以参考 Nginx 官方文档：\nRate Limiting with NGINX and NGINX Plus（https://www.nginx.com/blog/rate-limiting-nginx/）。\n\n如果自带的模块不能满足，那就上自定义的 lua 模块吧，参考 OpenResty 提供的 Lua 限流模块 lua-resty-limit-traffic。\n\n#### 2 TokenServer 流控\n\n> 这里借用了 Sentinel 中的 TokenServer 叫法，Sentinel 集群流控的介绍可以参考官方文档：Sentinel集群流控（https://github.com/alibaba/Sentinel/wiki/集群流控）。\n\n这类流控的思路是找一个 TokenServer 来专门来管控流控配额，包括统计总调用量，判断单个请求是否允许等等，应用服务器作为客户端与 TokenServer 通信来获取配额。因为流控的逻辑在 TokenServer 内部统一处理，因此单机流控中讨论的算法同样适用。\n\n很自然地能想到，这类流控非常依赖于 TokenServer 的性能和可用性。\n\n性能方面，单点的 TokenServer 很容易成为瓶颈，查 Sentinel 源码，其中使用了 Netty 来做网络通信，数据包采用自定义格式，其他性能优化能找到的不多。\n\n可用性方面，就像 Sentinel 官方文档中讲的，若在生产环境使用 TokenServer 集群限流，必须要解决以下问题：\n\nToken Server 自动管理、调度（分配/选举 Token Server）\n\nToken Server 高可用，在某个 Server 不可用时自动 failover 到其它机器\n\n目前 Sentinel 的 TokenServer 默认并没有实现这些能力，需要定制或增加其他系统来实现，例如，采用一种分布式一致性协议来做集群选举，或者借助一组 monitor 来监控状态，实现成本还是挺高的。\n\n#### 3 存储式流控\n\n存储式流控的思想是通过一个存储系统来保存流控的计数值等统计信息，应用从存储中获取统计信息，然后将最新的请求信息再写入存储中。存储系统可以选择现成的 MySQL 数据库或者 Redis 缓存等，一般从性能出发选择缓存的比较多。这里选择 Tair 和 Redis 做例子。\n\n**Tair 流控**\n\n比较简单，直接上代码实现。\n\n```\npublic boolean tryAcquire(String key) {\n  // 以秒为单位构建tair的key\n  String wrappedKey = wrapKey(key);\n  // 每次请求+1，初始值为0，key的有效期设置5s\n  Result<Integer> result = tairManager.incr(NAMESPACE, wrappedKey, 1, 0, 5);\n  return result.isSuccess() && result.getValue() <= threshold;\n}\n\nprivate String wrapKey(String key) {\n  long sec = System.currentTimeMillis() / 1000L;\n  return key + \":\" + sec;\n}\n```\n\n是不是感觉太简单了点？得益于 Tair 的高性能，这种方式可以很好地支撑大流量。\n\n这种 Tair 流控的方案实际上用的简单窗口的思路，每个 key 以每秒为一个时间窗口做 QPS 控制（QPM/QPD 原理类似）。关键在于用到了 Tair 的这个 API：\n\n> incr\n\nResult incr(int namespace, Serializable key, int value, int defaultValue, int expireTime)\n描述\n增加计数。注意：incr 前不要 put！！\n参数\nnamespace - 申请时分配的 namespace\nkey - key 列表，不超过 1k\nvalue - 增加量\ndefaultValue - 第一次调用 incr 时的 key 的 count 初始值，第一次返回的值为 defaultValue + value。\nexpireTime - 数据过期时间，单位为秒，可设相对时间或绝对时间（Unix 时间戳）。expireTime = 0，表示数据永不过期。expireTime > 0，表示设置过期时间。若 expireTime > 当前时间的时间戳，则表示使用绝对时间，否则使用相对时间。expireTime < 0，表示不关注过期时间，若之前设过过期时间，则已之前的过期时间为准，若没有，则作为永不过期处理，但当前 mdb 统一当做永不过期来处理。\n返回值\nResult 对象，返回值可为负值。当 key 不存在时，第一次返回 defaultValue+ value。后续的 incr 基于该值增加 value。\n\n当然这种方式也有缺点：\n\n- 简单窗口的临界突变问题。\n- Tair 的可靠性问题，需要有降级方案。上面其实也说了，中心化的流控一般都需要搭配降级的单机流控。\n- 集群机器的时间同步问题。由于生成 key 会用到集群机器的本地时间，因此要求机器时间必须是一致的。\n\n打个比方，不同机器时间稍微差个 10ms，在时间窗口的间隔点上的统计就会产生比较大的误差，比如说在同一时刻，一台机器时间是 0.990，一台是 1.000，两者调用 incr 时操作的 key 不一样，精度自然就会受影响。\n\n**Redis 流控**\n\nRedis 支持丰富的数据结构，性能也不错，其“单进程”模型方便同步控制，因此非常适合用来做分布式流控的存储。\n\n1）简单窗口实现\n\n使用 Redis 实现简单窗口流控的思路跟使用 Tair 是一致的。Redis 也提供了 INCR 命令用于计数，同时 Redis 的“单进程”模型也提供了很好的并发保护。Redis 的官方文档就写了如何使用 INCR 来实现 Rate Limiter，我这里稍作翻译了下：\n\n> Redis INCR key(https://redis.io/commands/incr)\n\n以简单窗口为例，最简单直接的实现如下：\n\n```\nFUNCTION LIMIT_API_CALL(ip)\nts = CURRENT_UNIX_TIME()\nkeyname = ip+\":\"+ts\ncurrent = GET(keyname)\nIF current != NULL AND current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    MULTI\n        INCR(keyname,1)\n        EXPIRE(keyname,10)\n    EXEC\n    PERFORM_API_CALL()\nEND\n```\n\n实现上与上述的 Tair 类似，也是对每个 key 以秒为单位维护一个计数器，差别在于因为 Redis 没有提供原子的 INCR + EXPIRE 指令，所以在 INCR 之后需要再调用一次 EXPIRE 来设置 key 的有效期。同时在外层以 MULTI 和 EXEC 包裹以保证事务性。\n\n如果不想每次都调用 EXPIRE，可以考虑第二种方式：\n\n```\nFUNCTION LIMIT_API_CALL(ip):\ncurrent = GET(ip)\nIF current != NULL AND current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    value = INCR(ip)\n    IF value == 1 THEN\n        EXPIRE(ip,1)\n    END\n    PERFORM_API_CALL()\nEND\n```\n\n计数器的有效期在第一次 INCR 时设置为 1s，因此不需要对 key 进行额外处理。\n\n不过需要注意的是，这种方式存在一种隐藏的竞争条件。如果客户端在第一次调用了 INCR 后，由于应用崩溃或其他原因没有调用 EXPIRE，计数器会一直存在。\n\n针对方式二的这个问题，可以用 lua 脚本解决：\n\n```\nlocal current\ncurrent = redis.call(\"incr\",KEYS[1])\nif tonumber(current) == 1 then\n    redis.call(\"expire\",KEYS[1],1)\nend\n```\n\n第三种方式是通过 Redis 的 list 结构来实现。更复杂一些但可以记录下每次的请求。\n\n```\nFUNCTION LIMIT_API_CALL(ip)\ncurrent = LLEN(ip)\nIF current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    IF EXISTS(ip) == FALSE              #1\n        MULTI\n            RPUSH(ip,ip)\n            EXPIRE(ip,1)\n        EXEC\n    ELSE\n        RPUSHX(ip,ip)\n    END\n    PERFORM_API_CALL()\nEND\n```\n\n这里也有一个隐含的竞争条件，在执行到 EXIST 判断这一行（#1 位置）时，两个客户端的 EXIST 命令可能都会返回 false，因此 MULTI/EXEC 块里的命令会被执行两次，不过这种情况很少出现，不太会影响计数器的准确性。\n\n上述的几种方式还可以进一步优化，因为 INCR 和 RPUSH 这些命令都会返回操作后的计数器值，所以可以使用 set-then-get 的方式获取计数器值。\n\n将简单窗口改造成滑动窗口也是类似的思路，把单一的 key 换成一个 hash 结构，hash 里面为每个子窗口保存一个计数值，在统计时，将同个 hash 中所有子窗口的计数值相加即可。\n\n2）令牌桶/漏桶实现\n\n用 Redis 实现令牌桶或者漏桶也非常简单。以令牌桶为例，在实现上，可以用两个 key 分别存储每个用户的可用 token 数和上次请求时间，另一种可能更好的办法是使用 Redis 的 hash 数据结构。\n\n下图的示例是一个用户 user_1 当前在 Redis 中保存的流控配额数据：令牌桶中当前剩余 2 个 token，最近一次访问的时间戳是 1490868000。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/7a12af696eef4851ab16afb0d44426ea.png)\n\n当收到一个新请求时，Redis 客户端要执行的操作与我们在单机流控算法中看到的一样。首先，从对应 hash 中获得当前配额数据（HGETALL），根据当前时间戳、上次请求的时间戳和 token 填充速度计算要填充的 token 数；然后，判断是否放行，更新新的时间戳和 token 数（HMSET）。\n\n一个示例如下：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/2e0a53670860429faca7b77337931117.png)\n\n同样的，如果要求比较高的精度，这里必须要对客户端的操作做并发控制。\n\n不做同步控制可能导致的问题示例：桶里只有一个 token，两个客户端同时请求时出现并发冲突，结果是请求都会放行。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/c86cda7753e4469b8f517da77be5a4af.png)\n\nlua 代码示例如下：\n\n```\nlocal tokens_key = KEYS[1]\nlocal timestamp_key = KEYS[2]\n\nlocal rate = tonumber(ARGV[1])\nlocal capacity = tonumber(ARGV[2])\nlocal now = tonumber(ARGV[3])\nlocal requested = tonumber(ARGV[4])\n\nlocal fill_time = capacity/rate\nlocal ttl = math.floor(fill_time*2)\n\nlocal last_tokens = tonumber(redis.call(\"get\", tokens_key))\nif last_tokens == nil then\n  last_tokens = capacity\nend\n\nlocal last_refreshed = tonumber(redis.call(\"get\", timestamp_key))\nif last_refreshed == nil then\n  last_refreshed = 0\nend\n\nlocal delta = math.max(0, now-last_refreshed)\nlocal filled_tokens = math.min(capacity, last_tokens+(delta*rate))\nlocal allowed = filled_tokens >= requested\nlocal new_tokens = filled_tokens\nif allowed then\n  new_tokens = filled_tokens - requested\nend\n\nredis.call(\"setex\", tokens_key, ttl, new_tokens)\nredis.call(\"setex\", timestamp_key, ttl, now)\n\nreturn { allowed, new_tokens }\n```\n\n3）滑动日志实现\n\n得益于 Redis 的 Sorted Set 结构，实现滑动日志变得异常简单。流程大致如下：\n\na）每个用户有一个对应的 Sorted Set 记录请求日志。\n\n- 其中每个元素的 key 和 value 可以是相同的，即请求的时间戳。\n- Sorted Set 可以根据时间窗口大小设置有效期，比如时间窗口为 1s 时设置过期时间 5s，在请求量不大时可以节省 Redis 服务器内存。\n\nb）当收到一个新的用户请求时，首先通过 ZREMRANGEBYSCORE 命令删除 Sorted Set 中过期的元素，这里的过期即：\n\n请求时间戳 t < 当前时间戳 now - 时间窗口大小 interval\n\nc）使用 ZADD 将当前请求添加到 Set 中。\n\nd）使用 ZCOUNT 获取当前剩余 Set 大小，判断是否需要流控。\n\n```\nlong now = System.currentTimeMillis();\nlong maxScoreMs = now - windowInSecond * 1000;\n\nTransaction redis = jedisPool.getResource().multi();\nredis.zremrangeByScore(key, 0, maxScoreMs);\nredis.zadd(key, now, now + \"-\" + Math.random()); // 加入一个随机值使得member不重复\nredis.expire(key, windowInSecond);\nredis.exec();\n```\n\n另一个 JS 实现的代码示例：\nhttps://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js\n\n由于滑动日志算法的空间复杂度较其他算法高，使用滑动日志算法时，需要注意监控 Redis 内存的使用量。\n\n4）并发控制\n\n上面的几种算法都提到了不做并发控制可能带来的竞态条件，但额外的并发控制必然会带来性能下降，通常需要在精度和性能之间做取舍。Redis 流控的并发控制常见的有几类：\n\n- 使用 Redis 事务 MULTI/EXEC。\n- 使用 RedLock（https://redis.io/topics/distlock） 等分布式锁，要求每个客户端操作前先获取对应 key 的分布式锁。\n- Lua 脚本。\n\n最好通过性能测试来决定使用哪一种方式。\n\n#### 4 扩展的一些思考\n\n分布式流控带来了网络通信、加锁同步等开销，会对性能带来一定影响。同时分布式环境的可靠性也会带来更多挑战。如何设计一个高性能、高可靠性的分布式流控系统？这可能是个涉及到整个系统方方面面的大话题。\n\n分享一下个人的一些思考，欢迎讨论：\n\n1）根据实际诉求，合理搭配不同层的多级流控是个不错的方式，尽量把流量拦在外层。例如常见的接口层 Nginx 流控 + 应用层流控。\n\n2）选择一个合适的缓存系统保存流控的动态数据，这个一般跟着公司的统一技术架构走。\n\n3）将流控的静态配置放到配置中心（例如 Diamond）。\n\n4）设计时要考虑分布式流控不可用的情况（例如缓存挂掉），必要时切到单机流控，使用 Sentinel 成熟可靠。\n\n5）很多时候对精度的要求没那么高，因为一般都会允许一定的突发量。这时候可以做一些性能的优化。性能的最大瓶颈在于每次请求都会访问一次缓存，我之前在设计时就采用了一种折中的办法：\n\n- 将可用配额的一部分，按一定比例（例如 50%），先预分配给集群内的机器。一般是平均分配，如果预先就已经知道每台机器的流量权重，可以加权分配。每台机器消耗配额的速率不同，中间也可能有机器宕机，可能有扩缩容，因此预分配的比例不宜太大，当然也不宜太小。\n- 每台机器在配额耗尽时，向中心系统请求配额，这里的一个优化点是每台机器会记录自身配额消耗的速率（等同于承受的流量速率），按照速率大小申请不同大小的配额，消耗速率大则一次性申请更多。\n- 在整体可用配额不足一定比例时（例如 10%），限制每台机器一次可申请的配额数，按剩余窗口大小计算发放配额的大小，并且每次发放量不超过剩余配额的一定比例（例如 50%），使得剩余的流量能够平滑地过渡。\n\n五 总结\n\n分布式流控的算法其实是单机流控的延伸，算法本质是一样的。这里按我的个人理解总结了上述几种流控算法的复杂度和适用场景。\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/4ba212a1a7de40a6ba7601faa653b4d9.png)\n\n","source":"_posts/limiter.md","raw":"---\ntitle: 服务流控方案总结\ndate: 2020-12-26 14:09:12\ntags:\n  - 笔记\nid: limiter\ncategories:\n  - 笔记\n---\n\n转载自：https://developer.aliyun.com/article/765912\n\n### 一 流控的场景\n\n流控的意义其实无需多言了。最常用的场景下，流控是为了保护下游有限的资源不被流量冲垮，保证服务的可用性，一般允许流控的阈值有一定的弹性，偶尔的超量访问是可以接受的。\n\n有的时候，流控服务于收费模式，比如某些云厂商会对调用 API 的频次进行计费。既然涉及到钱，一般就不允许有超出阈值的调用量。\n\n这些不同的场景下，适用的流控算法不尽相同。大多数情况下，使用 Sentinel 中间件已经能很好地应对，但 Sentinel 也并不是万能的，需要思考其他的流控方案。\n\n<!--more-->\n\n### 二 接口定义\n\n为了方便，以下所有的示例代码实现都是基于 Throttler 接口。\n\nThrottler 接口定义了一个通用的方法用于申请单个配额。\n\n当然你也可以定义一个 tryAcquire(String key, int permits) 签名的方法用于一次申请多个配额，实现的思路是一样的。\n\n有些流控算法需要为每个 key 维护一个 Throttler 实例。\n\n```\npublic interface Throttler {\n    /**\n     * 尝试申请一个配额\n     *\n     * @param key     申请配额的key\n     * @return 申请成功则返回true，否则返回false\n     */\n    boolean tryAcquire(String key);\n}\n```\n\n### 三 单机流控\n\n#### 1 简单窗口\n\n> 简单窗口是我自己的命名，有些地方也叫做固定窗口，主要是为了跟后面的滑动窗口区分。\n\n流控是为了限制指定时间间隔内能够允许的访问量，因此，最直观的思路就是基于一个给定的时间窗口，维护一个计数器用于统计访问次数，然后实现以下规则：\n\n- 如果访问次数小于阈值，则代表允许访问，访问次数 +1。\n- 如果访问次数超出阈值，则限制访问，访问次数不增。\n- 如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。这样就确保计数器统计的是最近一个窗口的访问量。\n\n**代码实现 SimpleWindowThrottler**\n\n```\n/**\n * 毫秒为单位的时间窗口\n */\nprivate final long windowInMs;\n/**\n * 时间窗口内最大允许的阈值\n */\nprivate final int threshold;\n/**\n * 最后一次成功请求时间\n */\nprivate long lastReqTime = System.currentTimeMillis();\n/**\n * 计数器\n */\nprivate long counter;\n\npublic boolean tryAcquire(String key) {\n    long now = System.currentTimeMillis();\n    // 如果当前时间已经超过了上一次访问时间开始的时间窗口，重置计数器，以当前时间作为新窗口的起始值\n    if (now - lastReqTime > windowInMs) {       #1\n        counter = 0;\n        lastReqTime = now;                  #2\n    }\n    if (counter < threshold) {                  #3\n        counter++;                          #4\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n另外一种常见的场景是根据不同的 key 来做流控，每个 key 有单独的时间窗口、阈值配置，因此需要为每个 key 维护一个单独的限流器实例。\n\n**切换到多线程环境**\n在现实应用中，往往是多个线程来同时申请配额，为了比较简洁地表达算法思路，示例代码里面都没有做并发同步控制。\n\n以简单窗口的实现为例，要转换为多线程安全的流控算法，一种直接的办法是将 tryAcquire 方法设置为 synchronized。\n\n当然一种感觉上更高效的办法也可以是修改读写变量的类型：\n\n```\nprivate volatile long lastReqTime = System.currentTimeMillis();\nprivate LongAdder counter = new LongAdder();\n```\n\n不过这样其实并不真正“安全”，设想以下的场景，两个线程 A、线程 B 前后脚尝试获取配额，#1 位置的判断条件满足后，会同时走到 #2 位置修改 lastReqTime 值，线程 B 的赋值会覆盖线程 A，导致时间窗口起始点向后偏移。同样的，位置 #3 和 #4 也会构成竞争条件。当然如果对流控的精度要求不高，这种竞争也是能接受的。\n\n**临界突变问题**\n\n简单窗口的流控实现非常简单，以 1 分钟允许 100 次访问为例，如果流量均匀保持 200 次/分钟的访问速率，系统的访问量曲线大概是这样的（按分钟清零）：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/55c271e1437d49e2822a5f3114659474.png)\n\n但如果流量并不均匀，假设在时间窗口开始时刻 0:00 有几次零星的访问，一直到 0:50 时刻，开始以 10 次/秒的速度请求，就会出现这样的访问量图线：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/71496c33553043328fd24f9e6c58a352.png)\n\n在临界的 20 秒内（0:50~1:10）系统承受的实际访问量是 200 次，换句话说，最坏的情况下，在窗口临界点附近系统会承受 2 倍的流量冲击，这就是简单窗口不能解决的临界突变问题。\n\n#### 2 滑动窗口\n\n如何解决简单窗口算法的临界突变问题？既然一个窗口统计的精度低，那么可以把整个大的时间窗口切分成更细粒度的子窗口，每个子窗口独立统计。同时，每过一个子窗口大小的时间，就向右滑动一个子窗口。这就是滑动窗口算法的思路。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/64e7d74023a84b75a17fc320b152fa27.png)\n\n如上图所示，将一分钟的时间窗口切分成 6 个子窗口，每个子窗口维护一个独立的计数器用于统计 10 秒内的访问量，每经过 10s，时间窗口向右滑动一格。\n\n回到简单窗口出现临界跳变的例子，结合上面的图再看滑动窗口如何消除临界突变。如果 0:50 到 1:00 时刻（对应灰色的格子）进来了 100 次请求，接下来 1:00~1:10 的 100 次请求会落到黄色的格子中，由于算法统计的是 6 个子窗口的访问量总和，这时候总和超过设定的阈值 100，就会拒绝后面的这 100 次请求。\n\n**代码实现（参考 Sentinel）**\n\nSentinel 提供了一个轻量高性能的滑动窗口流控算法实现，看代码的时候可以重点关注这几个类：\n\n1）功能插槽 StatisticSlot 负责记录、统计不同纬度的 runtime 指标监控信息，例如 RT、QPS 等。\n\nSentinel 内部使用了 slot chain 的责任链设计模式，每个功能插槽 slot 有不同的功能（限流、降级、系统保护），通过 ProcessorSlotChain 串联在一起。\n\n参考官方 Wiki：\nhttps://github.com/alibaba/Sentinel/wiki/Sentinel工作主流程\n\n2）StatisticSlot 使用 StatisticNode#addPassRequest 记录允许的请求数，包含秒和分钟两个维度。\n\n3）具体记录用到的是 Metric 接口，对应实现类 ArrayMetric，背后真正的滑动窗口数据结构是 LeapArray 。\n\n4）LeapArray 内部维护了滑动窗口用到的关键属性和结构，包括：\n\na）总窗口大小 intervalInMs，滑动子窗口大小 windowLengthInMs，采样数量sampleCount：\n\nsampleCount = intervalInMs / windowLengthInMs\n\n当前实现默认为 2，而总窗口大小默认是 1s，也就意味着默认的滑动窗口大小是 500ms。可以通过调整采样数量来调整统计的精度。\n\nb）滑动窗口的数组 array，数组中每个元素以 WindowWrap 表示，其中包含：\n\n- windowStart：滑动窗口的开始时间。\n- windowLength：滑动窗口的长度。\n- value：滑动窗口记录的内容，泛型表示，关键的一类就是 MetricBucket，里面包含了一组 LongAdder 用于记录不同类型的数据，例如请求通过数、请求阻塞数、请求异常数等等。\n\n记录请求的逻辑说白了，就是根据当前时间获取所属的滑动窗口，然后将该窗口的统计值 +1 即可。但实际上，获取当前所属的时间窗口这一步隐含了不少细节，详细的实现可以从 LeapArray#currentWindow 中找到，源码的注释写得很详细，这里就不多提了。\n\n这里借助一张其他同学画的图表述以上的流程：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/94326f15088f4750acd811ec75b43252.png)\n\n以上的流程基于 3.9.21 版本的源码，早先版本的 Sentinel 内部版本实现不尽相同，使用了一个叫 SentinelRollingNumber 的数据结构，但原理是类似的。\n\n**精度问题**\n\n现在思考这么一个问题：滑动窗口算法能否精准地控制任意给定时间窗口 T 内的访问量不大于 N？\n\n答案是否定的，还是将 1 分钟分成 6 个 10 秒大小的子窗口的例子，假设请求的速率现在是 20 次/秒，从 0:05 时刻开始进入，那么在 0:05~0:10 时间段内会放进 100 个请求，同时接下来的请求都会被限流，直到 1:00 时刻窗口滑动，在 1:00~1:05 时刻继续放进 100 个请求。如果把 0:05~1:05 看作是 1 分钟的时间窗口，那么这个窗口内实际的请求量是 200，超出了给定的阈值 100。\n\n如果要追求更高的精度，理论上只需要把滑动窗口切分得更细。像 Sentinel 中就可以通过修改单位时间内的采样数量 sampleCount 值来设置精度，这个值一般根据业务的需求来定，以达到在精度和内存消耗之间的平衡。\n\n**平滑度问题**\n\n使用滑动窗口算法限制流量时，我们经常会看到像下面一样的流量曲线。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/d80a395b5cb24ca59f2b97d4fb55893e.png)\n\n突发的大流量在窗口开始不久就直接把限流的阈值打满，导致剩余的窗口内所有请求都无法通过。在时间窗口的单位比较大时（例如以分为单位进行流控），这种问题的影响就比较大了。在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。\n\n#### 3 漏桶\n\n滑动窗口无法很好地解决平滑度问题，再回过头看我们对于平滑度的诉求，当流量超过一定范围后，我们想要的效果不是一下子切断流量，而是将流量控制在系统能承受的一定的速度内。假设平均访问速率为 v, 那我们要做的流控其实是流速控制，即控制平均访问速率 v ≤ N / T。\n\n在网络通信中常常用到漏桶算法来实现流量整形。漏桶算法的思路就是基于流速来做控制。想象一下上学时经常做的水池一边抽水一边注水的应用题，把水池换成水桶（还是底下有洞一注水就开始漏的那种），把请求看作是往桶里注水，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃的请求。在概念上类比：\n\n- 最大允许请求数 N：桶的大小\n- 时间窗口大小 T：一整桶水漏完的时间\n- 最大访问速率 V：一整桶水漏完的速度，即 N/T\n- 请求被限流：桶注水的速度比漏水的速度快，最终导致桶内水溢出\n\n假设起始时刻桶是空的，每次访问都会往桶里注入一单位体积的水量，那么当我们以小于等于 N/T 的速度往桶里注水时，桶内的水就永远不会溢出。反之，一旦实际注水速度超过漏水速度，桶里就会产生越来越多的积水，直到溢出为止。同时漏水的速度永远被控制在 N/T 以内，这就实现了平滑流量的目的。\n\n漏桶算法的访问速率曲线如下：\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/68127312b88a4bb3ac0b4a1caf297f6c.png)\n\n附上一张网上常见的漏桶算法原题图：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/1299847fdcb042289fa10067ab074949.png)\n\n**代码实现 LeakyBucketThrottler**\n\n```\n/**\n * 当前桶内剩余的水\n */\nprivate long left;\n/**\n * 上次成功注水的时间戳\n */\nprivate long lastInjectTime = System.currentTimeMillis();\n/**\n * 桶的容量\n */\nprivate long capacity;\n/**\n * 一桶水漏完的时间\n */\nprivate long duration;\n/**\n * 桶漏水的速度，即 capacity / duration\n */\nprivate double velocity;\n\npublic boolean tryAcquire(String key) {\n    long now = System.currentTimeMillis();\n    // 当前剩余的水 = 之前的剩余水量 - 过去这段时间内漏掉的水量\n    // 过去这段时间内漏掉的水量 = (当前时间-上次注水时间) * 漏水速度\n    // 如果当前时间相比上次注水时间相隔太久（一直没有注水），桶内的剩余水量就是0（漏完了）\n    left = Math.max(0, left - (long)((now - lastInjectTime) * velocity));\n    // 往当前水量基础上注一单位水，只要没有溢出就代表可以访问\n    if (left + 1 <= capacity) {\n        lastInjectTime = now;\n        left++;\n        return true;\n    } else {\n        return false;\n    }\n}\n```\n\n**漏桶的问题**\n\n漏桶的优势在于能够平滑流量，如果流量不是均匀的，那么漏桶算法与滑动窗口算法一样无法做到真正的精确控制。极端情况下，漏桶在时间窗口 T 内也会放进相当于 2 倍阈值 N 的流量。\n\n设想一下，如果访问量相比窗口大小 N 大很多，在窗口（0~T）一开始的 0 时刻就直接涌进来，使得漏桶在时间 t（ 0≈t\n\n虽然可以通过限制桶大小的方式使得访问量控制在 N 以内，但这样做的副作用是流量在还未达到限制条件就被禁止。\n\n还有一个隐含的约束是，漏桶漏水的速度最好是一个整数值（即容量 N 能够整除时间窗口大小 T ），否则在计算剩余水量时会有些许误差。\n\n#### 4 令牌桶\n\n漏桶模型中，请求来了是往桶里注水，如果反一下，把请求放行变成从桶里抽水，对应的，把注水看作是补充系统可承受流量的话，漏桶模型就变成了令牌桶模型。\n\n理解漏桶之后，再看令牌桶就很简单了，抄一段令牌桶的原理：\n\n> 令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/c17f0f04ac0642cd8764e477b0880e26.png)\n\n**代码实现 TokenBucketThrottler**\n\n令牌桶与漏桶本质上是一样的，因此漏桶的代码稍微改下就可以变成令牌桶。\n\n```\nlong now = System.currentTimeMillis();\nleft = Math.min(capacity, left + (long)((now - lastInjectTime) * velocity));\nif (left - 1 > 0) {\n    lastInjectTime = now;\n    left--;\n    return true;\n} else {\n    return false;\n}\n```\n\n生产环境中使用令牌桶的话，可以考虑借助 Guava 中提供的 RateLimiter。它的实现是多线程安全的，调用 RateLimiter#acquire 时，如果剩余令牌不足，会阻塞线程一段时间直至有足够的可用令牌（而不是直接拒绝，这在某些场景下很有用）。除去默认的 SmoothBursty 策略外，RateLimiter 还提供了一种叫 SmoothWarmingUp 的策略，支持设置一个热身期，热身期内，RateLimiter 会平滑地将放令牌的速率加大，直致最大速率。设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存) 。RateLimiter 有一个缺点是只支持 QPS 级别。\n\n**漏桶、令牌桶的区别**\n\n虽然两者本质上只是反转了一下，不过在实际使用中，适用的场景稍有差别：\n\n1）漏桶：用于控制网络中的速率。在该算法中，输入速率可以变化，但输出速率保持恒定。常常配合一个 FIFO 队列使用。\n\n想象一下，漏桶的破洞是固定大小的，因此漏水的速率是可以保持恒定的。\n\n2）令牌桶：按照固定速率往桶中添加令牌，允许输出速率根据突发大小而变化。\n\n举个例子，一个系统限制 60 秒内的最大访问量是 60 次，换算速率是 1 次/秒，如果在一段时间内没有访问量，那么对漏桶而言此刻是空的。现在，一瞬间涌入 60 个请求，那么流量整形后，漏桶会以每秒 1 个请求的速度，花上 1 分钟将 60 个请求漏给下游。换成令牌桶的话，则是从令牌桶中一次性取走 60 个令牌，一下子塞给下游。\n\n#### 5 滑动日志\n\n一般情况下，上述的算法已经能很好地用于大部分实际应用场景了，很少有场景需要真正完全精确的控制（即任意给定时间窗口T内请求量不大于 N ）。如果要精确控制的话，我们需要记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。这就是滑动日志的算法思路。\n\n设想某一个时刻 t 有一个请求，要判断是否允许，我们要看的其实是过去 t - N 时间段内是否有大于等于 N 个请求被放行，因此只要系统维护一个队列 q，里面记录每一个请求的时间，理论上就可以计算出从 t - N 时刻开始的请求数。\n\n考虑到只需关心当前时间之前最长 T 时间内的记录，因此队列 q 的长度可以动态变化，并且队列中最多只记录 N 条访问，因此队列长度的最大值为 N。\n\n> 滑动日志与滑动窗口非常像，区别在于滑动日志的滑动是根据日志记录的时间做动态滑动，而滑动窗口是根据子窗口的大小，以子窗口维度滑动。\n\n**伪代码实现**\n\n算法的伪代码表示如下：\n\n```\n# 初始化\ncounter = 0\nq = []\n\n# 请求处理流程\n# 1.找到队列中第一个时间戳>=t-T的请求，即以当前时间t截止的时间窗口T内的最早请求\nt = now\nstart = findWindowStart(q, t)\n\n# 2.截断队列，只保留最近T时间窗口内的记录和计数值\nq = q[start, q.length - 1] \ncounter -= start\n\n# 3.判断是否放行，如果允许放行则将这次请求加到队列 q 的末尾\nif counter < threshold\n    push(q, t)\n    counter++\n    # 放行\nelse\n    # 限流\n```\n\nfindWindowStart 的实现依赖于队列 q 使用的数据结构，以简单的数组为例，可以使用二分查找等方式。后面也会看到使用其他数据结构如何实现。\n\n如果用数组实现，一个难点可能是如何截断一个队列，一种可行的思路是使用一组头尾指针 head 和 tail 分别指向数组中最近和最早的有效记录索引来解决， findWindowStart 的实现就变成在 tail 和 head 之间查找对应元素。\n\n**复杂度问题**\n\n虽然算法解决了精确度问题，但代价也是显而易见的。\n\n首先，我们要保存一个长度最大为 N 的队列，这意味着空间复杂度达到 O(N)，如果要针对不同的 key 做流控，那么空间上会占用更多。当然，可以对不活跃 key 的队列进行复用来降低内存消耗。\n\n其次，我们需要在队列中确定时间窗口，即通过 findWindowStart 方法寻找不早于当前时间戳 t - N 的请求记录。以二分查找为例，时间复杂度是 O(logN)。\n\n### 四 分布式流控\n\n现实中的应用服务往往是分布式部署的，如果共用的资源（例如数据库）或者依赖的下游服务有流量限制，那么分布式流控就要派上用场了。\n\n虽然可以给每台应用服务器平均分配流控配额，把问题转换为单机流控，但如果碰到流量不均匀、机器宕机、临时扩缩容等场景，这种做法的效果不佳。\n\n分布式环境下做流控的核心算法思路其实与单机流控是一致的，区别在于需要实现一种同步机制来保证全局配额。同步机制的实现可以有中心化和去中心化两种思路：\n\n1）中心化：配额由一个中心系统统一管控，应用进程通过向中心系统申请的方式获取流控配额。\n\n- 状态的一致性在中心系统维护，实现简单。\n- 中心系统节点的不可用会导致流控出错，需要有额外的保护。例如，中心化流控在中心存储不可用时，往往会退化为单机流控。\n\n2）去中心化：应用进程独立保存和维护流控配额状态，集群内周期性异步通讯以保持状态一致。\n\n- 相比中心化方案，去中心化方案能够降低中心化单点可靠性带来的影响，但实现上比较复杂，状态的一致性难以保证。\n- 在 CAP 中去中心化更加倾向于 A 而中心化更倾向于 C。\n\n去中心化方案在生产环境中没有见过，因此下文只讨论中心化流控的思路。\n\n#### 1 接入层入口流控\n\n应用接入的网络架构中，在应用服务器之前往往有一层 LVS 或 Nginx 做统一入口，可以在这一层做入口的流控。本质上这就是单机流控的场景。\n\n以 Nginx 为例，Nginx 提供了 ngx_http_limit_req_module 模块用于流控，底层使用的是漏桶算法。\n\n一个 Nginx 流控配置的示例如下，表示每个 IP 地址每秒只能请求 10 次 /login/ 接口。\n\n```\nlimit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;\n\nserver {\n    location /login/ {\n        limit_req zone=mylimit;\n\n        proxy_pass http://my_upstream;\n    }\n}\n```\n\nNginx 的流控指令还支持更多配置，比如说配置 limit_req 指令时加上 burst 和 nodelay 参数来允许一定程度的突发，或者结合 geo 和 map 指令来实现黑白名单流控，具体可以参考 Nginx 官方文档：\nRate Limiting with NGINX and NGINX Plus（https://www.nginx.com/blog/rate-limiting-nginx/）。\n\n如果自带的模块不能满足，那就上自定义的 lua 模块吧，参考 OpenResty 提供的 Lua 限流模块 lua-resty-limit-traffic。\n\n#### 2 TokenServer 流控\n\n> 这里借用了 Sentinel 中的 TokenServer 叫法，Sentinel 集群流控的介绍可以参考官方文档：Sentinel集群流控（https://github.com/alibaba/Sentinel/wiki/集群流控）。\n\n这类流控的思路是找一个 TokenServer 来专门来管控流控配额，包括统计总调用量，判断单个请求是否允许等等，应用服务器作为客户端与 TokenServer 通信来获取配额。因为流控的逻辑在 TokenServer 内部统一处理，因此单机流控中讨论的算法同样适用。\n\n很自然地能想到，这类流控非常依赖于 TokenServer 的性能和可用性。\n\n性能方面，单点的 TokenServer 很容易成为瓶颈，查 Sentinel 源码，其中使用了 Netty 来做网络通信，数据包采用自定义格式，其他性能优化能找到的不多。\n\n可用性方面，就像 Sentinel 官方文档中讲的，若在生产环境使用 TokenServer 集群限流，必须要解决以下问题：\n\nToken Server 自动管理、调度（分配/选举 Token Server）\n\nToken Server 高可用，在某个 Server 不可用时自动 failover 到其它机器\n\n目前 Sentinel 的 TokenServer 默认并没有实现这些能力，需要定制或增加其他系统来实现，例如，采用一种分布式一致性协议来做集群选举，或者借助一组 monitor 来监控状态，实现成本还是挺高的。\n\n#### 3 存储式流控\n\n存储式流控的思想是通过一个存储系统来保存流控的计数值等统计信息，应用从存储中获取统计信息，然后将最新的请求信息再写入存储中。存储系统可以选择现成的 MySQL 数据库或者 Redis 缓存等，一般从性能出发选择缓存的比较多。这里选择 Tair 和 Redis 做例子。\n\n**Tair 流控**\n\n比较简单，直接上代码实现。\n\n```\npublic boolean tryAcquire(String key) {\n  // 以秒为单位构建tair的key\n  String wrappedKey = wrapKey(key);\n  // 每次请求+1，初始值为0，key的有效期设置5s\n  Result<Integer> result = tairManager.incr(NAMESPACE, wrappedKey, 1, 0, 5);\n  return result.isSuccess() && result.getValue() <= threshold;\n}\n\nprivate String wrapKey(String key) {\n  long sec = System.currentTimeMillis() / 1000L;\n  return key + \":\" + sec;\n}\n```\n\n是不是感觉太简单了点？得益于 Tair 的高性能，这种方式可以很好地支撑大流量。\n\n这种 Tair 流控的方案实际上用的简单窗口的思路，每个 key 以每秒为一个时间窗口做 QPS 控制（QPM/QPD 原理类似）。关键在于用到了 Tair 的这个 API：\n\n> incr\n\nResult incr(int namespace, Serializable key, int value, int defaultValue, int expireTime)\n描述\n增加计数。注意：incr 前不要 put！！\n参数\nnamespace - 申请时分配的 namespace\nkey - key 列表，不超过 1k\nvalue - 增加量\ndefaultValue - 第一次调用 incr 时的 key 的 count 初始值，第一次返回的值为 defaultValue + value。\nexpireTime - 数据过期时间，单位为秒，可设相对时间或绝对时间（Unix 时间戳）。expireTime = 0，表示数据永不过期。expireTime > 0，表示设置过期时间。若 expireTime > 当前时间的时间戳，则表示使用绝对时间，否则使用相对时间。expireTime < 0，表示不关注过期时间，若之前设过过期时间，则已之前的过期时间为准，若没有，则作为永不过期处理，但当前 mdb 统一当做永不过期来处理。\n返回值\nResult 对象，返回值可为负值。当 key 不存在时，第一次返回 defaultValue+ value。后续的 incr 基于该值增加 value。\n\n当然这种方式也有缺点：\n\n- 简单窗口的临界突变问题。\n- Tair 的可靠性问题，需要有降级方案。上面其实也说了，中心化的流控一般都需要搭配降级的单机流控。\n- 集群机器的时间同步问题。由于生成 key 会用到集群机器的本地时间，因此要求机器时间必须是一致的。\n\n打个比方，不同机器时间稍微差个 10ms，在时间窗口的间隔点上的统计就会产生比较大的误差，比如说在同一时刻，一台机器时间是 0.990，一台是 1.000，两者调用 incr 时操作的 key 不一样，精度自然就会受影响。\n\n**Redis 流控**\n\nRedis 支持丰富的数据结构，性能也不错，其“单进程”模型方便同步控制，因此非常适合用来做分布式流控的存储。\n\n1）简单窗口实现\n\n使用 Redis 实现简单窗口流控的思路跟使用 Tair 是一致的。Redis 也提供了 INCR 命令用于计数，同时 Redis 的“单进程”模型也提供了很好的并发保护。Redis 的官方文档就写了如何使用 INCR 来实现 Rate Limiter，我这里稍作翻译了下：\n\n> Redis INCR key(https://redis.io/commands/incr)\n\n以简单窗口为例，最简单直接的实现如下：\n\n```\nFUNCTION LIMIT_API_CALL(ip)\nts = CURRENT_UNIX_TIME()\nkeyname = ip+\":\"+ts\ncurrent = GET(keyname)\nIF current != NULL AND current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    MULTI\n        INCR(keyname,1)\n        EXPIRE(keyname,10)\n    EXEC\n    PERFORM_API_CALL()\nEND\n```\n\n实现上与上述的 Tair 类似，也是对每个 key 以秒为单位维护一个计数器，差别在于因为 Redis 没有提供原子的 INCR + EXPIRE 指令，所以在 INCR 之后需要再调用一次 EXPIRE 来设置 key 的有效期。同时在外层以 MULTI 和 EXEC 包裹以保证事务性。\n\n如果不想每次都调用 EXPIRE，可以考虑第二种方式：\n\n```\nFUNCTION LIMIT_API_CALL(ip):\ncurrent = GET(ip)\nIF current != NULL AND current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    value = INCR(ip)\n    IF value == 1 THEN\n        EXPIRE(ip,1)\n    END\n    PERFORM_API_CALL()\nEND\n```\n\n计数器的有效期在第一次 INCR 时设置为 1s，因此不需要对 key 进行额外处理。\n\n不过需要注意的是，这种方式存在一种隐藏的竞争条件。如果客户端在第一次调用了 INCR 后，由于应用崩溃或其他原因没有调用 EXPIRE，计数器会一直存在。\n\n针对方式二的这个问题，可以用 lua 脚本解决：\n\n```\nlocal current\ncurrent = redis.call(\"incr\",KEYS[1])\nif tonumber(current) == 1 then\n    redis.call(\"expire\",KEYS[1],1)\nend\n```\n\n第三种方式是通过 Redis 的 list 结构来实现。更复杂一些但可以记录下每次的请求。\n\n```\nFUNCTION LIMIT_API_CALL(ip)\ncurrent = LLEN(ip)\nIF current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    IF EXISTS(ip) == FALSE              #1\n        MULTI\n            RPUSH(ip,ip)\n            EXPIRE(ip,1)\n        EXEC\n    ELSE\n        RPUSHX(ip,ip)\n    END\n    PERFORM_API_CALL()\nEND\n```\n\n这里也有一个隐含的竞争条件，在执行到 EXIST 判断这一行（#1 位置）时，两个客户端的 EXIST 命令可能都会返回 false，因此 MULTI/EXEC 块里的命令会被执行两次，不过这种情况很少出现，不太会影响计数器的准确性。\n\n上述的几种方式还可以进一步优化，因为 INCR 和 RPUSH 这些命令都会返回操作后的计数器值，所以可以使用 set-then-get 的方式获取计数器值。\n\n将简单窗口改造成滑动窗口也是类似的思路，把单一的 key 换成一个 hash 结构，hash 里面为每个子窗口保存一个计数值，在统计时，将同个 hash 中所有子窗口的计数值相加即可。\n\n2）令牌桶/漏桶实现\n\n用 Redis 实现令牌桶或者漏桶也非常简单。以令牌桶为例，在实现上，可以用两个 key 分别存储每个用户的可用 token 数和上次请求时间，另一种可能更好的办法是使用 Redis 的 hash 数据结构。\n\n下图的示例是一个用户 user_1 当前在 Redis 中保存的流控配额数据：令牌桶中当前剩余 2 个 token，最近一次访问的时间戳是 1490868000。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/7a12af696eef4851ab16afb0d44426ea.png)\n\n当收到一个新请求时，Redis 客户端要执行的操作与我们在单机流控算法中看到的一样。首先，从对应 hash 中获得当前配额数据（HGETALL），根据当前时间戳、上次请求的时间戳和 token 填充速度计算要填充的 token 数；然后，判断是否放行，更新新的时间戳和 token 数（HMSET）。\n\n一个示例如下：\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/2e0a53670860429faca7b77337931117.png)\n\n同样的，如果要求比较高的精度，这里必须要对客户端的操作做并发控制。\n\n不做同步控制可能导致的问题示例：桶里只有一个 token，两个客户端同时请求时出现并发冲突，结果是请求都会放行。\n\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/c86cda7753e4469b8f517da77be5a4af.png)\n\nlua 代码示例如下：\n\n```\nlocal tokens_key = KEYS[1]\nlocal timestamp_key = KEYS[2]\n\nlocal rate = tonumber(ARGV[1])\nlocal capacity = tonumber(ARGV[2])\nlocal now = tonumber(ARGV[3])\nlocal requested = tonumber(ARGV[4])\n\nlocal fill_time = capacity/rate\nlocal ttl = math.floor(fill_time*2)\n\nlocal last_tokens = tonumber(redis.call(\"get\", tokens_key))\nif last_tokens == nil then\n  last_tokens = capacity\nend\n\nlocal last_refreshed = tonumber(redis.call(\"get\", timestamp_key))\nif last_refreshed == nil then\n  last_refreshed = 0\nend\n\nlocal delta = math.max(0, now-last_refreshed)\nlocal filled_tokens = math.min(capacity, last_tokens+(delta*rate))\nlocal allowed = filled_tokens >= requested\nlocal new_tokens = filled_tokens\nif allowed then\n  new_tokens = filled_tokens - requested\nend\n\nredis.call(\"setex\", tokens_key, ttl, new_tokens)\nredis.call(\"setex\", timestamp_key, ttl, now)\n\nreturn { allowed, new_tokens }\n```\n\n3）滑动日志实现\n\n得益于 Redis 的 Sorted Set 结构，实现滑动日志变得异常简单。流程大致如下：\n\na）每个用户有一个对应的 Sorted Set 记录请求日志。\n\n- 其中每个元素的 key 和 value 可以是相同的，即请求的时间戳。\n- Sorted Set 可以根据时间窗口大小设置有效期，比如时间窗口为 1s 时设置过期时间 5s，在请求量不大时可以节省 Redis 服务器内存。\n\nb）当收到一个新的用户请求时，首先通过 ZREMRANGEBYSCORE 命令删除 Sorted Set 中过期的元素，这里的过期即：\n\n请求时间戳 t < 当前时间戳 now - 时间窗口大小 interval\n\nc）使用 ZADD 将当前请求添加到 Set 中。\n\nd）使用 ZCOUNT 获取当前剩余 Set 大小，判断是否需要流控。\n\n```\nlong now = System.currentTimeMillis();\nlong maxScoreMs = now - windowInSecond * 1000;\n\nTransaction redis = jedisPool.getResource().multi();\nredis.zremrangeByScore(key, 0, maxScoreMs);\nredis.zadd(key, now, now + \"-\" + Math.random()); // 加入一个随机值使得member不重复\nredis.expire(key, windowInSecond);\nredis.exec();\n```\n\n另一个 JS 实现的代码示例：\nhttps://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js\n\n由于滑动日志算法的空间复杂度较其他算法高，使用滑动日志算法时，需要注意监控 Redis 内存的使用量。\n\n4）并发控制\n\n上面的几种算法都提到了不做并发控制可能带来的竞态条件，但额外的并发控制必然会带来性能下降，通常需要在精度和性能之间做取舍。Redis 流控的并发控制常见的有几类：\n\n- 使用 Redis 事务 MULTI/EXEC。\n- 使用 RedLock（https://redis.io/topics/distlock） 等分布式锁，要求每个客户端操作前先获取对应 key 的分布式锁。\n- Lua 脚本。\n\n最好通过性能测试来决定使用哪一种方式。\n\n#### 4 扩展的一些思考\n\n分布式流控带来了网络通信、加锁同步等开销，会对性能带来一定影响。同时分布式环境的可靠性也会带来更多挑战。如何设计一个高性能、高可靠性的分布式流控系统？这可能是个涉及到整个系统方方面面的大话题。\n\n分享一下个人的一些思考，欢迎讨论：\n\n1）根据实际诉求，合理搭配不同层的多级流控是个不错的方式，尽量把流量拦在外层。例如常见的接口层 Nginx 流控 + 应用层流控。\n\n2）选择一个合适的缓存系统保存流控的动态数据，这个一般跟着公司的统一技术架构走。\n\n3）将流控的静态配置放到配置中心（例如 Diamond）。\n\n4）设计时要考虑分布式流控不可用的情况（例如缓存挂掉），必要时切到单机流控，使用 Sentinel 成熟可靠。\n\n5）很多时候对精度的要求没那么高，因为一般都会允许一定的突发量。这时候可以做一些性能的优化。性能的最大瓶颈在于每次请求都会访问一次缓存，我之前在设计时就采用了一种折中的办法：\n\n- 将可用配额的一部分，按一定比例（例如 50%），先预分配给集群内的机器。一般是平均分配，如果预先就已经知道每台机器的流量权重，可以加权分配。每台机器消耗配额的速率不同，中间也可能有机器宕机，可能有扩缩容，因此预分配的比例不宜太大，当然也不宜太小。\n- 每台机器在配额耗尽时，向中心系统请求配额，这里的一个优化点是每台机器会记录自身配额消耗的速率（等同于承受的流量速率），按照速率大小申请不同大小的配额，消耗速率大则一次性申请更多。\n- 在整体可用配额不足一定比例时（例如 10%），限制每台机器一次可申请的配额数，按剩余窗口大小计算发放配额的大小，并且每次发放量不超过剩余配额的一定比例（例如 50%），使得剩余的流量能够平滑地过渡。\n\n五 总结\n\n分布式流控的算法其实是单机流控的延伸，算法本质是一样的。这里按我的个人理解总结了上述几种流控算法的复杂度和适用场景。\n![image.png](https://ucc.alicdn.com/pic/developer-ecology/4ba212a1a7de40a6ba7601faa653b4d9.png)\n\n","slug":"limiter","published":1,"updated":"2021-08-30T12:49:07.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt1g0lkg001rhcmn5d05e9qo","content":"<p>转载自：<a href=\"https://developer.aliyun.com/article/765912\">https://developer.aliyun.com/article/765912</a></p>\n<h3 id=\"一-流控的场景\"><a href=\"#一-流控的场景\" class=\"headerlink\" title=\"一 流控的场景\"></a>一 流控的场景</h3><p>流控的意义其实无需多言了。最常用的场景下，流控是为了保护下游有限的资源不被流量冲垮，保证服务的可用性，一般允许流控的阈值有一定的弹性，偶尔的超量访问是可以接受的。</p>\n<p>有的时候，流控服务于收费模式，比如某些云厂商会对调用 API 的频次进行计费。既然涉及到钱，一般就不允许有超出阈值的调用量。</p>\n<p>这些不同的场景下，适用的流控算法不尽相同。大多数情况下，使用 Sentinel 中间件已经能很好地应对，但 Sentinel 也并不是万能的，需要思考其他的流控方案。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"二-接口定义\"><a href=\"#二-接口定义\" class=\"headerlink\" title=\"二 接口定义\"></a>二 接口定义</h3><p>为了方便，以下所有的示例代码实现都是基于 Throttler 接口。</p>\n<p>Throttler 接口定义了一个通用的方法用于申请单个配额。</p>\n<p>当然你也可以定义一个 tryAcquire(String key, int permits) 签名的方法用于一次申请多个配额，实现的思路是一样的。</p>\n<p>有些流控算法需要为每个 key 维护一个 Throttler 实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Throttler &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 尝试申请一个配额</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param key     申请配额的key</span><br><span class=\"line\">     * @return 申请成功则返回true，否则返回false</span><br><span class=\"line\">     */</span><br><span class=\"line\">    boolean tryAcquire(String key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三-单机流控\"><a href=\"#三-单机流控\" class=\"headerlink\" title=\"三 单机流控\"></a>三 单机流控</h3><h4 id=\"1-简单窗口\"><a href=\"#1-简单窗口\" class=\"headerlink\" title=\"1 简单窗口\"></a>1 简单窗口</h4><blockquote>\n<p>简单窗口是我自己的命名，有些地方也叫做固定窗口，主要是为了跟后面的滑动窗口区分。</p>\n</blockquote>\n<p>流控是为了限制指定时间间隔内能够允许的访问量，因此，最直观的思路就是基于一个给定的时间窗口，维护一个计数器用于统计访问次数，然后实现以下规则：</p>\n<ul>\n<li>如果访问次数小于阈值，则代表允许访问，访问次数 +1。</li>\n<li>如果访问次数超出阈值，则限制访问，访问次数不增。</li>\n<li>如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。这样就确保计数器统计的是最近一个窗口的访问量。</li>\n</ul>\n<p><strong>代码实现 SimpleWindowThrottler</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 毫秒为单位的时间窗口</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final long windowInMs;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 时间窗口内最大允许的阈值</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final int threshold;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 最后一次成功请求时间</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long lastReqTime = System.currentTimeMillis();</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 计数器</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long counter;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean tryAcquire(String key) &#123;</span><br><span class=\"line\">    long now = System.currentTimeMillis();</span><br><span class=\"line\">    // 如果当前时间已经超过了上一次访问时间开始的时间窗口，重置计数器，以当前时间作为新窗口的起始值</span><br><span class=\"line\">    if (now - lastReqTime &gt; windowInMs) &#123;       #1</span><br><span class=\"line\">        counter = 0;</span><br><span class=\"line\">        lastReqTime = now;                  #2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (counter &lt; threshold) &#123;                  #3</span><br><span class=\"line\">        counter++;                          #4</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种常见的场景是根据不同的 key 来做流控，每个 key 有单独的时间窗口、阈值配置，因此需要为每个 key 维护一个单独的限流器实例。</p>\n<p><strong>切换到多线程环境</strong><br>在现实应用中，往往是多个线程来同时申请配额，为了比较简洁地表达算法思路，示例代码里面都没有做并发同步控制。</p>\n<p>以简单窗口的实现为例，要转换为多线程安全的流控算法，一种直接的办法是将 tryAcquire 方法设置为 synchronized。</p>\n<p>当然一种感觉上更高效的办法也可以是修改读写变量的类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile long lastReqTime = System.currentTimeMillis();</span><br><span class=\"line\">private LongAdder counter = new LongAdder();</span><br></pre></td></tr></table></figure>\n\n<p>不过这样其实并不真正“安全”，设想以下的场景，两个线程 A、线程 B 前后脚尝试获取配额，#1 位置的判断条件满足后，会同时走到 #2 位置修改 lastReqTime 值，线程 B 的赋值会覆盖线程 A，导致时间窗口起始点向后偏移。同样的，位置 #3 和 #4 也会构成竞争条件。当然如果对流控的精度要求不高，这种竞争也是能接受的。</p>\n<p><strong>临界突变问题</strong></p>\n<p>简单窗口的流控实现非常简单，以 1 分钟允许 100 次访问为例，如果流量均匀保持 200 次/分钟的访问速率，系统的访问量曲线大概是这样的（按分钟清零）：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/55c271e1437d49e2822a5f3114659474.png\" alt=\"image.png\"></p>\n<p>但如果流量并不均匀，假设在时间窗口开始时刻 0:00 有几次零星的访问，一直到 0:50 时刻，开始以 10 次/秒的速度请求，就会出现这样的访问量图线：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/71496c33553043328fd24f9e6c58a352.png\" alt=\"image.png\"></p>\n<p>在临界的 20 秒内（0:50~1:10）系统承受的实际访问量是 200 次，换句话说，最坏的情况下，在窗口临界点附近系统会承受 2 倍的流量冲击，这就是简单窗口不能解决的临界突变问题。</p>\n<h4 id=\"2-滑动窗口\"><a href=\"#2-滑动窗口\" class=\"headerlink\" title=\"2 滑动窗口\"></a>2 滑动窗口</h4><p>如何解决简单窗口算法的临界突变问题？既然一个窗口统计的精度低，那么可以把整个大的时间窗口切分成更细粒度的子窗口，每个子窗口独立统计。同时，每过一个子窗口大小的时间，就向右滑动一个子窗口。这就是滑动窗口算法的思路。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/64e7d74023a84b75a17fc320b152fa27.png\" alt=\"image.png\"></p>\n<p>如上图所示，将一分钟的时间窗口切分成 6 个子窗口，每个子窗口维护一个独立的计数器用于统计 10 秒内的访问量，每经过 10s，时间窗口向右滑动一格。</p>\n<p>回到简单窗口出现临界跳变的例子，结合上面的图再看滑动窗口如何消除临界突变。如果 0:50 到 1:00 时刻（对应灰色的格子）进来了 100 次请求，接下来 1:00~1:10 的 100 次请求会落到黄色的格子中，由于算法统计的是 6 个子窗口的访问量总和，这时候总和超过设定的阈值 100，就会拒绝后面的这 100 次请求。</p>\n<p><strong>代码实现（参考 Sentinel）</strong></p>\n<p>Sentinel 提供了一个轻量高性能的滑动窗口流控算法实现，看代码的时候可以重点关注这几个类：</p>\n<p>1）功能插槽 StatisticSlot 负责记录、统计不同纬度的 runtime 指标监控信息，例如 RT、QPS 等。</p>\n<p>Sentinel 内部使用了 slot chain 的责任链设计模式，每个功能插槽 slot 有不同的功能（限流、降级、系统保护），通过 ProcessorSlotChain 串联在一起。</p>\n<p>参考官方 Wiki：<br><a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel%E5%B7%A5%E4%BD%9C%E4%B8%BB%E6%B5%81%E7%A8%8B\">https://github.com/alibaba/Sentinel/wiki/Sentinel工作主流程</a></p>\n<p>2）StatisticSlot 使用 StatisticNode#addPassRequest 记录允许的请求数，包含秒和分钟两个维度。</p>\n<p>3）具体记录用到的是 Metric 接口，对应实现类 ArrayMetric，背后真正的滑动窗口数据结构是 LeapArray 。</p>\n<p>4）LeapArray 内部维护了滑动窗口用到的关键属性和结构，包括：</p>\n<p>a）总窗口大小 intervalInMs，滑动子窗口大小 windowLengthInMs，采样数量sampleCount：</p>\n<p>sampleCount = intervalInMs / windowLengthInMs</p>\n<p>当前实现默认为 2，而总窗口大小默认是 1s，也就意味着默认的滑动窗口大小是 500ms。可以通过调整采样数量来调整统计的精度。</p>\n<p>b）滑动窗口的数组 array，数组中每个元素以 WindowWrap 表示，其中包含：</p>\n<ul>\n<li>windowStart：滑动窗口的开始时间。</li>\n<li>windowLength：滑动窗口的长度。</li>\n<li>value：滑动窗口记录的内容，泛型表示，关键的一类就是 MetricBucket，里面包含了一组 LongAdder 用于记录不同类型的数据，例如请求通过数、请求阻塞数、请求异常数等等。</li>\n</ul>\n<p>记录请求的逻辑说白了，就是根据当前时间获取所属的滑动窗口，然后将该窗口的统计值 +1 即可。但实际上，获取当前所属的时间窗口这一步隐含了不少细节，详细的实现可以从 LeapArray#currentWindow 中找到，源码的注释写得很详细，这里就不多提了。</p>\n<p>这里借助一张其他同学画的图表述以上的流程：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/94326f15088f4750acd811ec75b43252.png\" alt=\"image.png\"></p>\n<p>以上的流程基于 3.9.21 版本的源码，早先版本的 Sentinel 内部版本实现不尽相同，使用了一个叫 SentinelRollingNumber 的数据结构，但原理是类似的。</p>\n<p><strong>精度问题</strong></p>\n<p>现在思考这么一个问题：滑动窗口算法能否精准地控制任意给定时间窗口 T 内的访问量不大于 N？</p>\n<p>答案是否定的，还是将 1 分钟分成 6 个 10 秒大小的子窗口的例子，假设请求的速率现在是 20 次/秒，从 0:05 时刻开始进入，那么在 0:05<del>0:10 时间段内会放进 100 个请求，同时接下来的请求都会被限流，直到 1:00 时刻窗口滑动，在 1:00</del>1:05 时刻继续放进 100 个请求。如果把 0:05~1:05 看作是 1 分钟的时间窗口，那么这个窗口内实际的请求量是 200，超出了给定的阈值 100。</p>\n<p>如果要追求更高的精度，理论上只需要把滑动窗口切分得更细。像 Sentinel 中就可以通过修改单位时间内的采样数量 sampleCount 值来设置精度，这个值一般根据业务的需求来定，以达到在精度和内存消耗之间的平衡。</p>\n<p><strong>平滑度问题</strong></p>\n<p>使用滑动窗口算法限制流量时，我们经常会看到像下面一样的流量曲线。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/d80a395b5cb24ca59f2b97d4fb55893e.png\" alt=\"image.png\"></p>\n<p>突发的大流量在窗口开始不久就直接把限流的阈值打满，导致剩余的窗口内所有请求都无法通过。在时间窗口的单位比较大时（例如以分为单位进行流控），这种问题的影响就比较大了。在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。</p>\n<h4 id=\"3-漏桶\"><a href=\"#3-漏桶\" class=\"headerlink\" title=\"3 漏桶\"></a>3 漏桶</h4><p>滑动窗口无法很好地解决平滑度问题，再回过头看我们对于平滑度的诉求，当流量超过一定范围后，我们想要的效果不是一下子切断流量，而是将流量控制在系统能承受的一定的速度内。假设平均访问速率为 v, 那我们要做的流控其实是流速控制，即控制平均访问速率 v ≤ N / T。</p>\n<p>在网络通信中常常用到漏桶算法来实现流量整形。漏桶算法的思路就是基于流速来做控制。想象一下上学时经常做的水池一边抽水一边注水的应用题，把水池换成水桶（还是底下有洞一注水就开始漏的那种），把请求看作是往桶里注水，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃的请求。在概念上类比：</p>\n<ul>\n<li>最大允许请求数 N：桶的大小</li>\n<li>时间窗口大小 T：一整桶水漏完的时间</li>\n<li>最大访问速率 V：一整桶水漏完的速度，即 N/T</li>\n<li>请求被限流：桶注水的速度比漏水的速度快，最终导致桶内水溢出</li>\n</ul>\n<p>假设起始时刻桶是空的，每次访问都会往桶里注入一单位体积的水量，那么当我们以小于等于 N/T 的速度往桶里注水时，桶内的水就永远不会溢出。反之，一旦实际注水速度超过漏水速度，桶里就会产生越来越多的积水，直到溢出为止。同时漏水的速度永远被控制在 N/T 以内，这就实现了平滑流量的目的。</p>\n<p>漏桶算法的访问速率曲线如下：<br><img src=\"https://ucc.alicdn.com/pic/developer-ecology/68127312b88a4bb3ac0b4a1caf297f6c.png\" alt=\"image.png\"></p>\n<p>附上一张网上常见的漏桶算法原题图：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/1299847fdcb042289fa10067ab074949.png\" alt=\"image.png\"></p>\n<p><strong>代码实现 LeakyBucketThrottler</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 当前桶内剩余的水</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long left;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 上次成功注水的时间戳</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long lastInjectTime = System.currentTimeMillis();</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 桶的容量</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long capacity;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 一桶水漏完的时间</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long duration;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 桶漏水的速度，即 capacity / duration</span><br><span class=\"line\"> */</span><br><span class=\"line\">private double velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean tryAcquire(String key) &#123;</span><br><span class=\"line\">    long now = System.currentTimeMillis();</span><br><span class=\"line\">    // 当前剩余的水 = 之前的剩余水量 - 过去这段时间内漏掉的水量</span><br><span class=\"line\">    // 过去这段时间内漏掉的水量 = (当前时间-上次注水时间) * 漏水速度</span><br><span class=\"line\">    // 如果当前时间相比上次注水时间相隔太久（一直没有注水），桶内的剩余水量就是0（漏完了）</span><br><span class=\"line\">    left = Math.max(0, left - (long)((now - lastInjectTime) * velocity));</span><br><span class=\"line\">    // 往当前水量基础上注一单位水，只要没有溢出就代表可以访问</span><br><span class=\"line\">    if (left + 1 &lt;= capacity) &#123;</span><br><span class=\"line\">        lastInjectTime = now;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>漏桶的问题</strong></p>\n<p>漏桶的优势在于能够平滑流量，如果流量不是均匀的，那么漏桶算法与滑动窗口算法一样无法做到真正的精确控制。极端情况下，漏桶在时间窗口 T 内也会放进相当于 2 倍阈值 N 的流量。</p>\n<p>设想一下，如果访问量相比窗口大小 N 大很多，在窗口（0~T）一开始的 0 时刻就直接涌进来，使得漏桶在时间 t（ 0≈t</p>\n<p>虽然可以通过限制桶大小的方式使得访问量控制在 N 以内，但这样做的副作用是流量在还未达到限制条件就被禁止。</p>\n<p>还有一个隐含的约束是，漏桶漏水的速度最好是一个整数值（即容量 N 能够整除时间窗口大小 T ），否则在计算剩余水量时会有些许误差。</p>\n<h4 id=\"4-令牌桶\"><a href=\"#4-令牌桶\" class=\"headerlink\" title=\"4 令牌桶\"></a>4 令牌桶</h4><p>漏桶模型中，请求来了是往桶里注水，如果反一下，把请求放行变成从桶里抽水，对应的，把注水看作是补充系统可承受流量的话，漏桶模型就变成了令牌桶模型。</p>\n<p>理解漏桶之后，再看令牌桶就很简单了，抄一段令牌桶的原理：</p>\n<blockquote>\n<p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>\n</blockquote>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/c17f0f04ac0642cd8764e477b0880e26.png\" alt=\"image.png\"></p>\n<p><strong>代码实现 TokenBucketThrottler</strong></p>\n<p>令牌桶与漏桶本质上是一样的，因此漏桶的代码稍微改下就可以变成令牌桶。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long now = System.currentTimeMillis();</span><br><span class=\"line\">left = Math.min(capacity, left + (long)((now - lastInjectTime) * velocity));</span><br><span class=\"line\">if (left - 1 &gt; 0) &#123;</span><br><span class=\"line\">    lastInjectTime = now;</span><br><span class=\"line\">    left--;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生产环境中使用令牌桶的话，可以考虑借助 Guava 中提供的 RateLimiter。它的实现是多线程安全的，调用 RateLimiter#acquire 时，如果剩余令牌不足，会阻塞线程一段时间直至有足够的可用令牌（而不是直接拒绝，这在某些场景下很有用）。除去默认的 SmoothBursty 策略外，RateLimiter 还提供了一种叫 SmoothWarmingUp 的策略，支持设置一个热身期，热身期内，RateLimiter 会平滑地将放令牌的速率加大，直致最大速率。设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存) 。RateLimiter 有一个缺点是只支持 QPS 级别。</p>\n<p><strong>漏桶、令牌桶的区别</strong></p>\n<p>虽然两者本质上只是反转了一下，不过在实际使用中，适用的场景稍有差别：</p>\n<p>1）漏桶：用于控制网络中的速率。在该算法中，输入速率可以变化，但输出速率保持恒定。常常配合一个 FIFO 队列使用。</p>\n<p>想象一下，漏桶的破洞是固定大小的，因此漏水的速率是可以保持恒定的。</p>\n<p>2）令牌桶：按照固定速率往桶中添加令牌，允许输出速率根据突发大小而变化。</p>\n<p>举个例子，一个系统限制 60 秒内的最大访问量是 60 次，换算速率是 1 次/秒，如果在一段时间内没有访问量，那么对漏桶而言此刻是空的。现在，一瞬间涌入 60 个请求，那么流量整形后，漏桶会以每秒 1 个请求的速度，花上 1 分钟将 60 个请求漏给下游。换成令牌桶的话，则是从令牌桶中一次性取走 60 个令牌，一下子塞给下游。</p>\n<h4 id=\"5-滑动日志\"><a href=\"#5-滑动日志\" class=\"headerlink\" title=\"5 滑动日志\"></a>5 滑动日志</h4><p>一般情况下，上述的算法已经能很好地用于大部分实际应用场景了，很少有场景需要真正完全精确的控制（即任意给定时间窗口T内请求量不大于 N ）。如果要精确控制的话，我们需要记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。这就是滑动日志的算法思路。</p>\n<p>设想某一个时刻 t 有一个请求，要判断是否允许，我们要看的其实是过去 t - N 时间段内是否有大于等于 N 个请求被放行，因此只要系统维护一个队列 q，里面记录每一个请求的时间，理论上就可以计算出从 t - N 时刻开始的请求数。</p>\n<p>考虑到只需关心当前时间之前最长 T 时间内的记录，因此队列 q 的长度可以动态变化，并且队列中最多只记录 N 条访问，因此队列长度的最大值为 N。</p>\n<blockquote>\n<p>滑动日志与滑动窗口非常像，区别在于滑动日志的滑动是根据日志记录的时间做动态滑动，而滑动窗口是根据子窗口的大小，以子窗口维度滑动。</p>\n</blockquote>\n<p><strong>伪代码实现</strong></p>\n<p>算法的伪代码表示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 初始化</span><br><span class=\"line\">counter = 0</span><br><span class=\"line\">q = []</span><br><span class=\"line\"></span><br><span class=\"line\"># 请求处理流程</span><br><span class=\"line\"># 1.找到队列中第一个时间戳&gt;=t-T的请求，即以当前时间t截止的时间窗口T内的最早请求</span><br><span class=\"line\">t = now</span><br><span class=\"line\">start = findWindowStart(q, t)</span><br><span class=\"line\"></span><br><span class=\"line\"># 2.截断队列，只保留最近T时间窗口内的记录和计数值</span><br><span class=\"line\">q = q[start, q.length - 1] </span><br><span class=\"line\">counter -= start</span><br><span class=\"line\"></span><br><span class=\"line\"># 3.判断是否放行，如果允许放行则将这次请求加到队列 q 的末尾</span><br><span class=\"line\">if counter &lt; threshold</span><br><span class=\"line\">    push(q, t)</span><br><span class=\"line\">    counter++</span><br><span class=\"line\">    # 放行</span><br><span class=\"line\">else</span><br><span class=\"line\">    # 限流</span><br></pre></td></tr></table></figure>\n\n<p>findWindowStart 的实现依赖于队列 q 使用的数据结构，以简单的数组为例，可以使用二分查找等方式。后面也会看到使用其他数据结构如何实现。</p>\n<p>如果用数组实现，一个难点可能是如何截断一个队列，一种可行的思路是使用一组头尾指针 head 和 tail 分别指向数组中最近和最早的有效记录索引来解决， findWindowStart 的实现就变成在 tail 和 head 之间查找对应元素。</p>\n<p><strong>复杂度问题</strong></p>\n<p>虽然算法解决了精确度问题，但代价也是显而易见的。</p>\n<p>首先，我们要保存一个长度最大为 N 的队列，这意味着空间复杂度达到 O(N)，如果要针对不同的 key 做流控，那么空间上会占用更多。当然，可以对不活跃 key 的队列进行复用来降低内存消耗。</p>\n<p>其次，我们需要在队列中确定时间窗口，即通过 findWindowStart 方法寻找不早于当前时间戳 t - N 的请求记录。以二分查找为例，时间复杂度是 O(logN)。</p>\n<h3 id=\"四-分布式流控\"><a href=\"#四-分布式流控\" class=\"headerlink\" title=\"四 分布式流控\"></a>四 分布式流控</h3><p>现实中的应用服务往往是分布式部署的，如果共用的资源（例如数据库）或者依赖的下游服务有流量限制，那么分布式流控就要派上用场了。</p>\n<p>虽然可以给每台应用服务器平均分配流控配额，把问题转换为单机流控，但如果碰到流量不均匀、机器宕机、临时扩缩容等场景，这种做法的效果不佳。</p>\n<p>分布式环境下做流控的核心算法思路其实与单机流控是一致的，区别在于需要实现一种同步机制来保证全局配额。同步机制的实现可以有中心化和去中心化两种思路：</p>\n<p>1）中心化：配额由一个中心系统统一管控，应用进程通过向中心系统申请的方式获取流控配额。</p>\n<ul>\n<li>状态的一致性在中心系统维护，实现简单。</li>\n<li>中心系统节点的不可用会导致流控出错，需要有额外的保护。例如，中心化流控在中心存储不可用时，往往会退化为单机流控。</li>\n</ul>\n<p>2）去中心化：应用进程独立保存和维护流控配额状态，集群内周期性异步通讯以保持状态一致。</p>\n<ul>\n<li>相比中心化方案，去中心化方案能够降低中心化单点可靠性带来的影响，但实现上比较复杂，状态的一致性难以保证。</li>\n<li>在 CAP 中去中心化更加倾向于 A 而中心化更倾向于 C。</li>\n</ul>\n<p>去中心化方案在生产环境中没有见过，因此下文只讨论中心化流控的思路。</p>\n<h4 id=\"1-接入层入口流控\"><a href=\"#1-接入层入口流控\" class=\"headerlink\" title=\"1 接入层入口流控\"></a>1 接入层入口流控</h4><p>应用接入的网络架构中，在应用服务器之前往往有一层 LVS 或 Nginx 做统一入口，可以在这一层做入口的流控。本质上这就是单机流控的场景。</p>\n<p>以 Nginx 为例，Nginx 提供了 ngx_http_limit_req_module 模块用于流控，底层使用的是漏桶算法。</p>\n<p>一个 Nginx 流控配置的示例如下，表示每个 IP 地址每秒只能请求 10 次 /login/ 接口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    location /login/ &#123;</span><br><span class=\"line\">        limit_req zone=mylimit;</span><br><span class=\"line\"></span><br><span class=\"line\">        proxy_pass http://my_upstream;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Nginx 的流控指令还支持更多配置，比如说配置 limit_req 指令时加上 burst 和 nodelay 参数来允许一定程度的突发，或者结合 geo 和 map 指令来实现黑白名单流控，具体可以参考 Nginx 官方文档：<br>Rate Limiting with NGINX and NGINX Plus（<a href=\"https://www.nginx.com/blog/rate-limiting-nginx/%EF%BC%89%E3%80%82\">https://www.nginx.com/blog/rate-limiting-nginx/）。</a></p>\n<p>如果自带的模块不能满足，那就上自定义的 lua 模块吧，参考 OpenResty 提供的 Lua 限流模块 lua-resty-limit-traffic。</p>\n<h4 id=\"2-TokenServer-流控\"><a href=\"#2-TokenServer-流控\" class=\"headerlink\" title=\"2 TokenServer 流控\"></a>2 TokenServer 流控</h4><blockquote>\n<p>这里借用了 Sentinel 中的 TokenServer 叫法，Sentinel 集群流控的介绍可以参考官方文档：Sentinel集群流控（<a href=\"https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%EF%BC%89%E3%80%82\">https://github.com/alibaba/Sentinel/wiki/集群流控）。</a></p>\n</blockquote>\n<p>这类流控的思路是找一个 TokenServer 来专门来管控流控配额，包括统计总调用量，判断单个请求是否允许等等，应用服务器作为客户端与 TokenServer 通信来获取配额。因为流控的逻辑在 TokenServer 内部统一处理，因此单机流控中讨论的算法同样适用。</p>\n<p>很自然地能想到，这类流控非常依赖于 TokenServer 的性能和可用性。</p>\n<p>性能方面，单点的 TokenServer 很容易成为瓶颈，查 Sentinel 源码，其中使用了 Netty 来做网络通信，数据包采用自定义格式，其他性能优化能找到的不多。</p>\n<p>可用性方面，就像 Sentinel 官方文档中讲的，若在生产环境使用 TokenServer 集群限流，必须要解决以下问题：</p>\n<p>Token Server 自动管理、调度（分配/选举 Token Server）</p>\n<p>Token Server 高可用，在某个 Server 不可用时自动 failover 到其它机器</p>\n<p>目前 Sentinel 的 TokenServer 默认并没有实现这些能力，需要定制或增加其他系统来实现，例如，采用一种分布式一致性协议来做集群选举，或者借助一组 monitor 来监控状态，实现成本还是挺高的。</p>\n<h4 id=\"3-存储式流控\"><a href=\"#3-存储式流控\" class=\"headerlink\" title=\"3 存储式流控\"></a>3 存储式流控</h4><p>存储式流控的思想是通过一个存储系统来保存流控的计数值等统计信息，应用从存储中获取统计信息，然后将最新的请求信息再写入存储中。存储系统可以选择现成的 MySQL 数据库或者 Redis 缓存等，一般从性能出发选择缓存的比较多。这里选择 Tair 和 Redis 做例子。</p>\n<p><strong>Tair 流控</strong></p>\n<p>比较简单，直接上代码实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean tryAcquire(String key) &#123;</span><br><span class=\"line\">  // 以秒为单位构建tair的key</span><br><span class=\"line\">  String wrappedKey = wrapKey(key);</span><br><span class=\"line\">  // 每次请求+1，初始值为0，key的有效期设置5s</span><br><span class=\"line\">  Result&lt;Integer&gt; result = tairManager.incr(NAMESPACE, wrappedKey, 1, 0, 5);</span><br><span class=\"line\">  return result.isSuccess() &amp;&amp; result.getValue() &lt;= threshold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private String wrapKey(String key) &#123;</span><br><span class=\"line\">  long sec = System.currentTimeMillis() / 1000L;</span><br><span class=\"line\">  return key + &quot;:&quot; + sec;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是感觉太简单了点？得益于 Tair 的高性能，这种方式可以很好地支撑大流量。</p>\n<p>这种 Tair 流控的方案实际上用的简单窗口的思路，每个 key 以每秒为一个时间窗口做 QPS 控制（QPM/QPD 原理类似）。关键在于用到了 Tair 的这个 API：</p>\n<blockquote>\n<p>incr</p>\n</blockquote>\n<p>Result incr(int namespace, Serializable key, int value, int defaultValue, int expireTime)<br>描述<br>增加计数。注意：incr 前不要 put！！<br>参数<br>namespace - 申请时分配的 namespace<br>key - key 列表，不超过 1k<br>value - 增加量<br>defaultValue - 第一次调用 incr 时的 key 的 count 初始值，第一次返回的值为 defaultValue + value。<br>expireTime - 数据过期时间，单位为秒，可设相对时间或绝对时间（Unix 时间戳）。expireTime = 0，表示数据永不过期。expireTime &gt; 0，表示设置过期时间。若 expireTime &gt; 当前时间的时间戳，则表示使用绝对时间，否则使用相对时间。expireTime &lt; 0，表示不关注过期时间，若之前设过过期时间，则已之前的过期时间为准，若没有，则作为永不过期处理，但当前 mdb 统一当做永不过期来处理。<br>返回值<br>Result 对象，返回值可为负值。当 key 不存在时，第一次返回 defaultValue+ value。后续的 incr 基于该值增加 value。</p>\n<p>当然这种方式也有缺点：</p>\n<ul>\n<li>简单窗口的临界突变问题。</li>\n<li>Tair 的可靠性问题，需要有降级方案。上面其实也说了，中心化的流控一般都需要搭配降级的单机流控。</li>\n<li>集群机器的时间同步问题。由于生成 key 会用到集群机器的本地时间，因此要求机器时间必须是一致的。</li>\n</ul>\n<p>打个比方，不同机器时间稍微差个 10ms，在时间窗口的间隔点上的统计就会产生比较大的误差，比如说在同一时刻，一台机器时间是 0.990，一台是 1.000，两者调用 incr 时操作的 key 不一样，精度自然就会受影响。</p>\n<p><strong>Redis 流控</strong></p>\n<p>Redis 支持丰富的数据结构，性能也不错，其“单进程”模型方便同步控制，因此非常适合用来做分布式流控的存储。</p>\n<p>1）简单窗口实现</p>\n<p>使用 Redis 实现简单窗口流控的思路跟使用 Tair 是一致的。Redis 也提供了 INCR 命令用于计数，同时 Redis 的“单进程”模型也提供了很好的并发保护。Redis 的官方文档就写了如何使用 INCR 来实现 Rate Limiter，我这里稍作翻译了下：</p>\n<blockquote>\n<p>Redis INCR key(<a href=\"https://redis.io/commands/incr\">https://redis.io/commands/incr</a>)</p>\n</blockquote>\n<p>以简单窗口为例，最简单直接的实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FUNCTION LIMIT_API_CALL(ip)</span><br><span class=\"line\">ts = CURRENT_UNIX_TIME()</span><br><span class=\"line\">keyname = ip+&quot;:&quot;+ts</span><br><span class=\"line\">current = GET(keyname)</span><br><span class=\"line\">IF current != NULL AND current &gt; 10 THEN</span><br><span class=\"line\">    ERROR &quot;too many requests per second&quot;</span><br><span class=\"line\">ELSE</span><br><span class=\"line\">    MULTI</span><br><span class=\"line\">        INCR(keyname,1)</span><br><span class=\"line\">        EXPIRE(keyname,10)</span><br><span class=\"line\">    EXEC</span><br><span class=\"line\">    PERFORM_API_CALL()</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>实现上与上述的 Tair 类似，也是对每个 key 以秒为单位维护一个计数器，差别在于因为 Redis 没有提供原子的 INCR + EXPIRE 指令，所以在 INCR 之后需要再调用一次 EXPIRE 来设置 key 的有效期。同时在外层以 MULTI 和 EXEC 包裹以保证事务性。</p>\n<p>如果不想每次都调用 EXPIRE，可以考虑第二种方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FUNCTION LIMIT_API_CALL(ip):</span><br><span class=\"line\">current = GET(ip)</span><br><span class=\"line\">IF current != NULL AND current &gt; 10 THEN</span><br><span class=\"line\">    ERROR &quot;too many requests per second&quot;</span><br><span class=\"line\">ELSE</span><br><span class=\"line\">    value = INCR(ip)</span><br><span class=\"line\">    IF value == 1 THEN</span><br><span class=\"line\">        EXPIRE(ip,1)</span><br><span class=\"line\">    END</span><br><span class=\"line\">    PERFORM_API_CALL()</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>计数器的有效期在第一次 INCR 时设置为 1s，因此不需要对 key 进行额外处理。</p>\n<p>不过需要注意的是，这种方式存在一种隐藏的竞争条件。如果客户端在第一次调用了 INCR 后，由于应用崩溃或其他原因没有调用 EXPIRE，计数器会一直存在。</p>\n<p>针对方式二的这个问题，可以用 lua 脚本解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local current</span><br><span class=\"line\">current = redis.call(&quot;incr&quot;,KEYS[1])</span><br><span class=\"line\">if tonumber(current) == 1 then</span><br><span class=\"line\">    redis.call(&quot;expire&quot;,KEYS[1],1)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>第三种方式是通过 Redis 的 list 结构来实现。更复杂一些但可以记录下每次的请求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FUNCTION LIMIT_API_CALL(ip)</span><br><span class=\"line\">current = LLEN(ip)</span><br><span class=\"line\">IF current &gt; 10 THEN</span><br><span class=\"line\">    ERROR &quot;too many requests per second&quot;</span><br><span class=\"line\">ELSE</span><br><span class=\"line\">    IF EXISTS(ip) == FALSE              #1</span><br><span class=\"line\">        MULTI</span><br><span class=\"line\">            RPUSH(ip,ip)</span><br><span class=\"line\">            EXPIRE(ip,1)</span><br><span class=\"line\">        EXEC</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">        RPUSHX(ip,ip)</span><br><span class=\"line\">    END</span><br><span class=\"line\">    PERFORM_API_CALL()</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>这里也有一个隐含的竞争条件，在执行到 EXIST 判断这一行（#1 位置）时，两个客户端的 EXIST 命令可能都会返回 false，因此 MULTI/EXEC 块里的命令会被执行两次，不过这种情况很少出现，不太会影响计数器的准确性。</p>\n<p>上述的几种方式还可以进一步优化，因为 INCR 和 RPUSH 这些命令都会返回操作后的计数器值，所以可以使用 set-then-get 的方式获取计数器值。</p>\n<p>将简单窗口改造成滑动窗口也是类似的思路，把单一的 key 换成一个 hash 结构，hash 里面为每个子窗口保存一个计数值，在统计时，将同个 hash 中所有子窗口的计数值相加即可。</p>\n<p>2）令牌桶/漏桶实现</p>\n<p>用 Redis 实现令牌桶或者漏桶也非常简单。以令牌桶为例，在实现上，可以用两个 key 分别存储每个用户的可用 token 数和上次请求时间，另一种可能更好的办法是使用 Redis 的 hash 数据结构。</p>\n<p>下图的示例是一个用户 user_1 当前在 Redis 中保存的流控配额数据：令牌桶中当前剩余 2 个 token，最近一次访问的时间戳是 1490868000。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/7a12af696eef4851ab16afb0d44426ea.png\" alt=\"image.png\"></p>\n<p>当收到一个新请求时，Redis 客户端要执行的操作与我们在单机流控算法中看到的一样。首先，从对应 hash 中获得当前配额数据（HGETALL），根据当前时间戳、上次请求的时间戳和 token 填充速度计算要填充的 token 数；然后，判断是否放行，更新新的时间戳和 token 数（HMSET）。</p>\n<p>一个示例如下：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/2e0a53670860429faca7b77337931117.png\" alt=\"image.png\"></p>\n<p>同样的，如果要求比较高的精度，这里必须要对客户端的操作做并发控制。</p>\n<p>不做同步控制可能导致的问题示例：桶里只有一个 token，两个客户端同时请求时出现并发冲突，结果是请求都会放行。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/c86cda7753e4469b8f517da77be5a4af.png\" alt=\"image.png\"></p>\n<p>lua 代码示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local tokens_key = KEYS[1]</span><br><span class=\"line\">local timestamp_key = KEYS[2]</span><br><span class=\"line\"></span><br><span class=\"line\">local rate = tonumber(ARGV[1])</span><br><span class=\"line\">local capacity = tonumber(ARGV[2])</span><br><span class=\"line\">local now = tonumber(ARGV[3])</span><br><span class=\"line\">local requested = tonumber(ARGV[4])</span><br><span class=\"line\"></span><br><span class=\"line\">local fill_time = capacity/rate</span><br><span class=\"line\">local ttl = math.floor(fill_time*2)</span><br><span class=\"line\"></span><br><span class=\"line\">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span><br><span class=\"line\">if last_tokens == nil then</span><br><span class=\"line\">  last_tokens = capacity</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span><br><span class=\"line\">if last_refreshed == nil then</span><br><span class=\"line\">  last_refreshed = 0</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">local delta = math.max(0, now-last_refreshed)</span><br><span class=\"line\">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span><br><span class=\"line\">local allowed = filled_tokens &gt;= requested</span><br><span class=\"line\">local new_tokens = filled_tokens</span><br><span class=\"line\">if allowed then</span><br><span class=\"line\">  new_tokens = filled_tokens - requested</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span><br><span class=\"line\">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123; allowed, new_tokens &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）滑动日志实现</p>\n<p>得益于 Redis 的 Sorted Set 结构，实现滑动日志变得异常简单。流程大致如下：</p>\n<p>a）每个用户有一个对应的 Sorted Set 记录请求日志。</p>\n<ul>\n<li>其中每个元素的 key 和 value 可以是相同的，即请求的时间戳。</li>\n<li>Sorted Set 可以根据时间窗口大小设置有效期，比如时间窗口为 1s 时设置过期时间 5s，在请求量不大时可以节省 Redis 服务器内存。</li>\n</ul>\n<p>b）当收到一个新的用户请求时，首先通过 ZREMRANGEBYSCORE 命令删除 Sorted Set 中过期的元素，这里的过期即：</p>\n<p>请求时间戳 t &lt; 当前时间戳 now - 时间窗口大小 interval</p>\n<p>c）使用 ZADD 将当前请求添加到 Set 中。</p>\n<p>d）使用 ZCOUNT 获取当前剩余 Set 大小，判断是否需要流控。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long now = System.currentTimeMillis();</span><br><span class=\"line\">long maxScoreMs = now - windowInSecond * 1000;</span><br><span class=\"line\"></span><br><span class=\"line\">Transaction redis = jedisPool.getResource().multi();</span><br><span class=\"line\">redis.zremrangeByScore(key, 0, maxScoreMs);</span><br><span class=\"line\">redis.zadd(key, now, now + &quot;-&quot; + Math.random()); // 加入一个随机值使得member不重复</span><br><span class=\"line\">redis.expire(key, windowInSecond);</span><br><span class=\"line\">redis.exec();</span><br></pre></td></tr></table></figure>\n\n<p>另一个 JS 实现的代码示例：<br><a href=\"https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js\">https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js</a></p>\n<p>由于滑动日志算法的空间复杂度较其他算法高，使用滑动日志算法时，需要注意监控 Redis 内存的使用量。</p>\n<p>4）并发控制</p>\n<p>上面的几种算法都提到了不做并发控制可能带来的竞态条件，但额外的并发控制必然会带来性能下降，通常需要在精度和性能之间做取舍。Redis 流控的并发控制常见的有几类：</p>\n<ul>\n<li>使用 Redis 事务 MULTI/EXEC。</li>\n<li>使用 RedLock（<a href=\"https://redis.io/topics/distlock%EF%BC%89\">https://redis.io/topics/distlock）</a> 等分布式锁，要求每个客户端操作前先获取对应 key 的分布式锁。</li>\n<li>Lua 脚本。</li>\n</ul>\n<p>最好通过性能测试来决定使用哪一种方式。</p>\n<h4 id=\"4-扩展的一些思考\"><a href=\"#4-扩展的一些思考\" class=\"headerlink\" title=\"4 扩展的一些思考\"></a>4 扩展的一些思考</h4><p>分布式流控带来了网络通信、加锁同步等开销，会对性能带来一定影响。同时分布式环境的可靠性也会带来更多挑战。如何设计一个高性能、高可靠性的分布式流控系统？这可能是个涉及到整个系统方方面面的大话题。</p>\n<p>分享一下个人的一些思考，欢迎讨论：</p>\n<p>1）根据实际诉求，合理搭配不同层的多级流控是个不错的方式，尽量把流量拦在外层。例如常见的接口层 Nginx 流控 + 应用层流控。</p>\n<p>2）选择一个合适的缓存系统保存流控的动态数据，这个一般跟着公司的统一技术架构走。</p>\n<p>3）将流控的静态配置放到配置中心（例如 Diamond）。</p>\n<p>4）设计时要考虑分布式流控不可用的情况（例如缓存挂掉），必要时切到单机流控，使用 Sentinel 成熟可靠。</p>\n<p>5）很多时候对精度的要求没那么高，因为一般都会允许一定的突发量。这时候可以做一些性能的优化。性能的最大瓶颈在于每次请求都会访问一次缓存，我之前在设计时就采用了一种折中的办法：</p>\n<ul>\n<li>将可用配额的一部分，按一定比例（例如 50%），先预分配给集群内的机器。一般是平均分配，如果预先就已经知道每台机器的流量权重，可以加权分配。每台机器消耗配额的速率不同，中间也可能有机器宕机，可能有扩缩容，因此预分配的比例不宜太大，当然也不宜太小。</li>\n<li>每台机器在配额耗尽时，向中心系统请求配额，这里的一个优化点是每台机器会记录自身配额消耗的速率（等同于承受的流量速率），按照速率大小申请不同大小的配额，消耗速率大则一次性申请更多。</li>\n<li>在整体可用配额不足一定比例时（例如 10%），限制每台机器一次可申请的配额数，按剩余窗口大小计算发放配额的大小，并且每次发放量不超过剩余配额的一定比例（例如 50%），使得剩余的流量能够平滑地过渡。</li>\n</ul>\n<p>五 总结</p>\n<p>分布式流控的算法其实是单机流控的延伸，算法本质是一样的。这里按我的个人理解总结了上述几种流控算法的复杂度和适用场景。<br><img src=\"https://ucc.alicdn.com/pic/developer-ecology/4ba212a1a7de40a6ba7601faa653b4d9.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"<p>转载自：<a href=\"https://developer.aliyun.com/article/765912\">https://developer.aliyun.com/article/765912</a></p>\n<h3 id=\"一-流控的场景\"><a href=\"#一-流控的场景\" class=\"headerlink\" title=\"一 流控的场景\"></a>一 流控的场景</h3><p>流控的意义其实无需多言了。最常用的场景下，流控是为了保护下游有限的资源不被流量冲垮，保证服务的可用性，一般允许流控的阈值有一定的弹性，偶尔的超量访问是可以接受的。</p>\n<p>有的时候，流控服务于收费模式，比如某些云厂商会对调用 API 的频次进行计费。既然涉及到钱，一般就不允许有超出阈值的调用量。</p>\n<p>这些不同的场景下，适用的流控算法不尽相同。大多数情况下，使用 Sentinel 中间件已经能很好地应对，但 Sentinel 也并不是万能的，需要思考其他的流控方案。</p>","more":"<h3 id=\"二-接口定义\"><a href=\"#二-接口定义\" class=\"headerlink\" title=\"二 接口定义\"></a>二 接口定义</h3><p>为了方便，以下所有的示例代码实现都是基于 Throttler 接口。</p>\n<p>Throttler 接口定义了一个通用的方法用于申请单个配额。</p>\n<p>当然你也可以定义一个 tryAcquire(String key, int permits) 签名的方法用于一次申请多个配额，实现的思路是一样的。</p>\n<p>有些流控算法需要为每个 key 维护一个 Throttler 实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Throttler &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 尝试申请一个配额</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param key     申请配额的key</span><br><span class=\"line\">     * @return 申请成功则返回true，否则返回false</span><br><span class=\"line\">     */</span><br><span class=\"line\">    boolean tryAcquire(String key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三-单机流控\"><a href=\"#三-单机流控\" class=\"headerlink\" title=\"三 单机流控\"></a>三 单机流控</h3><h4 id=\"1-简单窗口\"><a href=\"#1-简单窗口\" class=\"headerlink\" title=\"1 简单窗口\"></a>1 简单窗口</h4><blockquote>\n<p>简单窗口是我自己的命名，有些地方也叫做固定窗口，主要是为了跟后面的滑动窗口区分。</p>\n</blockquote>\n<p>流控是为了限制指定时间间隔内能够允许的访问量，因此，最直观的思路就是基于一个给定的时间窗口，维护一个计数器用于统计访问次数，然后实现以下规则：</p>\n<ul>\n<li>如果访问次数小于阈值，则代表允许访问，访问次数 +1。</li>\n<li>如果访问次数超出阈值，则限制访问，访问次数不增。</li>\n<li>如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。这样就确保计数器统计的是最近一个窗口的访问量。</li>\n</ul>\n<p><strong>代码实现 SimpleWindowThrottler</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 毫秒为单位的时间窗口</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final long windowInMs;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 时间窗口内最大允许的阈值</span><br><span class=\"line\"> */</span><br><span class=\"line\">private final int threshold;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 最后一次成功请求时间</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long lastReqTime = System.currentTimeMillis();</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 计数器</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long counter;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean tryAcquire(String key) &#123;</span><br><span class=\"line\">    long now = System.currentTimeMillis();</span><br><span class=\"line\">    // 如果当前时间已经超过了上一次访问时间开始的时间窗口，重置计数器，以当前时间作为新窗口的起始值</span><br><span class=\"line\">    if (now - lastReqTime &gt; windowInMs) &#123;       #1</span><br><span class=\"line\">        counter = 0;</span><br><span class=\"line\">        lastReqTime = now;                  #2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (counter &lt; threshold) &#123;                  #3</span><br><span class=\"line\">        counter++;                          #4</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种常见的场景是根据不同的 key 来做流控，每个 key 有单独的时间窗口、阈值配置，因此需要为每个 key 维护一个单独的限流器实例。</p>\n<p><strong>切换到多线程环境</strong><br>在现实应用中，往往是多个线程来同时申请配额，为了比较简洁地表达算法思路，示例代码里面都没有做并发同步控制。</p>\n<p>以简单窗口的实现为例，要转换为多线程安全的流控算法，一种直接的办法是将 tryAcquire 方法设置为 synchronized。</p>\n<p>当然一种感觉上更高效的办法也可以是修改读写变量的类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private volatile long lastReqTime = System.currentTimeMillis();</span><br><span class=\"line\">private LongAdder counter = new LongAdder();</span><br></pre></td></tr></table></figure>\n\n<p>不过这样其实并不真正“安全”，设想以下的场景，两个线程 A、线程 B 前后脚尝试获取配额，#1 位置的判断条件满足后，会同时走到 #2 位置修改 lastReqTime 值，线程 B 的赋值会覆盖线程 A，导致时间窗口起始点向后偏移。同样的，位置 #3 和 #4 也会构成竞争条件。当然如果对流控的精度要求不高，这种竞争也是能接受的。</p>\n<p><strong>临界突变问题</strong></p>\n<p>简单窗口的流控实现非常简单，以 1 分钟允许 100 次访问为例，如果流量均匀保持 200 次/分钟的访问速率，系统的访问量曲线大概是这样的（按分钟清零）：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/55c271e1437d49e2822a5f3114659474.png\" alt=\"image.png\"></p>\n<p>但如果流量并不均匀，假设在时间窗口开始时刻 0:00 有几次零星的访问，一直到 0:50 时刻，开始以 10 次/秒的速度请求，就会出现这样的访问量图线：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/71496c33553043328fd24f9e6c58a352.png\" alt=\"image.png\"></p>\n<p>在临界的 20 秒内（0:50~1:10）系统承受的实际访问量是 200 次，换句话说，最坏的情况下，在窗口临界点附近系统会承受 2 倍的流量冲击，这就是简单窗口不能解决的临界突变问题。</p>\n<h4 id=\"2-滑动窗口\"><a href=\"#2-滑动窗口\" class=\"headerlink\" title=\"2 滑动窗口\"></a>2 滑动窗口</h4><p>如何解决简单窗口算法的临界突变问题？既然一个窗口统计的精度低，那么可以把整个大的时间窗口切分成更细粒度的子窗口，每个子窗口独立统计。同时，每过一个子窗口大小的时间，就向右滑动一个子窗口。这就是滑动窗口算法的思路。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/64e7d74023a84b75a17fc320b152fa27.png\" alt=\"image.png\"></p>\n<p>如上图所示，将一分钟的时间窗口切分成 6 个子窗口，每个子窗口维护一个独立的计数器用于统计 10 秒内的访问量，每经过 10s，时间窗口向右滑动一格。</p>\n<p>回到简单窗口出现临界跳变的例子，结合上面的图再看滑动窗口如何消除临界突变。如果 0:50 到 1:00 时刻（对应灰色的格子）进来了 100 次请求，接下来 1:00~1:10 的 100 次请求会落到黄色的格子中，由于算法统计的是 6 个子窗口的访问量总和，这时候总和超过设定的阈值 100，就会拒绝后面的这 100 次请求。</p>\n<p><strong>代码实现（参考 Sentinel）</strong></p>\n<p>Sentinel 提供了一个轻量高性能的滑动窗口流控算法实现，看代码的时候可以重点关注这几个类：</p>\n<p>1）功能插槽 StatisticSlot 负责记录、统计不同纬度的 runtime 指标监控信息，例如 RT、QPS 等。</p>\n<p>Sentinel 内部使用了 slot chain 的责任链设计模式，每个功能插槽 slot 有不同的功能（限流、降级、系统保护），通过 ProcessorSlotChain 串联在一起。</p>\n<p>参考官方 Wiki：<br><a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel%E5%B7%A5%E4%BD%9C%E4%B8%BB%E6%B5%81%E7%A8%8B\">https://github.com/alibaba/Sentinel/wiki/Sentinel工作主流程</a></p>\n<p>2）StatisticSlot 使用 StatisticNode#addPassRequest 记录允许的请求数，包含秒和分钟两个维度。</p>\n<p>3）具体记录用到的是 Metric 接口，对应实现类 ArrayMetric，背后真正的滑动窗口数据结构是 LeapArray 。</p>\n<p>4）LeapArray 内部维护了滑动窗口用到的关键属性和结构，包括：</p>\n<p>a）总窗口大小 intervalInMs，滑动子窗口大小 windowLengthInMs，采样数量sampleCount：</p>\n<p>sampleCount = intervalInMs / windowLengthInMs</p>\n<p>当前实现默认为 2，而总窗口大小默认是 1s，也就意味着默认的滑动窗口大小是 500ms。可以通过调整采样数量来调整统计的精度。</p>\n<p>b）滑动窗口的数组 array，数组中每个元素以 WindowWrap 表示，其中包含：</p>\n<ul>\n<li>windowStart：滑动窗口的开始时间。</li>\n<li>windowLength：滑动窗口的长度。</li>\n<li>value：滑动窗口记录的内容，泛型表示，关键的一类就是 MetricBucket，里面包含了一组 LongAdder 用于记录不同类型的数据，例如请求通过数、请求阻塞数、请求异常数等等。</li>\n</ul>\n<p>记录请求的逻辑说白了，就是根据当前时间获取所属的滑动窗口，然后将该窗口的统计值 +1 即可。但实际上，获取当前所属的时间窗口这一步隐含了不少细节，详细的实现可以从 LeapArray#currentWindow 中找到，源码的注释写得很详细，这里就不多提了。</p>\n<p>这里借助一张其他同学画的图表述以上的流程：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/94326f15088f4750acd811ec75b43252.png\" alt=\"image.png\"></p>\n<p>以上的流程基于 3.9.21 版本的源码，早先版本的 Sentinel 内部版本实现不尽相同，使用了一个叫 SentinelRollingNumber 的数据结构，但原理是类似的。</p>\n<p><strong>精度问题</strong></p>\n<p>现在思考这么一个问题：滑动窗口算法能否精准地控制任意给定时间窗口 T 内的访问量不大于 N？</p>\n<p>答案是否定的，还是将 1 分钟分成 6 个 10 秒大小的子窗口的例子，假设请求的速率现在是 20 次/秒，从 0:05 时刻开始进入，那么在 0:05<del>0:10 时间段内会放进 100 个请求，同时接下来的请求都会被限流，直到 1:00 时刻窗口滑动，在 1:00</del>1:05 时刻继续放进 100 个请求。如果把 0:05~1:05 看作是 1 分钟的时间窗口，那么这个窗口内实际的请求量是 200，超出了给定的阈值 100。</p>\n<p>如果要追求更高的精度，理论上只需要把滑动窗口切分得更细。像 Sentinel 中就可以通过修改单位时间内的采样数量 sampleCount 值来设置精度，这个值一般根据业务的需求来定，以达到在精度和内存消耗之间的平衡。</p>\n<p><strong>平滑度问题</strong></p>\n<p>使用滑动窗口算法限制流量时，我们经常会看到像下面一样的流量曲线。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/d80a395b5cb24ca59f2b97d4fb55893e.png\" alt=\"image.png\"></p>\n<p>突发的大流量在窗口开始不久就直接把限流的阈值打满，导致剩余的窗口内所有请求都无法通过。在时间窗口的单位比较大时（例如以分为单位进行流控），这种问题的影响就比较大了。在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。</p>\n<h4 id=\"3-漏桶\"><a href=\"#3-漏桶\" class=\"headerlink\" title=\"3 漏桶\"></a>3 漏桶</h4><p>滑动窗口无法很好地解决平滑度问题，再回过头看我们对于平滑度的诉求，当流量超过一定范围后，我们想要的效果不是一下子切断流量，而是将流量控制在系统能承受的一定的速度内。假设平均访问速率为 v, 那我们要做的流控其实是流速控制，即控制平均访问速率 v ≤ N / T。</p>\n<p>在网络通信中常常用到漏桶算法来实现流量整形。漏桶算法的思路就是基于流速来做控制。想象一下上学时经常做的水池一边抽水一边注水的应用题，把水池换成水桶（还是底下有洞一注水就开始漏的那种），把请求看作是往桶里注水，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃的请求。在概念上类比：</p>\n<ul>\n<li>最大允许请求数 N：桶的大小</li>\n<li>时间窗口大小 T：一整桶水漏完的时间</li>\n<li>最大访问速率 V：一整桶水漏完的速度，即 N/T</li>\n<li>请求被限流：桶注水的速度比漏水的速度快，最终导致桶内水溢出</li>\n</ul>\n<p>假设起始时刻桶是空的，每次访问都会往桶里注入一单位体积的水量，那么当我们以小于等于 N/T 的速度往桶里注水时，桶内的水就永远不会溢出。反之，一旦实际注水速度超过漏水速度，桶里就会产生越来越多的积水，直到溢出为止。同时漏水的速度永远被控制在 N/T 以内，这就实现了平滑流量的目的。</p>\n<p>漏桶算法的访问速率曲线如下：<br><img src=\"https://ucc.alicdn.com/pic/developer-ecology/68127312b88a4bb3ac0b4a1caf297f6c.png\" alt=\"image.png\"></p>\n<p>附上一张网上常见的漏桶算法原题图：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/1299847fdcb042289fa10067ab074949.png\" alt=\"image.png\"></p>\n<p><strong>代码实现 LeakyBucketThrottler</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 当前桶内剩余的水</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long left;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 上次成功注水的时间戳</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long lastInjectTime = System.currentTimeMillis();</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 桶的容量</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long capacity;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 一桶水漏完的时间</span><br><span class=\"line\"> */</span><br><span class=\"line\">private long duration;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 桶漏水的速度，即 capacity / duration</span><br><span class=\"line\"> */</span><br><span class=\"line\">private double velocity;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean tryAcquire(String key) &#123;</span><br><span class=\"line\">    long now = System.currentTimeMillis();</span><br><span class=\"line\">    // 当前剩余的水 = 之前的剩余水量 - 过去这段时间内漏掉的水量</span><br><span class=\"line\">    // 过去这段时间内漏掉的水量 = (当前时间-上次注水时间) * 漏水速度</span><br><span class=\"line\">    // 如果当前时间相比上次注水时间相隔太久（一直没有注水），桶内的剩余水量就是0（漏完了）</span><br><span class=\"line\">    left = Math.max(0, left - (long)((now - lastInjectTime) * velocity));</span><br><span class=\"line\">    // 往当前水量基础上注一单位水，只要没有溢出就代表可以访问</span><br><span class=\"line\">    if (left + 1 &lt;= capacity) &#123;</span><br><span class=\"line\">        lastInjectTime = now;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>漏桶的问题</strong></p>\n<p>漏桶的优势在于能够平滑流量，如果流量不是均匀的，那么漏桶算法与滑动窗口算法一样无法做到真正的精确控制。极端情况下，漏桶在时间窗口 T 内也会放进相当于 2 倍阈值 N 的流量。</p>\n<p>设想一下，如果访问量相比窗口大小 N 大很多，在窗口（0~T）一开始的 0 时刻就直接涌进来，使得漏桶在时间 t（ 0≈t</p>\n<p>虽然可以通过限制桶大小的方式使得访问量控制在 N 以内，但这样做的副作用是流量在还未达到限制条件就被禁止。</p>\n<p>还有一个隐含的约束是，漏桶漏水的速度最好是一个整数值（即容量 N 能够整除时间窗口大小 T ），否则在计算剩余水量时会有些许误差。</p>\n<h4 id=\"4-令牌桶\"><a href=\"#4-令牌桶\" class=\"headerlink\" title=\"4 令牌桶\"></a>4 令牌桶</h4><p>漏桶模型中，请求来了是往桶里注水，如果反一下，把请求放行变成从桶里抽水，对应的，把注水看作是补充系统可承受流量的话，漏桶模型就变成了令牌桶模型。</p>\n<p>理解漏桶之后，再看令牌桶就很简单了，抄一段令牌桶的原理：</p>\n<blockquote>\n<p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>\n</blockquote>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/c17f0f04ac0642cd8764e477b0880e26.png\" alt=\"image.png\"></p>\n<p><strong>代码实现 TokenBucketThrottler</strong></p>\n<p>令牌桶与漏桶本质上是一样的，因此漏桶的代码稍微改下就可以变成令牌桶。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long now = System.currentTimeMillis();</span><br><span class=\"line\">left = Math.min(capacity, left + (long)((now - lastInjectTime) * velocity));</span><br><span class=\"line\">if (left - 1 &gt; 0) &#123;</span><br><span class=\"line\">    lastInjectTime = now;</span><br><span class=\"line\">    left--;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生产环境中使用令牌桶的话，可以考虑借助 Guava 中提供的 RateLimiter。它的实现是多线程安全的，调用 RateLimiter#acquire 时，如果剩余令牌不足，会阻塞线程一段时间直至有足够的可用令牌（而不是直接拒绝，这在某些场景下很有用）。除去默认的 SmoothBursty 策略外，RateLimiter 还提供了一种叫 SmoothWarmingUp 的策略，支持设置一个热身期，热身期内，RateLimiter 会平滑地将放令牌的速率加大，直致最大速率。设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存) 。RateLimiter 有一个缺点是只支持 QPS 级别。</p>\n<p><strong>漏桶、令牌桶的区别</strong></p>\n<p>虽然两者本质上只是反转了一下，不过在实际使用中，适用的场景稍有差别：</p>\n<p>1）漏桶：用于控制网络中的速率。在该算法中，输入速率可以变化，但输出速率保持恒定。常常配合一个 FIFO 队列使用。</p>\n<p>想象一下，漏桶的破洞是固定大小的，因此漏水的速率是可以保持恒定的。</p>\n<p>2）令牌桶：按照固定速率往桶中添加令牌，允许输出速率根据突发大小而变化。</p>\n<p>举个例子，一个系统限制 60 秒内的最大访问量是 60 次，换算速率是 1 次/秒，如果在一段时间内没有访问量，那么对漏桶而言此刻是空的。现在，一瞬间涌入 60 个请求，那么流量整形后，漏桶会以每秒 1 个请求的速度，花上 1 分钟将 60 个请求漏给下游。换成令牌桶的话，则是从令牌桶中一次性取走 60 个令牌，一下子塞给下游。</p>\n<h4 id=\"5-滑动日志\"><a href=\"#5-滑动日志\" class=\"headerlink\" title=\"5 滑动日志\"></a>5 滑动日志</h4><p>一般情况下，上述的算法已经能很好地用于大部分实际应用场景了，很少有场景需要真正完全精确的控制（即任意给定时间窗口T内请求量不大于 N ）。如果要精确控制的话，我们需要记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。这就是滑动日志的算法思路。</p>\n<p>设想某一个时刻 t 有一个请求，要判断是否允许，我们要看的其实是过去 t - N 时间段内是否有大于等于 N 个请求被放行，因此只要系统维护一个队列 q，里面记录每一个请求的时间，理论上就可以计算出从 t - N 时刻开始的请求数。</p>\n<p>考虑到只需关心当前时间之前最长 T 时间内的记录，因此队列 q 的长度可以动态变化，并且队列中最多只记录 N 条访问，因此队列长度的最大值为 N。</p>\n<blockquote>\n<p>滑动日志与滑动窗口非常像，区别在于滑动日志的滑动是根据日志记录的时间做动态滑动，而滑动窗口是根据子窗口的大小，以子窗口维度滑动。</p>\n</blockquote>\n<p><strong>伪代码实现</strong></p>\n<p>算法的伪代码表示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 初始化</span><br><span class=\"line\">counter = 0</span><br><span class=\"line\">q = []</span><br><span class=\"line\"></span><br><span class=\"line\"># 请求处理流程</span><br><span class=\"line\"># 1.找到队列中第一个时间戳&gt;=t-T的请求，即以当前时间t截止的时间窗口T内的最早请求</span><br><span class=\"line\">t = now</span><br><span class=\"line\">start = findWindowStart(q, t)</span><br><span class=\"line\"></span><br><span class=\"line\"># 2.截断队列，只保留最近T时间窗口内的记录和计数值</span><br><span class=\"line\">q = q[start, q.length - 1] </span><br><span class=\"line\">counter -= start</span><br><span class=\"line\"></span><br><span class=\"line\"># 3.判断是否放行，如果允许放行则将这次请求加到队列 q 的末尾</span><br><span class=\"line\">if counter &lt; threshold</span><br><span class=\"line\">    push(q, t)</span><br><span class=\"line\">    counter++</span><br><span class=\"line\">    # 放行</span><br><span class=\"line\">else</span><br><span class=\"line\">    # 限流</span><br></pre></td></tr></table></figure>\n\n<p>findWindowStart 的实现依赖于队列 q 使用的数据结构，以简单的数组为例，可以使用二分查找等方式。后面也会看到使用其他数据结构如何实现。</p>\n<p>如果用数组实现，一个难点可能是如何截断一个队列，一种可行的思路是使用一组头尾指针 head 和 tail 分别指向数组中最近和最早的有效记录索引来解决， findWindowStart 的实现就变成在 tail 和 head 之间查找对应元素。</p>\n<p><strong>复杂度问题</strong></p>\n<p>虽然算法解决了精确度问题，但代价也是显而易见的。</p>\n<p>首先，我们要保存一个长度最大为 N 的队列，这意味着空间复杂度达到 O(N)，如果要针对不同的 key 做流控，那么空间上会占用更多。当然，可以对不活跃 key 的队列进行复用来降低内存消耗。</p>\n<p>其次，我们需要在队列中确定时间窗口，即通过 findWindowStart 方法寻找不早于当前时间戳 t - N 的请求记录。以二分查找为例，时间复杂度是 O(logN)。</p>\n<h3 id=\"四-分布式流控\"><a href=\"#四-分布式流控\" class=\"headerlink\" title=\"四 分布式流控\"></a>四 分布式流控</h3><p>现实中的应用服务往往是分布式部署的，如果共用的资源（例如数据库）或者依赖的下游服务有流量限制，那么分布式流控就要派上用场了。</p>\n<p>虽然可以给每台应用服务器平均分配流控配额，把问题转换为单机流控，但如果碰到流量不均匀、机器宕机、临时扩缩容等场景，这种做法的效果不佳。</p>\n<p>分布式环境下做流控的核心算法思路其实与单机流控是一致的，区别在于需要实现一种同步机制来保证全局配额。同步机制的实现可以有中心化和去中心化两种思路：</p>\n<p>1）中心化：配额由一个中心系统统一管控，应用进程通过向中心系统申请的方式获取流控配额。</p>\n<ul>\n<li>状态的一致性在中心系统维护，实现简单。</li>\n<li>中心系统节点的不可用会导致流控出错，需要有额外的保护。例如，中心化流控在中心存储不可用时，往往会退化为单机流控。</li>\n</ul>\n<p>2）去中心化：应用进程独立保存和维护流控配额状态，集群内周期性异步通讯以保持状态一致。</p>\n<ul>\n<li>相比中心化方案，去中心化方案能够降低中心化单点可靠性带来的影响，但实现上比较复杂，状态的一致性难以保证。</li>\n<li>在 CAP 中去中心化更加倾向于 A 而中心化更倾向于 C。</li>\n</ul>\n<p>去中心化方案在生产环境中没有见过，因此下文只讨论中心化流控的思路。</p>\n<h4 id=\"1-接入层入口流控\"><a href=\"#1-接入层入口流控\" class=\"headerlink\" title=\"1 接入层入口流控\"></a>1 接入层入口流控</h4><p>应用接入的网络架构中，在应用服务器之前往往有一层 LVS 或 Nginx 做统一入口，可以在这一层做入口的流控。本质上这就是单机流控的场景。</p>\n<p>以 Nginx 为例，Nginx 提供了 ngx_http_limit_req_module 模块用于流控，底层使用的是漏桶算法。</p>\n<p>一个 Nginx 流控配置的示例如下，表示每个 IP 地址每秒只能请求 10 次 /login/ 接口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    location /login/ &#123;</span><br><span class=\"line\">        limit_req zone=mylimit;</span><br><span class=\"line\"></span><br><span class=\"line\">        proxy_pass http://my_upstream;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Nginx 的流控指令还支持更多配置，比如说配置 limit_req 指令时加上 burst 和 nodelay 参数来允许一定程度的突发，或者结合 geo 和 map 指令来实现黑白名单流控，具体可以参考 Nginx 官方文档：<br>Rate Limiting with NGINX and NGINX Plus（<a href=\"https://www.nginx.com/blog/rate-limiting-nginx/%EF%BC%89%E3%80%82\">https://www.nginx.com/blog/rate-limiting-nginx/）。</a></p>\n<p>如果自带的模块不能满足，那就上自定义的 lua 模块吧，参考 OpenResty 提供的 Lua 限流模块 lua-resty-limit-traffic。</p>\n<h4 id=\"2-TokenServer-流控\"><a href=\"#2-TokenServer-流控\" class=\"headerlink\" title=\"2 TokenServer 流控\"></a>2 TokenServer 流控</h4><blockquote>\n<p>这里借用了 Sentinel 中的 TokenServer 叫法，Sentinel 集群流控的介绍可以参考官方文档：Sentinel集群流控（<a href=\"https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%EF%BC%89%E3%80%82\">https://github.com/alibaba/Sentinel/wiki/集群流控）。</a></p>\n</blockquote>\n<p>这类流控的思路是找一个 TokenServer 来专门来管控流控配额，包括统计总调用量，判断单个请求是否允许等等，应用服务器作为客户端与 TokenServer 通信来获取配额。因为流控的逻辑在 TokenServer 内部统一处理，因此单机流控中讨论的算法同样适用。</p>\n<p>很自然地能想到，这类流控非常依赖于 TokenServer 的性能和可用性。</p>\n<p>性能方面，单点的 TokenServer 很容易成为瓶颈，查 Sentinel 源码，其中使用了 Netty 来做网络通信，数据包采用自定义格式，其他性能优化能找到的不多。</p>\n<p>可用性方面，就像 Sentinel 官方文档中讲的，若在生产环境使用 TokenServer 集群限流，必须要解决以下问题：</p>\n<p>Token Server 自动管理、调度（分配/选举 Token Server）</p>\n<p>Token Server 高可用，在某个 Server 不可用时自动 failover 到其它机器</p>\n<p>目前 Sentinel 的 TokenServer 默认并没有实现这些能力，需要定制或增加其他系统来实现，例如，采用一种分布式一致性协议来做集群选举，或者借助一组 monitor 来监控状态，实现成本还是挺高的。</p>\n<h4 id=\"3-存储式流控\"><a href=\"#3-存储式流控\" class=\"headerlink\" title=\"3 存储式流控\"></a>3 存储式流控</h4><p>存储式流控的思想是通过一个存储系统来保存流控的计数值等统计信息，应用从存储中获取统计信息，然后将最新的请求信息再写入存储中。存储系统可以选择现成的 MySQL 数据库或者 Redis 缓存等，一般从性能出发选择缓存的比较多。这里选择 Tair 和 Redis 做例子。</p>\n<p><strong>Tair 流控</strong></p>\n<p>比较简单，直接上代码实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean tryAcquire(String key) &#123;</span><br><span class=\"line\">  // 以秒为单位构建tair的key</span><br><span class=\"line\">  String wrappedKey = wrapKey(key);</span><br><span class=\"line\">  // 每次请求+1，初始值为0，key的有效期设置5s</span><br><span class=\"line\">  Result&lt;Integer&gt; result = tairManager.incr(NAMESPACE, wrappedKey, 1, 0, 5);</span><br><span class=\"line\">  return result.isSuccess() &amp;&amp; result.getValue() &lt;= threshold;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private String wrapKey(String key) &#123;</span><br><span class=\"line\">  long sec = System.currentTimeMillis() / 1000L;</span><br><span class=\"line\">  return key + &quot;:&quot; + sec;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是感觉太简单了点？得益于 Tair 的高性能，这种方式可以很好地支撑大流量。</p>\n<p>这种 Tair 流控的方案实际上用的简单窗口的思路，每个 key 以每秒为一个时间窗口做 QPS 控制（QPM/QPD 原理类似）。关键在于用到了 Tair 的这个 API：</p>\n<blockquote>\n<p>incr</p>\n</blockquote>\n<p>Result incr(int namespace, Serializable key, int value, int defaultValue, int expireTime)<br>描述<br>增加计数。注意：incr 前不要 put！！<br>参数<br>namespace - 申请时分配的 namespace<br>key - key 列表，不超过 1k<br>value - 增加量<br>defaultValue - 第一次调用 incr 时的 key 的 count 初始值，第一次返回的值为 defaultValue + value。<br>expireTime - 数据过期时间，单位为秒，可设相对时间或绝对时间（Unix 时间戳）。expireTime = 0，表示数据永不过期。expireTime &gt; 0，表示设置过期时间。若 expireTime &gt; 当前时间的时间戳，则表示使用绝对时间，否则使用相对时间。expireTime &lt; 0，表示不关注过期时间，若之前设过过期时间，则已之前的过期时间为准，若没有，则作为永不过期处理，但当前 mdb 统一当做永不过期来处理。<br>返回值<br>Result 对象，返回值可为负值。当 key 不存在时，第一次返回 defaultValue+ value。后续的 incr 基于该值增加 value。</p>\n<p>当然这种方式也有缺点：</p>\n<ul>\n<li>简单窗口的临界突变问题。</li>\n<li>Tair 的可靠性问题，需要有降级方案。上面其实也说了，中心化的流控一般都需要搭配降级的单机流控。</li>\n<li>集群机器的时间同步问题。由于生成 key 会用到集群机器的本地时间，因此要求机器时间必须是一致的。</li>\n</ul>\n<p>打个比方，不同机器时间稍微差个 10ms，在时间窗口的间隔点上的统计就会产生比较大的误差，比如说在同一时刻，一台机器时间是 0.990，一台是 1.000，两者调用 incr 时操作的 key 不一样，精度自然就会受影响。</p>\n<p><strong>Redis 流控</strong></p>\n<p>Redis 支持丰富的数据结构，性能也不错，其“单进程”模型方便同步控制，因此非常适合用来做分布式流控的存储。</p>\n<p>1）简单窗口实现</p>\n<p>使用 Redis 实现简单窗口流控的思路跟使用 Tair 是一致的。Redis 也提供了 INCR 命令用于计数，同时 Redis 的“单进程”模型也提供了很好的并发保护。Redis 的官方文档就写了如何使用 INCR 来实现 Rate Limiter，我这里稍作翻译了下：</p>\n<blockquote>\n<p>Redis INCR key(<a href=\"https://redis.io/commands/incr\">https://redis.io/commands/incr</a>)</p>\n</blockquote>\n<p>以简单窗口为例，最简单直接的实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FUNCTION LIMIT_API_CALL(ip)</span><br><span class=\"line\">ts = CURRENT_UNIX_TIME()</span><br><span class=\"line\">keyname = ip+&quot;:&quot;+ts</span><br><span class=\"line\">current = GET(keyname)</span><br><span class=\"line\">IF current != NULL AND current &gt; 10 THEN</span><br><span class=\"line\">    ERROR &quot;too many requests per second&quot;</span><br><span class=\"line\">ELSE</span><br><span class=\"line\">    MULTI</span><br><span class=\"line\">        INCR(keyname,1)</span><br><span class=\"line\">        EXPIRE(keyname,10)</span><br><span class=\"line\">    EXEC</span><br><span class=\"line\">    PERFORM_API_CALL()</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>实现上与上述的 Tair 类似，也是对每个 key 以秒为单位维护一个计数器，差别在于因为 Redis 没有提供原子的 INCR + EXPIRE 指令，所以在 INCR 之后需要再调用一次 EXPIRE 来设置 key 的有效期。同时在外层以 MULTI 和 EXEC 包裹以保证事务性。</p>\n<p>如果不想每次都调用 EXPIRE，可以考虑第二种方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FUNCTION LIMIT_API_CALL(ip):</span><br><span class=\"line\">current = GET(ip)</span><br><span class=\"line\">IF current != NULL AND current &gt; 10 THEN</span><br><span class=\"line\">    ERROR &quot;too many requests per second&quot;</span><br><span class=\"line\">ELSE</span><br><span class=\"line\">    value = INCR(ip)</span><br><span class=\"line\">    IF value == 1 THEN</span><br><span class=\"line\">        EXPIRE(ip,1)</span><br><span class=\"line\">    END</span><br><span class=\"line\">    PERFORM_API_CALL()</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>计数器的有效期在第一次 INCR 时设置为 1s，因此不需要对 key 进行额外处理。</p>\n<p>不过需要注意的是，这种方式存在一种隐藏的竞争条件。如果客户端在第一次调用了 INCR 后，由于应用崩溃或其他原因没有调用 EXPIRE，计数器会一直存在。</p>\n<p>针对方式二的这个问题，可以用 lua 脚本解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local current</span><br><span class=\"line\">current = redis.call(&quot;incr&quot;,KEYS[1])</span><br><span class=\"line\">if tonumber(current) == 1 then</span><br><span class=\"line\">    redis.call(&quot;expire&quot;,KEYS[1],1)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>第三种方式是通过 Redis 的 list 结构来实现。更复杂一些但可以记录下每次的请求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FUNCTION LIMIT_API_CALL(ip)</span><br><span class=\"line\">current = LLEN(ip)</span><br><span class=\"line\">IF current &gt; 10 THEN</span><br><span class=\"line\">    ERROR &quot;too many requests per second&quot;</span><br><span class=\"line\">ELSE</span><br><span class=\"line\">    IF EXISTS(ip) == FALSE              #1</span><br><span class=\"line\">        MULTI</span><br><span class=\"line\">            RPUSH(ip,ip)</span><br><span class=\"line\">            EXPIRE(ip,1)</span><br><span class=\"line\">        EXEC</span><br><span class=\"line\">    ELSE</span><br><span class=\"line\">        RPUSHX(ip,ip)</span><br><span class=\"line\">    END</span><br><span class=\"line\">    PERFORM_API_CALL()</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n\n<p>这里也有一个隐含的竞争条件，在执行到 EXIST 判断这一行（#1 位置）时，两个客户端的 EXIST 命令可能都会返回 false，因此 MULTI/EXEC 块里的命令会被执行两次，不过这种情况很少出现，不太会影响计数器的准确性。</p>\n<p>上述的几种方式还可以进一步优化，因为 INCR 和 RPUSH 这些命令都会返回操作后的计数器值，所以可以使用 set-then-get 的方式获取计数器值。</p>\n<p>将简单窗口改造成滑动窗口也是类似的思路，把单一的 key 换成一个 hash 结构，hash 里面为每个子窗口保存一个计数值，在统计时，将同个 hash 中所有子窗口的计数值相加即可。</p>\n<p>2）令牌桶/漏桶实现</p>\n<p>用 Redis 实现令牌桶或者漏桶也非常简单。以令牌桶为例，在实现上，可以用两个 key 分别存储每个用户的可用 token 数和上次请求时间，另一种可能更好的办法是使用 Redis 的 hash 数据结构。</p>\n<p>下图的示例是一个用户 user_1 当前在 Redis 中保存的流控配额数据：令牌桶中当前剩余 2 个 token，最近一次访问的时间戳是 1490868000。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/7a12af696eef4851ab16afb0d44426ea.png\" alt=\"image.png\"></p>\n<p>当收到一个新请求时，Redis 客户端要执行的操作与我们在单机流控算法中看到的一样。首先，从对应 hash 中获得当前配额数据（HGETALL），根据当前时间戳、上次请求的时间戳和 token 填充速度计算要填充的 token 数；然后，判断是否放行，更新新的时间戳和 token 数（HMSET）。</p>\n<p>一个示例如下：</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/2e0a53670860429faca7b77337931117.png\" alt=\"image.png\"></p>\n<p>同样的，如果要求比较高的精度，这里必须要对客户端的操作做并发控制。</p>\n<p>不做同步控制可能导致的问题示例：桶里只有一个 token，两个客户端同时请求时出现并发冲突，结果是请求都会放行。</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/c86cda7753e4469b8f517da77be5a4af.png\" alt=\"image.png\"></p>\n<p>lua 代码示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local tokens_key = KEYS[1]</span><br><span class=\"line\">local timestamp_key = KEYS[2]</span><br><span class=\"line\"></span><br><span class=\"line\">local rate = tonumber(ARGV[1])</span><br><span class=\"line\">local capacity = tonumber(ARGV[2])</span><br><span class=\"line\">local now = tonumber(ARGV[3])</span><br><span class=\"line\">local requested = tonumber(ARGV[4])</span><br><span class=\"line\"></span><br><span class=\"line\">local fill_time = capacity/rate</span><br><span class=\"line\">local ttl = math.floor(fill_time*2)</span><br><span class=\"line\"></span><br><span class=\"line\">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span><br><span class=\"line\">if last_tokens == nil then</span><br><span class=\"line\">  last_tokens = capacity</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span><br><span class=\"line\">if last_refreshed == nil then</span><br><span class=\"line\">  last_refreshed = 0</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">local delta = math.max(0, now-last_refreshed)</span><br><span class=\"line\">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span><br><span class=\"line\">local allowed = filled_tokens &gt;= requested</span><br><span class=\"line\">local new_tokens = filled_tokens</span><br><span class=\"line\">if allowed then</span><br><span class=\"line\">  new_tokens = filled_tokens - requested</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span><br><span class=\"line\">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123; allowed, new_tokens &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）滑动日志实现</p>\n<p>得益于 Redis 的 Sorted Set 结构，实现滑动日志变得异常简单。流程大致如下：</p>\n<p>a）每个用户有一个对应的 Sorted Set 记录请求日志。</p>\n<ul>\n<li>其中每个元素的 key 和 value 可以是相同的，即请求的时间戳。</li>\n<li>Sorted Set 可以根据时间窗口大小设置有效期，比如时间窗口为 1s 时设置过期时间 5s，在请求量不大时可以节省 Redis 服务器内存。</li>\n</ul>\n<p>b）当收到一个新的用户请求时，首先通过 ZREMRANGEBYSCORE 命令删除 Sorted Set 中过期的元素，这里的过期即：</p>\n<p>请求时间戳 t &lt; 当前时间戳 now - 时间窗口大小 interval</p>\n<p>c）使用 ZADD 将当前请求添加到 Set 中。</p>\n<p>d）使用 ZCOUNT 获取当前剩余 Set 大小，判断是否需要流控。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long now = System.currentTimeMillis();</span><br><span class=\"line\">long maxScoreMs = now - windowInSecond * 1000;</span><br><span class=\"line\"></span><br><span class=\"line\">Transaction redis = jedisPool.getResource().multi();</span><br><span class=\"line\">redis.zremrangeByScore(key, 0, maxScoreMs);</span><br><span class=\"line\">redis.zadd(key, now, now + &quot;-&quot; + Math.random()); // 加入一个随机值使得member不重复</span><br><span class=\"line\">redis.expire(key, windowInSecond);</span><br><span class=\"line\">redis.exec();</span><br></pre></td></tr></table></figure>\n\n<p>另一个 JS 实现的代码示例：<br><a href=\"https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js\">https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js</a></p>\n<p>由于滑动日志算法的空间复杂度较其他算法高，使用滑动日志算法时，需要注意监控 Redis 内存的使用量。</p>\n<p>4）并发控制</p>\n<p>上面的几种算法都提到了不做并发控制可能带来的竞态条件，但额外的并发控制必然会带来性能下降，通常需要在精度和性能之间做取舍。Redis 流控的并发控制常见的有几类：</p>\n<ul>\n<li>使用 Redis 事务 MULTI/EXEC。</li>\n<li>使用 RedLock（<a href=\"https://redis.io/topics/distlock%EF%BC%89\">https://redis.io/topics/distlock）</a> 等分布式锁，要求每个客户端操作前先获取对应 key 的分布式锁。</li>\n<li>Lua 脚本。</li>\n</ul>\n<p>最好通过性能测试来决定使用哪一种方式。</p>\n<h4 id=\"4-扩展的一些思考\"><a href=\"#4-扩展的一些思考\" class=\"headerlink\" title=\"4 扩展的一些思考\"></a>4 扩展的一些思考</h4><p>分布式流控带来了网络通信、加锁同步等开销，会对性能带来一定影响。同时分布式环境的可靠性也会带来更多挑战。如何设计一个高性能、高可靠性的分布式流控系统？这可能是个涉及到整个系统方方面面的大话题。</p>\n<p>分享一下个人的一些思考，欢迎讨论：</p>\n<p>1）根据实际诉求，合理搭配不同层的多级流控是个不错的方式，尽量把流量拦在外层。例如常见的接口层 Nginx 流控 + 应用层流控。</p>\n<p>2）选择一个合适的缓存系统保存流控的动态数据，这个一般跟着公司的统一技术架构走。</p>\n<p>3）将流控的静态配置放到配置中心（例如 Diamond）。</p>\n<p>4）设计时要考虑分布式流控不可用的情况（例如缓存挂掉），必要时切到单机流控，使用 Sentinel 成熟可靠。</p>\n<p>5）很多时候对精度的要求没那么高，因为一般都会允许一定的突发量。这时候可以做一些性能的优化。性能的最大瓶颈在于每次请求都会访问一次缓存，我之前在设计时就采用了一种折中的办法：</p>\n<ul>\n<li>将可用配额的一部分，按一定比例（例如 50%），先预分配给集群内的机器。一般是平均分配，如果预先就已经知道每台机器的流量权重，可以加权分配。每台机器消耗配额的速率不同，中间也可能有机器宕机，可能有扩缩容，因此预分配的比例不宜太大，当然也不宜太小。</li>\n<li>每台机器在配额耗尽时，向中心系统请求配额，这里的一个优化点是每台机器会记录自身配额消耗的速率（等同于承受的流量速率），按照速率大小申请不同大小的配额，消耗速率大则一次性申请更多。</li>\n<li>在整体可用配额不足一定比例时（例如 10%），限制每台机器一次可申请的配额数，按剩余窗口大小计算发放配额的大小，并且每次发放量不超过剩余配额的一定比例（例如 50%），使得剩余的流量能够平滑地过渡。</li>\n</ul>\n<p>五 总结</p>\n<p>分布式流控的算法其实是单机流控的延伸，算法本质是一样的。这里按我的个人理解总结了上述几种流控算法的复杂度和适用场景。<br><img src=\"https://ucc.alicdn.com/pic/developer-ecology/4ba212a1a7de40a6ba7601faa653b4d9.png\" alt=\"image.png\"></p>"},{"title":"golang笔记","date":"2015-09-01T15:49:37.000Z","id":"golang-summary","_content":"\ngo gc\n\ngo kitex hertz\n\n性能分析\n\n匹配 网关\n\nredis\n\n","source":"_posts/golang-summary.md","raw":"---\ntitle: golang笔记\ndate: 2015-09-01 23:49:37\ntags:\n  - 笔记\nid: golang-summary\ncategories:\n  - 笔记\n---\n\ngo gc\n\ngo kitex hertz\n\n性能分析\n\n匹配 网关\n\nredis\n\n","slug":"golang-summary","published":1,"updated":"2021-09-02T02:03:39.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2dv7s20000wcmnap4z2h0z","content":"<p>go gc</p>\n<p>go kitex hertz</p>\n<p>性能分析</p>\n<p>匹配 网关</p>\n<p>redis</p>\n","site":{"data":{}},"excerpt":"","more":"<p>go gc</p>\n<p>go kitex hertz</p>\n<p>性能分析</p>\n<p>匹配 网关</p>\n<p>redis</p>\n"},{"title":"notice","date":"2099-11-11T15:59:59.000Z","id":"notice","_content":"\n## 文章还在迁移中，更多旧文章见[主页](https://192.144.167.243/)\n\n主页已停止更新，新文章都在这里。\n","source":"_posts/notice.md","raw":"---\ntitle: notice\ndate: 2099-11-11 23:59:59\ntags:\n  - 笔记\nid: notice\ncategories:\n  - 公告\n---\n\n## 文章还在迁移中，更多旧文章见[主页](https://192.144.167.243/)\n\n主页已停止更新，新文章都在这里。\n","slug":"notice","published":1,"updated":"2021-09-02T02:03:39.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2dv7s80002wcmncyl5da6p","content":"<h2 id=\"文章还在迁移中，更多旧文章见主页\"><a href=\"#文章还在迁移中，更多旧文章见主页\" class=\"headerlink\" title=\"文章还在迁移中，更多旧文章见主页\"></a>文章还在迁移中，更多旧文章见<a href=\"https://192.144.167.243/\">主页</a></h2><p>主页已停止更新，新文章都在这里。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文章还在迁移中，更多旧文章见主页\"><a href=\"#文章还在迁移中，更多旧文章见主页\" class=\"headerlink\" title=\"文章还在迁移中，更多旧文章见主页\"></a>文章还在迁移中，更多旧文章见<a href=\"https://192.144.167.243/\">主页</a></h2><p>主页已停止更新，新文章都在这里。</p>\n"}],"PostAsset":[{"_id":"source/_posts/wordpress-build/wordpress.png","slug":"wordpress.png","post":"cksr0voz100006cmn3kswbl5v","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cksr0voz100006cmn3kswbl5v","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksr2m80m000380mne2pt5dyz"},{"post_id":"ckpqi95k00000e9lw258vf7vr","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksr2ozfa0000b8mn43pb29qn"},{"post_id":"cksr02cky00009kmn3ehn9lja","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksr2pg7o0001b8mn5y8p2p5e"},{"post_id":"cksraj6r90000ssmn11gqcrsf","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrakj2x0002ssmndmlm8ipl"},{"post_id":"cksrd9hvm0003ssmn8kxm7eix","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrda8sh0005ssmnhzt1hbva"},{"post_id":"cksrg67bx0006ssmnh3hmbmki","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrg6r800008ssmnhnkub0ul"},{"post_id":"cksrg9qch0009ssmn5h10evws","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrgagn4000bssmn8xs5bwcu"},{"post_id":"cksrgmpej000cssmne1ydab53","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrgnxpo000essmne21zb5xs"},{"post_id":"cksrgqixf000fssmn17s5cfja","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrgr504000hssmn7n1j3x2a"},{"post_id":"cksrgwkhf000issmngzyba8tu","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrgwzs5000kssmn3ejwdq9y"},{"post_id":"cksrhe20i000lssmnbbxp7xir","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrhll29000nssmn1k69eq14"},{"post_id":"cksrhmyab000ossmn6xap1wab","category_id":"cksr2m80l000280mnh3x39nkl","_id":"cksrhnuxu000rssmnhixs0dmz"},{"post_id":"ckt1g0lje0000hcmn80ozcxl4","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljl0006hcmn8qdn4s1s"},{"post_id":"ckt1g0lji0001hcmn9qlr0xeo","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljm0009hcmne8j4eg27"},{"post_id":"ckt1g0ljj0003hcmn6pbe3qou","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljm000chcmn58tlf7t8"},{"post_id":"ckt1g0ljk0005hcmn09p3dh6p","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljn000fhcmn6xfm686l"},{"post_id":"ckt1g0ljl0008hcmnhedk6ing","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljo000ihcmn9gb64mkn"},{"post_id":"ckt1g0ljm000bhcmn03tyhnfe","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljq000khcmn750t8wh5"},{"post_id":"ckt1g0ljn000ehcmnadh80a0i","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljr000nhcmn0l7obhhk"},{"post_id":"ckt1g0ljo000hhcmndud45khv","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljt000phcmn639h2n58"},{"post_id":"ckt1g0ljr000mhcmn4k7vcoz4","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljv000uhcmnhr6qe6ba"},{"post_id":"ckt1g0ljs000ohcmndsby7m8y","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljw000xhcmncvuh53nw"},{"post_id":"ckt1g0ljt000rhcmn0y4z1s27","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0ljy0010hcmn9rug7dae"},{"post_id":"ckt1g0lju000thcmn64bufrtl","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk10013hcmn3xzo6drd"},{"post_id":"ckt1g0ljv000whcmnctkq73ki","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk30016hcmn1k2t1o2r"},{"post_id":"ckt1g0ljx000zhcmnfxmb3hgd","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk50019hcmn1bz1hclv"},{"post_id":"ckt1g0lk00012hcmn3h5b236p","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk7001chcmn1xl14ddi"},{"post_id":"ckt1g0lk20015hcmn11qg84nr","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk8001ehcmn9dsmcfem"},{"post_id":"ckt1g0lk40018hcmn3yqhhm1j","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk8001ghcmn50e6gji1"},{"post_id":"ckt1g0lk6001bhcmn7fx13cvt","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lk9001hhcmnab9h8zxs"},{"post_id":"ckt1g0lkb001ihcmn1t3nhqo8","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lke001nhcmn3jdg4ana"},{"post_id":"ckt1g0lkb001jhcmn6i2z1jo6","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lkf001phcmn5xum735n"},{"post_id":"ckt1g0lkc001lhcmn1cpke6y4","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lkf001qhcmn0c00at1a"},{"post_id":"ckt1g0lkg001rhcmn5d05e9qo","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt1g0lli001thcmn1f2n39zu"},{"post_id":"ckt2dv7s20000wcmnap4z2h0z","category_id":"cksr2m80l000280mnh3x39nkl","_id":"ckt2dv7s80003wcmn6yw4gd6d"},{"post_id":"ckt2dv7s80002wcmncyl5da6p","category_id":"ckt2dv7s90004wcmn7yv66ft7","_id":"ckt2dv7sf0006wcmn1tmg4be9"}],"PostTag":[{"post_id":"ckpqi95k00000e9lw258vf7vr","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksr02cl100039kmn0tl52mpv"},{"post_id":"cksr02cky00009kmn3ehn9lja","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksr02cl100049kmn7c9tcvzz"},{"post_id":"cksr0voz100006cmn3kswbl5v","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksr0voz500016cmngrekaxtx"},{"post_id":"cksr24dk500005gmn8rso7lhc","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksr24dk700015gmn1jml4g5o"},{"post_id":"cksraj6r90000ssmn11gqcrsf","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrakj2x0001ssmn9bfx62fw"},{"post_id":"cksrd9hvm0003ssmn8kxm7eix","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrda8sg0004ssmncl7vh0nb"},{"post_id":"cksrg67bx0006ssmnh3hmbmki","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrg6r7z0007ssmndyxhhq3x"},{"post_id":"cksrg9qch0009ssmn5h10evws","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrgagn4000assmnbk8r8n56"},{"post_id":"cksrgmpej000cssmne1ydab53","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrgnxpo000dssmnec2s1zbz"},{"post_id":"cksrgqixf000fssmn17s5cfja","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrgr504000gssmn8jnr8gcv"},{"post_id":"cksrgwkhf000issmngzyba8tu","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrgwzs5000jssmnadtgecn3"},{"post_id":"cksrhe20i000lssmnbbxp7xir","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrhll29000mssmn0bat91xu"},{"post_id":"cksrhmyab000ossmn6xap1wab","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"cksrhnuxu000qssmn6jo4h3ol"},{"post_id":"ckt1g0lje0000hcmn80ozcxl4","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljj0002hcmngiu0av01"},{"post_id":"ckt1g0lji0001hcmn9qlr0xeo","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljk0004hcmn4hybgx8q"},{"post_id":"ckt1g0ljj0003hcmn6pbe3qou","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljl0007hcmn2a9qfjjc"},{"post_id":"ckt1g0ljk0005hcmn09p3dh6p","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljm000ahcmn7md800i4"},{"post_id":"ckt1g0ljl0008hcmnhedk6ing","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljn000dhcmn8i3gbx8o"},{"post_id":"ckt1g0ljm000bhcmn03tyhnfe","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljo000ghcmnd5xh9z3t"},{"post_id":"ckt1g0ljn000ehcmnadh80a0i","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljo000jhcmn2f5x96x0"},{"post_id":"ckt1g0ljo000hhcmndud45khv","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljr000lhcmn5a0q269p"},{"post_id":"ckt1g0ljr000mhcmn4k7vcoz4","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljt000qhcmn7vp58j4u"},{"post_id":"ckt1g0ljs000ohcmndsby7m8y","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lju000shcmn0ez46sjs"},{"post_id":"ckt1g0ljt000rhcmn0y4z1s27","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljv000vhcmnccap5pqy"},{"post_id":"ckt1g0lju000thcmn64bufrtl","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljw000yhcmn6hqs77pm"},{"post_id":"ckt1g0ljv000whcmnctkq73ki","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0ljy0011hcmn09x6gouo"},{"post_id":"ckt1g0ljx000zhcmnfxmb3hgd","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lk20014hcmngkrc39hz"},{"post_id":"ckt1g0lk00012hcmn3h5b236p","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lk40017hcmnc1w4ak5r"},{"post_id":"ckt1g0lk20015hcmn11qg84nr","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lk6001ahcmna3wnffus"},{"post_id":"ckt1g0lk40018hcmn3yqhhm1j","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lk8001dhcmndtlh8q43"},{"post_id":"ckt1g0lk6001bhcmn7fx13cvt","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lk8001fhcmnbsfa5xym"},{"post_id":"ckt1g0lkb001ihcmn1t3nhqo8","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lkc001khcmncgkvckru"},{"post_id":"ckt1g0lkb001jhcmn6i2z1jo6","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lke001mhcmn0oonbdvl"},{"post_id":"ckt1g0lkc001lhcmn1cpke6y4","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0lkf001ohcmn5g1f203i"},{"post_id":"ckt1g0lkg001rhcmn5d05e9qo","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt1g0llh001shcmn2tk91b5r"},{"post_id":"ckt2dv7s20000wcmnap4z2h0z","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt2dv7s70001wcmn7az99tux"},{"post_id":"ckt2dv7s80002wcmncyl5da6p","tag_id":"cksr02ckz00019kmn7c9ggqe7","_id":"ckt2dv7sf0005wcmn1bjoh4p6"}],"Tag":[{"name":"demo","_id":"ckpqi95k40001e9lwdhrz1elf"},{"name":"hello","_id":"ckpqi95k50002e9lwgjm6310q"},{"name":"笔记","_id":"cksr02ckz00019kmn7c9ggqe7"}]}}